/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["someLibName"] = factory();
	else
		root["someLibName"] = factory();
})(self, function() {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n\n\n//# sourceURL=webpack://someLibName/./node_modules/base64-js/index.js?");

/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nconst base64 = __webpack_require__(/*! base64-js */ \"./node_modules/base64-js/index.js\")\nconst ieee754 = __webpack_require__(/*! ieee754 */ \"./node_modules/ieee754/index.js\")\nconst customInspectSymbol =\n  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation\n    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\n    : null\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nconst K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    const arr = new Uint8Array(1)\n    const proto = { foo: function () { return 42 } }\n    Object.setPrototypeOf(proto, Uint8Array.prototype)\n    Object.setPrototypeOf(arr, proto)\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  const buf = new Uint8Array(length)\n  Object.setPrototypeOf(buf, Buffer.prototype)\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayView(value)\n  }\n\n  if (value == null) {\n    throw new TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof SharedArrayBuffer !== 'undefined' &&\n      (isInstance(value, SharedArrayBuffer) ||\n      (value && isInstance(value.buffer, SharedArrayBuffer)))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  const valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  const b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nObject.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)\nObject.setPrototypeOf(Buffer, Uint8Array)\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpreted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  const length = byteLength(string, encoding) | 0\n  let buf = createBuffer(length)\n\n  const actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  const length = array.length < 0 ? 0 : checked(array.length) | 0\n  const buf = createBuffer(length)\n  for (let i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayView (arrayView) {\n  if (isInstance(arrayView, Uint8Array)) {\n    const copy = new Uint8Array(arrayView)\n    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)\n  }\n  return fromArrayLike(arrayView)\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  let buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(buf, Buffer.prototype)\n\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    const len = checked(obj.length) | 0\n    const buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  let x = a.length\n  let y = b.length\n\n  for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  let i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  const buffer = Buffer.allocUnsafe(length)\n  let pos = 0\n  for (i = 0; i < list.length; ++i) {\n    let buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      if (pos + buf.length > buffer.length) {\n        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)\n        buf.copy(buffer, pos)\n      } else {\n        Uint8Array.prototype.set.call(\n          buffer,\n          buf,\n          pos\n        )\n      }\n    } else if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    } else {\n      buf.copy(buffer, pos)\n    }\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  const len = string.length\n  const mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  let loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  const i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  const len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (let i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  const len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (let i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  const len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (let i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  const length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  let str = ''\n  const max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\nif (customInspectSymbol) {\n  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  let x = thisEnd - thisStart\n  let y = end - start\n  const len = Math.min(x, y)\n\n  const thisCopy = this.slice(thisStart, thisEnd)\n  const targetCopy = target.slice(start, end)\n\n  for (let i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  let indexSize = 1\n  let arrLength = arr.length\n  let valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  let i\n  if (dir) {\n    let foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      let found = true\n      for (let j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  const remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  const strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  let i\n  for (i = 0; i < length; ++i) {\n    const parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  const remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return asciiWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  const res = []\n\n  let i = start\n  while (i < end) {\n    const firstByte = buf[i]\n    let codePoint = null\n    let bytesPerSequence = (firstByte > 0xEF)\n      ? 4\n      : (firstByte > 0xDF)\n          ? 3\n          : (firstByte > 0xBF)\n              ? 2\n              : 1\n\n    if (i + bytesPerSequence <= end) {\n      let secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nconst MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  const len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  let res = ''\n  let i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  const len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  let out = ''\n  for (let i = start; i < end; ++i) {\n    out += hexSliceLookupTable[buf[i]]\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  const bytes = buf.slice(start, end)\n  let res = ''\n  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n  for (let i = 0; i < bytes.length - 1; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  const len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  const newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(newBuf, Buffer.prototype)\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUintLE =\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUintBE =\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  let val = this[offset + --byteLength]\n  let mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUint8 =\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUint16LE =\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUint16BE =\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUint32LE =\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUint32BE =\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const lo = first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24\n\n  const hi = this[++offset] +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    last * 2 ** 24\n\n  return BigInt(lo) + (BigInt(hi) << BigInt(32))\n})\n\nBuffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const hi = first * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  const lo = this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last\n\n  return (BigInt(hi) << BigInt(32)) + BigInt(lo)\n})\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let i = byteLength\n  let mul = 1\n  let val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = this[offset + 4] +\n    this[offset + 5] * 2 ** 8 +\n    this[offset + 6] * 2 ** 16 +\n    (last << 24) // Overflow\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24)\n})\n\nBuffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = (first << 24) + // Overflow\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last)\n})\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUintLE =\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let mul = 1\n  let i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUintBE =\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUint8 =\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUint16LE =\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint16BE =\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint32LE =\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUint32BE =\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction wrtBigUInt64LE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  return offset\n}\n\nfunction wrtBigUInt64BE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset + 7] = lo\n  lo = lo >> 8\n  buf[offset + 6] = lo\n  lo = lo >> 8\n  buf[offset + 5] = lo\n  lo = lo >> 8\n  buf[offset + 4] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset + 3] = hi\n  hi = hi >> 8\n  buf[offset + 2] = hi\n  hi = hi >> 8\n  buf[offset + 1] = hi\n  hi = hi >> 8\n  buf[offset] = hi\n  return offset + 8\n}\n\nBuffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = 0\n  let mul = 1\n  let sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  let sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nBuffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  const len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      const code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  } else if (typeof val === 'boolean') {\n    val = Number(val)\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  let i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    const bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    const len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// CUSTOM ERRORS\n// =============\n\n// Simplified versions from Node, changed for Buffer-only usage\nconst errors = {}\nfunction E (sym, getMessage, Base) {\n  errors[sym] = class NodeError extends Base {\n    constructor () {\n      super()\n\n      Object.defineProperty(this, 'message', {\n        value: getMessage.apply(this, arguments),\n        writable: true,\n        configurable: true\n      })\n\n      // Add the error code to the name to include it in the stack trace.\n      this.name = `${this.name} [${sym}]`\n      // Access the stack to generate the error message including the error code\n      // from the name.\n      this.stack // eslint-disable-line no-unused-expressions\n      // Reset the name to the actual name.\n      delete this.name\n    }\n\n    get code () {\n      return sym\n    }\n\n    set code (value) {\n      Object.defineProperty(this, 'code', {\n        configurable: true,\n        enumerable: true,\n        value,\n        writable: true\n      })\n    }\n\n    toString () {\n      return `${this.name} [${sym}]: ${this.message}`\n    }\n  }\n}\n\nE('ERR_BUFFER_OUT_OF_BOUNDS',\n  function (name) {\n    if (name) {\n      return `${name} is outside of buffer bounds`\n    }\n\n    return 'Attempt to access memory outside buffer bounds'\n  }, RangeError)\nE('ERR_INVALID_ARG_TYPE',\n  function (name, actual) {\n    return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`\n  }, TypeError)\nE('ERR_OUT_OF_RANGE',\n  function (str, range, input) {\n    let msg = `The value of \"${str}\" is out of range.`\n    let received = input\n    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n      received = addNumericalSeparator(String(input))\n    } else if (typeof input === 'bigint') {\n      received = String(input)\n      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\n        received = addNumericalSeparator(received)\n      }\n      received += 'n'\n    }\n    msg += ` It must be ${range}. Received ${received}`\n    return msg\n  }, RangeError)\n\nfunction addNumericalSeparator (val) {\n  let res = ''\n  let i = val.length\n  const start = val[0] === '-' ? 1 : 0\n  for (; i >= start + 4; i -= 3) {\n    res = `_${val.slice(i - 3, i)}${res}`\n  }\n  return `${val.slice(0, i)}${res}`\n}\n\n// CHECK FUNCTIONS\n// ===============\n\nfunction checkBounds (buf, offset, byteLength) {\n  validateNumber(offset, 'offset')\n  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {\n    boundsError(offset, buf.length - (byteLength + 1))\n  }\n}\n\nfunction checkIntBI (value, min, max, buf, offset, byteLength) {\n  if (value > max || value < min) {\n    const n = typeof min === 'bigint' ? 'n' : ''\n    let range\n    if (byteLength > 3) {\n      if (min === 0 || min === BigInt(0)) {\n        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`\n      } else {\n        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +\n                `${(byteLength + 1) * 8 - 1}${n}`\n      }\n    } else {\n      range = `>= ${min}${n} and <= ${max}${n}`\n    }\n    throw new errors.ERR_OUT_OF_RANGE('value', range, value)\n  }\n  checkBounds(buf, offset, byteLength)\n}\n\nfunction validateNumber (value, name) {\n  if (typeof value !== 'number') {\n    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)\n  }\n}\n\nfunction boundsError (value, length, type) {\n  if (Math.floor(value) !== value) {\n    validateNumber(value, type)\n    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)\n  }\n\n  if (length < 0) {\n    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()\n  }\n\n  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',\n                                    `>= ${type ? 1 : 0} and <= ${length}`,\n                                    value)\n}\n\n// HELPER FUNCTIONS\n// ================\n\nconst INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  let codePoint\n  const length = string.length\n  let leadSurrogate = null\n  const bytes = []\n\n  for (let i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  let c, hi, lo\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  let i\n  for (i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n\n// Create lookup table for `toString('hex')`\n// See: https://github.com/feross/buffer/issues/219\nconst hexSliceLookupTable = (function () {\n  const alphabet = '0123456789abcdef'\n  const table = new Array(256)\n  for (let i = 0; i < 16; ++i) {\n    const i16 = i * 16\n    for (let j = 0; j < 16; ++j) {\n      table[i16 + j] = alphabet[i] + alphabet[j]\n    }\n  }\n  return table\n})()\n\n// Return not function with Error if BigInt not supported\nfunction defineBigIntMethod (fn) {\n  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn\n}\n\nfunction BufferBigIntNotDefined () {\n  throw new Error('BigInt not supported')\n}\n\n\n//# sourceURL=webpack://someLibName/./node_modules/buffer/index.js?");

/***/ }),

/***/ "./node_modules/err-code/index.js":
/*!****************************************!*\
  !*** ./node_modules/err-code/index.js ***!
  \****************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n * @typedef {{ [key: string]: any }} Extensions\n * @typedef {Error} Err\n * @property {string} message\n */\n\n/**\n *\n * @param {Error} obj\n * @param {Extensions} props\n * @returns {Error & Extensions}\n */\nfunction assign(obj, props) {\n    for (const key in props) {\n        Object.defineProperty(obj, key, {\n            value: props[key],\n            enumerable: true,\n            configurable: true,\n        });\n    }\n\n    return obj;\n}\n\n/**\n *\n * @param {any} err - An Error\n * @param {string|Extensions} code - A string code or props to set on the error\n * @param {Extensions} [props] - Props to set on the error\n * @returns {Error & Extensions}\n */\nfunction createError(err, code, props) {\n    if (!err || typeof err === 'string') {\n        throw new TypeError('Please pass an Error to err-code');\n    }\n\n    if (!props) {\n        props = {};\n    }\n\n    if (typeof code === 'object') {\n        props = code;\n        code = '';\n    }\n\n    if (code) {\n        props.code = code;\n    }\n\n    try {\n        return assign(err, props);\n    } catch (_) {\n        props.message = err.message;\n        props.stack = err.stack;\n\n        const ErrClass = function () {};\n\n        ErrClass.prototype = Object.create(Object.getPrototypeOf(err));\n\n        // @ts-ignore\n        const output = assign(new ErrClass(), props);\n\n        return output;\n    }\n}\n\nmodule.exports = createError;\n\n\n//# sourceURL=webpack://someLibName/./node_modules/err-code/index.js?");

/***/ }),

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/***/ ((module) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n\n\n//# sourceURL=webpack://someLibName/./node_modules/events/events.js?");

/***/ }),

/***/ "./node_modules/get-browser-rtc/index.js":
/*!***********************************************!*\
  !*** ./node_modules/get-browser-rtc/index.js ***!
  \***********************************************/
/***/ ((module) => {

eval("// originally pulled out of simple-peer\n\nmodule.exports = function getBrowserRTC () {\n  if (typeof globalThis === 'undefined') return null\n  var wrtc = {\n    RTCPeerConnection: globalThis.RTCPeerConnection || globalThis.mozRTCPeerConnection ||\n      globalThis.webkitRTCPeerConnection,\n    RTCSessionDescription: globalThis.RTCSessionDescription ||\n      globalThis.mozRTCSessionDescription || globalThis.webkitRTCSessionDescription,\n    RTCIceCandidate: globalThis.RTCIceCandidate || globalThis.mozRTCIceCandidate ||\n      globalThis.webkitRTCIceCandidate\n  }\n  if (!wrtc.RTCPeerConnection) return null\n  return wrtc\n}\n\n\n//# sourceURL=webpack://someLibName/./node_modules/get-browser-rtc/index.js?");

/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n\n//# sourceURL=webpack://someLibName/./node_modules/ieee754/index.js?");

/***/ }),

/***/ "./node_modules/inherits/inherits_browser.js":
/*!***************************************************!*\
  !*** ./node_modules/inherits/inherits_browser.js ***!
  \***************************************************/
/***/ ((module) => {

eval("if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n\n\n//# sourceURL=webpack://someLibName/./node_modules/inherits/inherits_browser.js?");

/***/ }),

/***/ "./node_modules/queue-microtask/index.js":
/*!***********************************************!*\
  !*** ./node_modules/queue-microtask/index.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\nlet promise\n\nmodule.exports = typeof queueMicrotask === 'function'\n  ? queueMicrotask.bind(typeof window !== 'undefined' ? window : __webpack_require__.g)\n  // reuse resolved promise, and allocate it lazily\n  : cb => (promise || (promise = Promise.resolve()))\n    .then(cb)\n    .catch(err => setTimeout(() => { throw err }, 0))\n\n\n//# sourceURL=webpack://someLibName/./node_modules/queue-microtask/index.js?");

/***/ }),

/***/ "./node_modules/randombytes/browser.js":
/*!*********************************************!*\
  !*** ./node_modules/randombytes/browser.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n// limit of Crypto.getRandomValues()\n// https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues\nvar MAX_BYTES = 65536\n\n// Node supports requesting up to this number of bytes\n// https://github.com/nodejs/node/blob/master/lib/internal/crypto/random.js#L48\nvar MAX_UINT32 = 4294967295\n\nfunction oldBrowser () {\n  throw new Error('Secure random number generation is not supported by this browser.\\nUse Chrome, Firefox or Internet Explorer 11')\n}\n\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer\nvar crypto = __webpack_require__.g.crypto || __webpack_require__.g.msCrypto\n\nif (crypto && crypto.getRandomValues) {\n  module.exports = randomBytes\n} else {\n  module.exports = oldBrowser\n}\n\nfunction randomBytes (size, cb) {\n  // phantomjs needs to throw\n  if (size > MAX_UINT32) throw new RangeError('requested too many random bytes')\n\n  var bytes = Buffer.allocUnsafe(size)\n\n  if (size > 0) {  // getRandomValues fails on IE if size == 0\n    if (size > MAX_BYTES) { // this is the max bytes crypto.getRandomValues\n      // can do at once see https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues\n      for (var generated = 0; generated < size; generated += MAX_BYTES) {\n        // buffer.slice automatically checks if the end is past the end of\n        // the buffer so we don't have to here\n        crypto.getRandomValues(bytes.slice(generated, generated + MAX_BYTES))\n      }\n    } else {\n      crypto.getRandomValues(bytes)\n    }\n  }\n\n  if (typeof cb === 'function') {\n    return process.nextTick(function () {\n      cb(null, bytes)\n    })\n  }\n\n  return bytes\n}\n\n\n//# sourceURL=webpack://someLibName/./node_modules/randombytes/browser.js?");

/***/ }),

/***/ "./node_modules/safe-buffer/index.js":
/*!*******************************************!*\
  !*** ./node_modules/safe-buffer/index.js ***!
  \*******************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* eslint-disable node/no-deprecated-api */\nvar buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n\n\n//# sourceURL=webpack://someLibName/./node_modules/safe-buffer/index.js?");

/***/ }),

/***/ "./node_modules/simple-peer/index.js":
/*!*******************************************!*\
  !*** ./node_modules/simple-peer/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*! simple-peer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\nconst debug = __webpack_require__(/*! debug */ \"./node_modules/simple-peer/node_modules/debug/src/browser.js\")('simple-peer')\nconst getBrowserRTC = __webpack_require__(/*! get-browser-rtc */ \"./node_modules/get-browser-rtc/index.js\")\nconst randombytes = __webpack_require__(/*! randombytes */ \"./node_modules/randombytes/browser.js\")\nconst stream = __webpack_require__(/*! readable-stream */ \"./node_modules/simple-peer/node_modules/readable-stream/readable-browser.js\")\nconst queueMicrotask = __webpack_require__(/*! queue-microtask */ \"./node_modules/queue-microtask/index.js\") // TODO: remove when Node 10 is not supported\nconst errCode = __webpack_require__(/*! err-code */ \"./node_modules/err-code/index.js\")\nconst { Buffer } = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")\n\nconst MAX_BUFFERED_AMOUNT = 64 * 1024\nconst ICECOMPLETE_TIMEOUT = 5 * 1000\nconst CHANNEL_CLOSING_TIMEOUT = 5 * 1000\n\n// HACK: Filter trickle lines when trickle is disabled #354\nfunction filterTrickle (sdp) {\n  return sdp.replace(/a=ice-options:trickle\\s\\n/g, '')\n}\n\nfunction warn (message) {\n  console.warn(message)\n}\n\n/**\n * WebRTC peer connection. Same API as node core `net.Socket`, plus a few extra methods.\n * Duplex stream.\n * @param {Object} opts\n */\nclass Peer extends stream.Duplex {\n  constructor (opts) {\n    opts = Object.assign({\n      allowHalfOpen: false\n    }, opts)\n\n    super(opts)\n\n    this._id = randombytes(4).toString('hex').slice(0, 7)\n    this._debug('new peer %o', opts)\n\n    this.channelName = opts.initiator\n      ? opts.channelName || randombytes(20).toString('hex')\n      : null\n\n    this.initiator = opts.initiator || false\n    this.channelConfig = opts.channelConfig || Peer.channelConfig\n    this.channelNegotiated = this.channelConfig.negotiated\n    this.config = Object.assign({}, Peer.config, opts.config)\n    this.offerOptions = opts.offerOptions || {}\n    this.answerOptions = opts.answerOptions || {}\n    this.sdpTransform = opts.sdpTransform || (sdp => sdp)\n    this.streams = opts.streams || (opts.stream ? [opts.stream] : []) // support old \"stream\" option\n    this.trickle = opts.trickle !== undefined ? opts.trickle : true\n    this.allowHalfTrickle = opts.allowHalfTrickle !== undefined ? opts.allowHalfTrickle : false\n    this.iceCompleteTimeout = opts.iceCompleteTimeout || ICECOMPLETE_TIMEOUT\n\n    this.destroyed = false\n    this.destroying = false\n    this._connected = false\n\n    this.remoteAddress = undefined\n    this.remoteFamily = undefined\n    this.remotePort = undefined\n    this.localAddress = undefined\n    this.localFamily = undefined\n    this.localPort = undefined\n\n    this._wrtc = (opts.wrtc && typeof opts.wrtc === 'object')\n      ? opts.wrtc\n      : getBrowserRTC()\n\n    if (!this._wrtc) {\n      if (typeof window === 'undefined') {\n        throw errCode(new Error('No WebRTC support: Specify `opts.wrtc` option in this environment'), 'ERR_WEBRTC_SUPPORT')\n      } else {\n        throw errCode(new Error('No WebRTC support: Not a supported browser'), 'ERR_WEBRTC_SUPPORT')\n      }\n    }\n\n    this._pcReady = false\n    this._channelReady = false\n    this._iceComplete = false // ice candidate trickle done (got null candidate)\n    this._iceCompleteTimer = null // send an offer/answer anyway after some timeout\n    this._channel = null\n    this._pendingCandidates = []\n\n    this._isNegotiating = false // is this peer waiting for negotiation to complete?\n    this._firstNegotiation = true\n    this._batchedNegotiation = false // batch synchronous negotiations\n    this._queuedNegotiation = false // is there a queued negotiation request?\n    this._sendersAwaitingStable = []\n    this._senderMap = new Map()\n    this._closingInterval = null\n\n    this._remoteTracks = []\n    this._remoteStreams = []\n\n    this._chunk = null\n    this._cb = null\n    this._interval = null\n\n    try {\n      this._pc = new (this._wrtc.RTCPeerConnection)(this.config)\n    } catch (err) {\n      this.destroy(errCode(err, 'ERR_PC_CONSTRUCTOR'))\n      return\n    }\n\n    // We prefer feature detection whenever possible, but sometimes that's not\n    // possible for certain implementations.\n    this._isReactNativeWebrtc = typeof this._pc._peerConnectionId === 'number'\n\n    this._pc.oniceconnectionstatechange = () => {\n      this._onIceStateChange()\n    }\n    this._pc.onicegatheringstatechange = () => {\n      this._onIceStateChange()\n    }\n    this._pc.onconnectionstatechange = () => {\n      this._onConnectionStateChange()\n    }\n    this._pc.onsignalingstatechange = () => {\n      this._onSignalingStateChange()\n    }\n    this._pc.onicecandidate = event => {\n      this._onIceCandidate(event)\n    }\n\n    // HACK: Fix for odd Firefox behavior, see: https://github.com/feross/simple-peer/pull/783\n    if (typeof this._pc.peerIdentity === 'object') {\n      this._pc.peerIdentity.catch(err => {\n        this.destroy(errCode(err, 'ERR_PC_PEER_IDENTITY'))\n      })\n    }\n\n    // Other spec events, unused by this implementation:\n    // - onconnectionstatechange\n    // - onicecandidateerror\n    // - onfingerprintfailure\n    // - onnegotiationneeded\n\n    if (this.initiator || this.channelNegotiated) {\n      this._setupData({\n        channel: this._pc.createDataChannel(this.channelName, this.channelConfig)\n      })\n    } else {\n      this._pc.ondatachannel = event => {\n        this._setupData(event)\n      }\n    }\n\n    if (this.streams) {\n      this.streams.forEach(stream => {\n        this.addStream(stream)\n      })\n    }\n    this._pc.ontrack = event => {\n      this._onTrack(event)\n    }\n\n    this._debug('initial negotiation')\n    this._needsNegotiation()\n\n    this._onFinishBound = () => {\n      this._onFinish()\n    }\n    this.once('finish', this._onFinishBound)\n  }\n\n  get bufferSize () {\n    return (this._channel && this._channel.bufferedAmount) || 0\n  }\n\n  // HACK: it's possible channel.readyState is \"closing\" before peer.destroy() fires\n  // https://bugs.chromium.org/p/chromium/issues/detail?id=882743\n  get connected () {\n    return (this._connected && this._channel.readyState === 'open')\n  }\n\n  address () {\n    return { port: this.localPort, family: this.localFamily, address: this.localAddress }\n  }\n\n  signal (data) {\n    if (this.destroying) return\n    if (this.destroyed) throw errCode(new Error('cannot signal after peer is destroyed'), 'ERR_DESTROYED')\n    if (typeof data === 'string') {\n      try {\n        data = JSON.parse(data)\n      } catch (err) {\n        data = {}\n      }\n    }\n    this._debug('signal()')\n\n    if (data.renegotiate && this.initiator) {\n      this._debug('got request to renegotiate')\n      this._needsNegotiation()\n    }\n    if (data.transceiverRequest && this.initiator) {\n      this._debug('got request for transceiver')\n      this.addTransceiver(data.transceiverRequest.kind, data.transceiverRequest.init)\n    }\n    if (data.candidate) {\n      if (this._pc.remoteDescription && this._pc.remoteDescription.type) {\n        this._addIceCandidate(data.candidate)\n      } else {\n        this._pendingCandidates.push(data.candidate)\n      }\n    }\n    if (data.sdp) {\n      this._pc.setRemoteDescription(new (this._wrtc.RTCSessionDescription)(data))\n        .then(() => {\n          if (this.destroyed) return\n\n          this._pendingCandidates.forEach(candidate => {\n            this._addIceCandidate(candidate)\n          })\n          this._pendingCandidates = []\n\n          if (this._pc.remoteDescription.type === 'offer') this._createAnswer()\n        })\n        .catch(err => {\n          this.destroy(errCode(err, 'ERR_SET_REMOTE_DESCRIPTION'))\n        })\n    }\n    if (!data.sdp && !data.candidate && !data.renegotiate && !data.transceiverRequest) {\n      this.destroy(errCode(new Error('signal() called with invalid signal data'), 'ERR_SIGNALING'))\n    }\n  }\n\n  _addIceCandidate (candidate) {\n    const iceCandidateObj = new this._wrtc.RTCIceCandidate(candidate)\n    this._pc.addIceCandidate(iceCandidateObj)\n      .catch(err => {\n        if (!iceCandidateObj.address || iceCandidateObj.address.endsWith('.local')) {\n          warn('Ignoring unsupported ICE candidate.')\n        } else {\n          this.destroy(errCode(err, 'ERR_ADD_ICE_CANDIDATE'))\n        }\n      })\n  }\n\n  /**\n   * Send text/binary data to the remote peer.\n   * @param {ArrayBufferView|ArrayBuffer|Buffer|string|Blob} chunk\n   */\n  send (chunk) {\n    if (this.destroying) return\n    if (this.destroyed) throw errCode(new Error('cannot send after peer is destroyed'), 'ERR_DESTROYED')\n    this._channel.send(chunk)\n  }\n\n  /**\n   * Add a Transceiver to the connection.\n   * @param {String} kind\n   * @param {Object} init\n   */\n  addTransceiver (kind, init) {\n    if (this.destroying) return\n    if (this.destroyed) throw errCode(new Error('cannot addTransceiver after peer is destroyed'), 'ERR_DESTROYED')\n    this._debug('addTransceiver()')\n\n    if (this.initiator) {\n      try {\n        this._pc.addTransceiver(kind, init)\n        this._needsNegotiation()\n      } catch (err) {\n        this.destroy(errCode(err, 'ERR_ADD_TRANSCEIVER'))\n      }\n    } else {\n      this.emit('signal', { // request initiator to renegotiate\n        type: 'transceiverRequest',\n        transceiverRequest: { kind, init }\n      })\n    }\n  }\n\n  /**\n   * Add a MediaStream to the connection.\n   * @param {MediaStream} stream\n   */\n  addStream (stream) {\n    if (this.destroying) return\n    if (this.destroyed) throw errCode(new Error('cannot addStream after peer is destroyed'), 'ERR_DESTROYED')\n    this._debug('addStream()')\n\n    stream.getTracks().forEach(track => {\n      this.addTrack(track, stream)\n    })\n  }\n\n  /**\n   * Add a MediaStreamTrack to the connection.\n   * @param {MediaStreamTrack} track\n   * @param {MediaStream} stream\n   */\n  addTrack (track, stream) {\n    if (this.destroying) return\n    if (this.destroyed) throw errCode(new Error('cannot addTrack after peer is destroyed'), 'ERR_DESTROYED')\n    this._debug('addTrack()')\n\n    const submap = this._senderMap.get(track) || new Map() // nested Maps map [track, stream] to sender\n    let sender = submap.get(stream)\n    if (!sender) {\n      sender = this._pc.addTrack(track, stream)\n      submap.set(stream, sender)\n      this._senderMap.set(track, submap)\n      this._needsNegotiation()\n    } else if (sender.removed) {\n      throw errCode(new Error('Track has been removed. You should enable/disable tracks that you want to re-add.'), 'ERR_SENDER_REMOVED')\n    } else {\n      throw errCode(new Error('Track has already been added to that stream.'), 'ERR_SENDER_ALREADY_ADDED')\n    }\n  }\n\n  /**\n   * Replace a MediaStreamTrack by another in the connection.\n   * @param {MediaStreamTrack} oldTrack\n   * @param {MediaStreamTrack} newTrack\n   * @param {MediaStream} stream\n   */\n  replaceTrack (oldTrack, newTrack, stream) {\n    if (this.destroying) return\n    if (this.destroyed) throw errCode(new Error('cannot replaceTrack after peer is destroyed'), 'ERR_DESTROYED')\n    this._debug('replaceTrack()')\n\n    const submap = this._senderMap.get(oldTrack)\n    const sender = submap ? submap.get(stream) : null\n    if (!sender) {\n      throw errCode(new Error('Cannot replace track that was never added.'), 'ERR_TRACK_NOT_ADDED')\n    }\n    if (newTrack) this._senderMap.set(newTrack, submap)\n\n    if (sender.replaceTrack != null) {\n      sender.replaceTrack(newTrack)\n    } else {\n      this.destroy(errCode(new Error('replaceTrack is not supported in this browser'), 'ERR_UNSUPPORTED_REPLACETRACK'))\n    }\n  }\n\n  /**\n   * Remove a MediaStreamTrack from the connection.\n   * @param {MediaStreamTrack} track\n   * @param {MediaStream} stream\n   */\n  removeTrack (track, stream) {\n    if (this.destroying) return\n    if (this.destroyed) throw errCode(new Error('cannot removeTrack after peer is destroyed'), 'ERR_DESTROYED')\n    this._debug('removeSender()')\n\n    const submap = this._senderMap.get(track)\n    const sender = submap ? submap.get(stream) : null\n    if (!sender) {\n      throw errCode(new Error('Cannot remove track that was never added.'), 'ERR_TRACK_NOT_ADDED')\n    }\n    try {\n      sender.removed = true\n      this._pc.removeTrack(sender)\n    } catch (err) {\n      if (err.name === 'NS_ERROR_UNEXPECTED') {\n        this._sendersAwaitingStable.push(sender) // HACK: Firefox must wait until (signalingState === stable) https://bugzilla.mozilla.org/show_bug.cgi?id=1133874\n      } else {\n        this.destroy(errCode(err, 'ERR_REMOVE_TRACK'))\n      }\n    }\n    this._needsNegotiation()\n  }\n\n  /**\n   * Remove a MediaStream from the connection.\n   * @param {MediaStream} stream\n   */\n  removeStream (stream) {\n    if (this.destroying) return\n    if (this.destroyed) throw errCode(new Error('cannot removeStream after peer is destroyed'), 'ERR_DESTROYED')\n    this._debug('removeSenders()')\n\n    stream.getTracks().forEach(track => {\n      this.removeTrack(track, stream)\n    })\n  }\n\n  _needsNegotiation () {\n    this._debug('_needsNegotiation')\n    if (this._batchedNegotiation) return // batch synchronous renegotiations\n    this._batchedNegotiation = true\n    queueMicrotask(() => {\n      this._batchedNegotiation = false\n      if (this.initiator || !this._firstNegotiation) {\n        this._debug('starting batched negotiation')\n        this.negotiate()\n      } else {\n        this._debug('non-initiator initial negotiation request discarded')\n      }\n      this._firstNegotiation = false\n    })\n  }\n\n  negotiate () {\n    if (this.destroying) return\n    if (this.destroyed) throw errCode(new Error('cannot negotiate after peer is destroyed'), 'ERR_DESTROYED')\n\n    if (this.initiator) {\n      if (this._isNegotiating) {\n        this._queuedNegotiation = true\n        this._debug('already negotiating, queueing')\n      } else {\n        this._debug('start negotiation')\n        setTimeout(() => { // HACK: Chrome crashes if we immediately call createOffer\n          this._createOffer()\n        }, 0)\n      }\n    } else {\n      if (this._isNegotiating) {\n        this._queuedNegotiation = true\n        this._debug('already negotiating, queueing')\n      } else {\n        this._debug('requesting negotiation from initiator')\n        this.emit('signal', { // request initiator to renegotiate\n          type: 'renegotiate',\n          renegotiate: true\n        })\n      }\n    }\n    this._isNegotiating = true\n  }\n\n  // TODO: Delete this method once readable-stream is updated to contain a default\n  // implementation of destroy() that automatically calls _destroy()\n  // See: https://github.com/nodejs/readable-stream/issues/283\n  destroy (err) {\n    this._destroy(err, () => {})\n  }\n\n  _destroy (err, cb) {\n    if (this.destroyed || this.destroying) return\n    this.destroying = true\n\n    this._debug('destroying (error: %s)', err && (err.message || err))\n\n    queueMicrotask(() => { // allow events concurrent with the call to _destroy() to fire (see #692)\n      this.destroyed = true\n      this.destroying = false\n\n      this._debug('destroy (error: %s)', err && (err.message || err))\n\n      this.readable = this.writable = false\n\n      if (!this._readableState.ended) this.push(null)\n      if (!this._writableState.finished) this.end()\n\n      this._connected = false\n      this._pcReady = false\n      this._channelReady = false\n      this._remoteTracks = null\n      this._remoteStreams = null\n      this._senderMap = null\n\n      clearInterval(this._closingInterval)\n      this._closingInterval = null\n\n      clearInterval(this._interval)\n      this._interval = null\n      this._chunk = null\n      this._cb = null\n\n      if (this._onFinishBound) this.removeListener('finish', this._onFinishBound)\n      this._onFinishBound = null\n\n      if (this._channel) {\n        try {\n          this._channel.close()\n        } catch (err) {}\n\n        // allow events concurrent with destruction to be handled\n        this._channel.onmessage = null\n        this._channel.onopen = null\n        this._channel.onclose = null\n        this._channel.onerror = null\n      }\n      if (this._pc) {\n        try {\n          this._pc.close()\n        } catch (err) {}\n\n        // allow events concurrent with destruction to be handled\n        this._pc.oniceconnectionstatechange = null\n        this._pc.onicegatheringstatechange = null\n        this._pc.onsignalingstatechange = null\n        this._pc.onicecandidate = null\n        this._pc.ontrack = null\n        this._pc.ondatachannel = null\n      }\n      this._pc = null\n      this._channel = null\n\n      if (err) this.emit('error', err)\n      this.emit('close')\n      cb()\n    })\n  }\n\n  _setupData (event) {\n    if (!event.channel) {\n      // In some situations `pc.createDataChannel()` returns `undefined` (in wrtc),\n      // which is invalid behavior. Handle it gracefully.\n      // See: https://github.com/feross/simple-peer/issues/163\n      return this.destroy(errCode(new Error('Data channel event is missing `channel` property'), 'ERR_DATA_CHANNEL'))\n    }\n\n    this._channel = event.channel\n    this._channel.binaryType = 'arraybuffer'\n\n    if (typeof this._channel.bufferedAmountLowThreshold === 'number') {\n      this._channel.bufferedAmountLowThreshold = MAX_BUFFERED_AMOUNT\n    }\n\n    this.channelName = this._channel.label\n\n    this._channel.onmessage = event => {\n      this._onChannelMessage(event)\n    }\n    this._channel.onbufferedamountlow = () => {\n      this._onChannelBufferedAmountLow()\n    }\n    this._channel.onopen = () => {\n      this._onChannelOpen()\n    }\n    this._channel.onclose = () => {\n      this._onChannelClose()\n    }\n    this._channel.onerror = event => {\n      const err = event.error instanceof Error\n        ? event.error\n        : new Error(`Datachannel error: ${event.message} ${event.filename}:${event.lineno}:${event.colno}`)\n      this.destroy(errCode(err, 'ERR_DATA_CHANNEL'))\n    }\n\n    // HACK: Chrome will sometimes get stuck in readyState \"closing\", let's check for this condition\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=882743\n    let isClosing = false\n    this._closingInterval = setInterval(() => { // No \"onclosing\" event\n      if (this._channel && this._channel.readyState === 'closing') {\n        if (isClosing) this._onChannelClose() // closing timed out: equivalent to onclose firing\n        isClosing = true\n      } else {\n        isClosing = false\n      }\n    }, CHANNEL_CLOSING_TIMEOUT)\n  }\n\n  _read () {}\n\n  _write (chunk, encoding, cb) {\n    if (this.destroyed) return cb(errCode(new Error('cannot write after peer is destroyed'), 'ERR_DATA_CHANNEL'))\n\n    if (this._connected) {\n      try {\n        this.send(chunk)\n      } catch (err) {\n        return this.destroy(errCode(err, 'ERR_DATA_CHANNEL'))\n      }\n      if (this._channel.bufferedAmount > MAX_BUFFERED_AMOUNT) {\n        this._debug('start backpressure: bufferedAmount %d', this._channel.bufferedAmount)\n        this._cb = cb\n      } else {\n        cb(null)\n      }\n    } else {\n      this._debug('write before connect')\n      this._chunk = chunk\n      this._cb = cb\n    }\n  }\n\n  // When stream finishes writing, close socket. Half open connections are not\n  // supported.\n  _onFinish () {\n    if (this.destroyed) return\n\n    // Wait a bit before destroying so the socket flushes.\n    // TODO: is there a more reliable way to accomplish this?\n    const destroySoon = () => {\n      setTimeout(() => this.destroy(), 1000)\n    }\n\n    if (this._connected) {\n      destroySoon()\n    } else {\n      this.once('connect', destroySoon)\n    }\n  }\n\n  _startIceCompleteTimeout () {\n    if (this.destroyed) return\n    if (this._iceCompleteTimer) return\n    this._debug('started iceComplete timeout')\n    this._iceCompleteTimer = setTimeout(() => {\n      if (!this._iceComplete) {\n        this._iceComplete = true\n        this._debug('iceComplete timeout completed')\n        this.emit('iceTimeout')\n        this.emit('_iceComplete')\n      }\n    }, this.iceCompleteTimeout)\n  }\n\n  _createOffer () {\n    if (this.destroyed) return\n\n    this._pc.createOffer(this.offerOptions)\n      .then(offer => {\n        if (this.destroyed) return\n        if (!this.trickle && !this.allowHalfTrickle) offer.sdp = filterTrickle(offer.sdp)\n        offer.sdp = this.sdpTransform(offer.sdp)\n\n        const sendOffer = () => {\n          if (this.destroyed) return\n          const signal = this._pc.localDescription || offer\n          this._debug('signal')\n          this.emit('signal', {\n            type: signal.type,\n            sdp: signal.sdp\n          })\n        }\n\n        const onSuccess = () => {\n          this._debug('createOffer success')\n          if (this.destroyed) return\n          if (this.trickle || this._iceComplete) sendOffer()\n          else this.once('_iceComplete', sendOffer) // wait for candidates\n        }\n\n        const onError = err => {\n          this.destroy(errCode(err, 'ERR_SET_LOCAL_DESCRIPTION'))\n        }\n\n        this._pc.setLocalDescription(offer)\n          .then(onSuccess)\n          .catch(onError)\n      })\n      .catch(err => {\n        this.destroy(errCode(err, 'ERR_CREATE_OFFER'))\n      })\n  }\n\n  _requestMissingTransceivers () {\n    if (this._pc.getTransceivers) {\n      this._pc.getTransceivers().forEach(transceiver => {\n        if (!transceiver.mid && transceiver.sender.track && !transceiver.requested) {\n          transceiver.requested = true // HACK: Safari returns negotiated transceivers with a null mid\n          this.addTransceiver(transceiver.sender.track.kind)\n        }\n      })\n    }\n  }\n\n  _createAnswer () {\n    if (this.destroyed) return\n\n    this._pc.createAnswer(this.answerOptions)\n      .then(answer => {\n        if (this.destroyed) return\n        if (!this.trickle && !this.allowHalfTrickle) answer.sdp = filterTrickle(answer.sdp)\n        answer.sdp = this.sdpTransform(answer.sdp)\n\n        const sendAnswer = () => {\n          if (this.destroyed) return\n          const signal = this._pc.localDescription || answer\n          this._debug('signal')\n          this.emit('signal', {\n            type: signal.type,\n            sdp: signal.sdp\n          })\n          if (!this.initiator) this._requestMissingTransceivers()\n        }\n\n        const onSuccess = () => {\n          if (this.destroyed) return\n          if (this.trickle || this._iceComplete) sendAnswer()\n          else this.once('_iceComplete', sendAnswer)\n        }\n\n        const onError = err => {\n          this.destroy(errCode(err, 'ERR_SET_LOCAL_DESCRIPTION'))\n        }\n\n        this._pc.setLocalDescription(answer)\n          .then(onSuccess)\n          .catch(onError)\n      })\n      .catch(err => {\n        this.destroy(errCode(err, 'ERR_CREATE_ANSWER'))\n      })\n  }\n\n  _onConnectionStateChange () {\n    if (this.destroyed) return\n    if (this._pc.connectionState === 'failed') {\n      this.destroy(errCode(new Error('Connection failed.'), 'ERR_CONNECTION_FAILURE'))\n    }\n  }\n\n  _onIceStateChange () {\n    if (this.destroyed) return\n    const iceConnectionState = this._pc.iceConnectionState\n    const iceGatheringState = this._pc.iceGatheringState\n\n    this._debug(\n      'iceStateChange (connection: %s) (gathering: %s)',\n      iceConnectionState,\n      iceGatheringState\n    )\n    this.emit('iceStateChange', iceConnectionState, iceGatheringState)\n\n    if (iceConnectionState === 'connected' || iceConnectionState === 'completed') {\n      this._pcReady = true\n      this._maybeReady()\n    }\n    if (iceConnectionState === 'failed') {\n      this.destroy(errCode(new Error('Ice connection failed.'), 'ERR_ICE_CONNECTION_FAILURE'))\n    }\n    if (iceConnectionState === 'closed') {\n      this.destroy(errCode(new Error('Ice connection closed.'), 'ERR_ICE_CONNECTION_CLOSED'))\n    }\n  }\n\n  getStats (cb) {\n    // statreports can come with a value array instead of properties\n    const flattenValues = report => {\n      if (Object.prototype.toString.call(report.values) === '[object Array]') {\n        report.values.forEach(value => {\n          Object.assign(report, value)\n        })\n      }\n      return report\n    }\n\n    // Promise-based getStats() (standard)\n    if (this._pc.getStats.length === 0 || this._isReactNativeWebrtc) {\n      this._pc.getStats()\n        .then(res => {\n          const reports = []\n          res.forEach(report => {\n            reports.push(flattenValues(report))\n          })\n          cb(null, reports)\n        }, err => cb(err))\n\n    // Single-parameter callback-based getStats() (non-standard)\n    } else if (this._pc.getStats.length > 0) {\n      this._pc.getStats(res => {\n        // If we destroy connection in `connect` callback this code might happen to run when actual connection is already closed\n        if (this.destroyed) return\n\n        const reports = []\n        res.result().forEach(result => {\n          const report = {}\n          result.names().forEach(name => {\n            report[name] = result.stat(name)\n          })\n          report.id = result.id\n          report.type = result.type\n          report.timestamp = result.timestamp\n          reports.push(flattenValues(report))\n        })\n        cb(null, reports)\n      }, err => cb(err))\n\n    // Unknown browser, skip getStats() since it's anyone's guess which style of\n    // getStats() they implement.\n    } else {\n      cb(null, [])\n    }\n  }\n\n  _maybeReady () {\n    this._debug('maybeReady pc %s channel %s', this._pcReady, this._channelReady)\n    if (this._connected || this._connecting || !this._pcReady || !this._channelReady) return\n\n    this._connecting = true\n\n    // HACK: We can't rely on order here, for details see https://github.com/js-platform/node-webrtc/issues/339\n    const findCandidatePair = () => {\n      if (this.destroyed) return\n\n      this.getStats((err, items) => {\n        if (this.destroyed) return\n\n        // Treat getStats error as non-fatal. It's not essential.\n        if (err) items = []\n\n        const remoteCandidates = {}\n        const localCandidates = {}\n        const candidatePairs = {}\n        let foundSelectedCandidatePair = false\n\n        items.forEach(item => {\n          // TODO: Once all browsers support the hyphenated stats report types, remove\n          // the non-hypenated ones\n          if (item.type === 'remotecandidate' || item.type === 'remote-candidate') {\n            remoteCandidates[item.id] = item\n          }\n          if (item.type === 'localcandidate' || item.type === 'local-candidate') {\n            localCandidates[item.id] = item\n          }\n          if (item.type === 'candidatepair' || item.type === 'candidate-pair') {\n            candidatePairs[item.id] = item\n          }\n        })\n\n        const setSelectedCandidatePair = selectedCandidatePair => {\n          foundSelectedCandidatePair = true\n\n          let local = localCandidates[selectedCandidatePair.localCandidateId]\n\n          if (local && (local.ip || local.address)) {\n            // Spec\n            this.localAddress = local.ip || local.address\n            this.localPort = Number(local.port)\n          } else if (local && local.ipAddress) {\n            // Firefox\n            this.localAddress = local.ipAddress\n            this.localPort = Number(local.portNumber)\n          } else if (typeof selectedCandidatePair.googLocalAddress === 'string') {\n            // TODO: remove this once Chrome 58 is released\n            local = selectedCandidatePair.googLocalAddress.split(':')\n            this.localAddress = local[0]\n            this.localPort = Number(local[1])\n          }\n          if (this.localAddress) {\n            this.localFamily = this.localAddress.includes(':') ? 'IPv6' : 'IPv4'\n          }\n\n          let remote = remoteCandidates[selectedCandidatePair.remoteCandidateId]\n\n          if (remote && (remote.ip || remote.address)) {\n            // Spec\n            this.remoteAddress = remote.ip || remote.address\n            this.remotePort = Number(remote.port)\n          } else if (remote && remote.ipAddress) {\n            // Firefox\n            this.remoteAddress = remote.ipAddress\n            this.remotePort = Number(remote.portNumber)\n          } else if (typeof selectedCandidatePair.googRemoteAddress === 'string') {\n            // TODO: remove this once Chrome 58 is released\n            remote = selectedCandidatePair.googRemoteAddress.split(':')\n            this.remoteAddress = remote[0]\n            this.remotePort = Number(remote[1])\n          }\n          if (this.remoteAddress) {\n            this.remoteFamily = this.remoteAddress.includes(':') ? 'IPv6' : 'IPv4'\n          }\n\n          this._debug(\n            'connect local: %s:%s remote: %s:%s',\n            this.localAddress,\n            this.localPort,\n            this.remoteAddress,\n            this.remotePort\n          )\n        }\n\n        items.forEach(item => {\n          // Spec-compliant\n          if (item.type === 'transport' && item.selectedCandidatePairId) {\n            setSelectedCandidatePair(candidatePairs[item.selectedCandidatePairId])\n          }\n\n          // Old implementations\n          if (\n            (item.type === 'googCandidatePair' && item.googActiveConnection === 'true') ||\n            ((item.type === 'candidatepair' || item.type === 'candidate-pair') && item.selected)\n          ) {\n            setSelectedCandidatePair(item)\n          }\n        })\n\n        // Ignore candidate pair selection in browsers like Safari 11 that do not have any local or remote candidates\n        // But wait until at least 1 candidate pair is available\n        if (!foundSelectedCandidatePair && (!Object.keys(candidatePairs).length || Object.keys(localCandidates).length)) {\n          setTimeout(findCandidatePair, 100)\n          return\n        } else {\n          this._connecting = false\n          this._connected = true\n        }\n\n        if (this._chunk) {\n          try {\n            this.send(this._chunk)\n          } catch (err) {\n            return this.destroy(errCode(err, 'ERR_DATA_CHANNEL'))\n          }\n          this._chunk = null\n          this._debug('sent chunk from \"write before connect\"')\n\n          const cb = this._cb\n          this._cb = null\n          cb(null)\n        }\n\n        // If `bufferedAmountLowThreshold` and 'onbufferedamountlow' are unsupported,\n        // fallback to using setInterval to implement backpressure.\n        if (typeof this._channel.bufferedAmountLowThreshold !== 'number') {\n          this._interval = setInterval(() => this._onInterval(), 150)\n          if (this._interval.unref) this._interval.unref()\n        }\n\n        this._debug('connect')\n        this.emit('connect')\n      })\n    }\n    findCandidatePair()\n  }\n\n  _onInterval () {\n    if (!this._cb || !this._channel || this._channel.bufferedAmount > MAX_BUFFERED_AMOUNT) {\n      return\n    }\n    this._onChannelBufferedAmountLow()\n  }\n\n  _onSignalingStateChange () {\n    if (this.destroyed) return\n\n    if (this._pc.signalingState === 'stable') {\n      this._isNegotiating = false\n\n      // HACK: Firefox doesn't yet support removing tracks when signalingState !== 'stable'\n      this._debug('flushing sender queue', this._sendersAwaitingStable)\n      this._sendersAwaitingStable.forEach(sender => {\n        this._pc.removeTrack(sender)\n        this._queuedNegotiation = true\n      })\n      this._sendersAwaitingStable = []\n\n      if (this._queuedNegotiation) {\n        this._debug('flushing negotiation queue')\n        this._queuedNegotiation = false\n        this._needsNegotiation() // negotiate again\n      } else {\n        this._debug('negotiated')\n        this.emit('negotiated')\n      }\n    }\n\n    this._debug('signalingStateChange %s', this._pc.signalingState)\n    this.emit('signalingStateChange', this._pc.signalingState)\n  }\n\n  _onIceCandidate (event) {\n    if (this.destroyed) return\n    if (event.candidate && this.trickle) {\n      this.emit('signal', {\n        type: 'candidate',\n        candidate: {\n          candidate: event.candidate.candidate,\n          sdpMLineIndex: event.candidate.sdpMLineIndex,\n          sdpMid: event.candidate.sdpMid\n        }\n      })\n    } else if (!event.candidate && !this._iceComplete) {\n      this._iceComplete = true\n      this.emit('_iceComplete')\n    }\n    // as soon as we've received one valid candidate start timeout\n    if (event.candidate) {\n      this._startIceCompleteTimeout()\n    }\n  }\n\n  _onChannelMessage (event) {\n    if (this.destroyed) return\n    let data = event.data\n    if (data instanceof ArrayBuffer) data = Buffer.from(data)\n    this.push(data)\n  }\n\n  _onChannelBufferedAmountLow () {\n    if (this.destroyed || !this._cb) return\n    this._debug('ending backpressure: bufferedAmount %d', this._channel.bufferedAmount)\n    const cb = this._cb\n    this._cb = null\n    cb(null)\n  }\n\n  _onChannelOpen () {\n    if (this._connected || this.destroyed) return\n    this._debug('on channel open')\n    this._channelReady = true\n    this._maybeReady()\n  }\n\n  _onChannelClose () {\n    if (this.destroyed) return\n    this._debug('on channel close')\n    this.destroy()\n  }\n\n  _onTrack (event) {\n    if (this.destroyed) return\n\n    event.streams.forEach(eventStream => {\n      this._debug('on track')\n      this.emit('track', event.track, eventStream)\n\n      this._remoteTracks.push({\n        track: event.track,\n        stream: eventStream\n      })\n\n      if (this._remoteStreams.some(remoteStream => {\n        return remoteStream.id === eventStream.id\n      })) return // Only fire one 'stream' event, even though there may be multiple tracks per stream\n\n      this._remoteStreams.push(eventStream)\n      queueMicrotask(() => {\n        this._debug('on stream')\n        this.emit('stream', eventStream) // ensure all tracks have been added\n      })\n    })\n  }\n\n  _debug () {\n    const args = [].slice.call(arguments)\n    args[0] = '[' + this._id + '] ' + args[0]\n    debug.apply(null, args)\n  }\n}\n\nPeer.WEBRTC_SUPPORT = !!getBrowserRTC()\n\n/**\n * Expose peer and data channel config for overriding all Peer\n * instances. Otherwise, just set opts.config or opts.channelConfig\n * when constructing a Peer.\n */\nPeer.config = {\n  iceServers: [\n    {\n      urls: [\n        'stun:stun.l.google.com:19302',\n        'stun:global.stun.twilio.com:3478'\n      ]\n    }\n  ],\n  sdpSemantics: 'unified-plan'\n}\n\nPeer.channelConfig = {}\n\nmodule.exports = Peer\n\n\n//# sourceURL=webpack://someLibName/./node_modules/simple-peer/index.js?");

/***/ }),

/***/ "./node_modules/simple-peer/node_modules/debug/src/browser.js":
/*!********************************************************************!*\
  !*** ./node_modules/simple-peer/node_modules/debug/src/browser.js ***!
  \********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\n\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\nexports.destroy = (() => {\n\tlet warned = false;\n\n\treturn () => {\n\t\tif (!warned) {\n\t\t\twarned = true;\n\t\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t\t}\n\t};\n})();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n\t'#0000CC',\n\t'#0000FF',\n\t'#0033CC',\n\t'#0033FF',\n\t'#0066CC',\n\t'#0066FF',\n\t'#0099CC',\n\t'#0099FF',\n\t'#00CC00',\n\t'#00CC33',\n\t'#00CC66',\n\t'#00CC99',\n\t'#00CCCC',\n\t'#00CCFF',\n\t'#3300CC',\n\t'#3300FF',\n\t'#3333CC',\n\t'#3333FF',\n\t'#3366CC',\n\t'#3366FF',\n\t'#3399CC',\n\t'#3399FF',\n\t'#33CC00',\n\t'#33CC33',\n\t'#33CC66',\n\t'#33CC99',\n\t'#33CCCC',\n\t'#33CCFF',\n\t'#6600CC',\n\t'#6600FF',\n\t'#6633CC',\n\t'#6633FF',\n\t'#66CC00',\n\t'#66CC33',\n\t'#9900CC',\n\t'#9900FF',\n\t'#9933CC',\n\t'#9933FF',\n\t'#99CC00',\n\t'#99CC33',\n\t'#CC0000',\n\t'#CC0033',\n\t'#CC0066',\n\t'#CC0099',\n\t'#CC00CC',\n\t'#CC00FF',\n\t'#CC3300',\n\t'#CC3333',\n\t'#CC3366',\n\t'#CC3399',\n\t'#CC33CC',\n\t'#CC33FF',\n\t'#CC6600',\n\t'#CC6633',\n\t'#CC9900',\n\t'#CC9933',\n\t'#CCCC00',\n\t'#CCCC33',\n\t'#FF0000',\n\t'#FF0033',\n\t'#FF0066',\n\t'#FF0099',\n\t'#FF00CC',\n\t'#FF00FF',\n\t'#FF3300',\n\t'#FF3333',\n\t'#FF3366',\n\t'#FF3399',\n\t'#FF33CC',\n\t'#FF33FF',\n\t'#FF6600',\n\t'#FF6633',\n\t'#FF9900',\n\t'#FF9933',\n\t'#FFCC00',\n\t'#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\n// eslint-disable-next-line complexity\nfunction useColors() {\n\t// NB: In an Electron preload script, document will be defined but not fully\n\t// initialized. Since we know we're in Chrome, we'll just detect this case\n\t// explicitly\n\tif (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n\t\treturn true;\n\t}\n\n\t// Internet Explorer and Edge do not support colors.\n\tif (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n\t\treturn false;\n\t}\n\n\t// Is webkit? http://stackoverflow.com/a/16459606/376773\n\t// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\treturn (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n\t\t// Is firebug? http://stackoverflow.com/a/398120/376773\n\t\t(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n\t\t// Is firefox >= v31?\n\t\t// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n\t\t// Double check webkit in userAgent just in case we are in a worker\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\targs[0] = (this.useColors ? '%c' : '') +\n\t\tthis.namespace +\n\t\t(this.useColors ? ' %c' : ' ') +\n\t\targs[0] +\n\t\t(this.useColors ? '%c ' : ' ') +\n\t\t'+' + module.exports.humanize(this.diff);\n\n\tif (!this.useColors) {\n\t\treturn;\n\t}\n\n\tconst c = 'color: ' + this.color;\n\targs.splice(1, 0, c, 'color: inherit');\n\n\t// The final \"%c\" is somewhat tricky, because there could be other\n\t// arguments passed either before or after the %c, so we need to\n\t// figure out the correct index to insert the CSS into\n\tlet index = 0;\n\tlet lastC = 0;\n\targs[0].replace(/%[a-zA-Z%]/g, match => {\n\t\tif (match === '%%') {\n\t\t\treturn;\n\t\t}\n\t\tindex++;\n\t\tif (match === '%c') {\n\t\t\t// We only are interested in the *last* %c\n\t\t\t// (the user may have provided their own)\n\t\t\tlastC = index;\n\t\t}\n\t});\n\n\targs.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.debug()` when available.\n * No-op when `console.debug` is not a \"function\".\n * If `console.debug` is not available, falls back\n * to `console.log`.\n *\n * @api public\n */\nexports.log = console.debug || console.log || (() => {});\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\ttry {\n\t\tif (namespaces) {\n\t\t\texports.storage.setItem('debug', namespaces);\n\t\t} else {\n\t\t\texports.storage.removeItem('debug');\n\t\t}\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\nfunction load() {\n\tlet r;\n\ttry {\n\t\tr = exports.storage.getItem('debug');\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n\n\t// If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\tif (!r && typeof process !== 'undefined' && 'env' in process) {\n\t\tr = process.env.DEBUG;\n\t}\n\n\treturn r;\n}\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n\ttry {\n\t\t// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n\t\t// The Browser also has localStorage in the global context.\n\t\treturn localStorage;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\nmodule.exports = __webpack_require__(/*! ./common */ \"./node_modules/simple-peer/node_modules/debug/src/common.js\")(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n\ttry {\n\t\treturn JSON.stringify(v);\n\t} catch (error) {\n\t\treturn '[UnexpectedJSONParseError]: ' + error.message;\n\t}\n};\n\n\n//# sourceURL=webpack://someLibName/./node_modules/simple-peer/node_modules/debug/src/browser.js?");

/***/ }),

/***/ "./node_modules/simple-peer/node_modules/debug/src/common.js":
/*!*******************************************************************!*\
  !*** ./node_modules/simple-peer/node_modules/debug/src/common.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\n\nfunction setup(env) {\n\tcreateDebug.debug = createDebug;\n\tcreateDebug.default = createDebug;\n\tcreateDebug.coerce = coerce;\n\tcreateDebug.disable = disable;\n\tcreateDebug.enable = enable;\n\tcreateDebug.enabled = enabled;\n\tcreateDebug.humanize = __webpack_require__(/*! ms */ \"./node_modules/simple-peer/node_modules/ms/index.js\");\n\tcreateDebug.destroy = destroy;\n\n\tObject.keys(env).forEach(key => {\n\t\tcreateDebug[key] = env[key];\n\t});\n\n\t/**\n\t* The currently active debug mode names, and names to skip.\n\t*/\n\n\tcreateDebug.names = [];\n\tcreateDebug.skips = [];\n\n\t/**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/\n\tcreateDebug.formatters = {};\n\n\t/**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/\n\tfunction selectColor(namespace) {\n\t\tlet hash = 0;\n\n\t\tfor (let i = 0; i < namespace.length; i++) {\n\t\t\thash = ((hash << 5) - hash) + namespace.charCodeAt(i);\n\t\t\thash |= 0; // Convert to 32bit integer\n\t\t}\n\n\t\treturn createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n\t}\n\tcreateDebug.selectColor = selectColor;\n\n\t/**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/\n\tfunction createDebug(namespace) {\n\t\tlet prevTime;\n\t\tlet enableOverride = null;\n\n\t\tfunction debug(...args) {\n\t\t\t// Disabled?\n\t\t\tif (!debug.enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst self = debug;\n\n\t\t\t// Set `diff` timestamp\n\t\t\tconst curr = Number(new Date());\n\t\t\tconst ms = curr - (prevTime || curr);\n\t\t\tself.diff = ms;\n\t\t\tself.prev = prevTime;\n\t\t\tself.curr = curr;\n\t\t\tprevTime = curr;\n\n\t\t\targs[0] = createDebug.coerce(args[0]);\n\n\t\t\tif (typeof args[0] !== 'string') {\n\t\t\t\t// Anything else let's inspect with %O\n\t\t\t\targs.unshift('%O');\n\t\t\t}\n\n\t\t\t// Apply any `formatters` transformations\n\t\t\tlet index = 0;\n\t\t\targs[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n\t\t\t\t// If we encounter an escaped % then don't increase the array index\n\t\t\t\tif (match === '%%') {\n\t\t\t\t\treturn '%';\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t\tconst formatter = createDebug.formatters[format];\n\t\t\t\tif (typeof formatter === 'function') {\n\t\t\t\t\tconst val = args[index];\n\t\t\t\t\tmatch = formatter.call(self, val);\n\n\t\t\t\t\t// Now we need to remove `args[index]` since it's inlined in the `format`\n\t\t\t\t\targs.splice(index, 1);\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\treturn match;\n\t\t\t});\n\n\t\t\t// Apply env-specific formatting (colors, etc.)\n\t\t\tcreateDebug.formatArgs.call(self, args);\n\n\t\t\tconst logFn = self.log || createDebug.log;\n\t\t\tlogFn.apply(self, args);\n\t\t}\n\n\t\tdebug.namespace = namespace;\n\t\tdebug.useColors = createDebug.useColors();\n\t\tdebug.color = createDebug.selectColor(namespace);\n\t\tdebug.extend = extend;\n\t\tdebug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.\n\n\t\tObject.defineProperty(debug, 'enabled', {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: false,\n\t\t\tget: () => enableOverride === null ? createDebug.enabled(namespace) : enableOverride,\n\t\t\tset: v => {\n\t\t\t\tenableOverride = v;\n\t\t\t}\n\t\t});\n\n\t\t// Env-specific initialization logic for debug instances\n\t\tif (typeof createDebug.init === 'function') {\n\t\t\tcreateDebug.init(debug);\n\t\t}\n\n\t\treturn debug;\n\t}\n\n\tfunction extend(namespace, delimiter) {\n\t\tconst newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n\t\tnewDebug.log = this.log;\n\t\treturn newDebug;\n\t}\n\n\t/**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/\n\tfunction enable(namespaces) {\n\t\tcreateDebug.save(namespaces);\n\n\t\tcreateDebug.names = [];\n\t\tcreateDebug.skips = [];\n\n\t\tlet i;\n\t\tconst split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n\t\tconst len = split.length;\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (!split[i]) {\n\t\t\t\t// ignore empty strings\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnamespaces = split[i].replace(/\\*/g, '.*?');\n\n\t\t\tif (namespaces[0] === '-') {\n\t\t\t\tcreateDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n\t\t\t} else {\n\t\t\t\tcreateDebug.names.push(new RegExp('^' + namespaces + '$'));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/\n\tfunction disable() {\n\t\tconst namespaces = [\n\t\t\t...createDebug.names.map(toNamespace),\n\t\t\t...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)\n\t\t].join(',');\n\t\tcreateDebug.enable('');\n\t\treturn namespaces;\n\t}\n\n\t/**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/\n\tfunction enabled(name) {\n\t\tif (name[name.length - 1] === '*') {\n\t\t\treturn true;\n\t\t}\n\n\t\tlet i;\n\t\tlet len;\n\n\t\tfor (i = 0, len = createDebug.skips.length; i < len; i++) {\n\t\t\tif (createDebug.skips[i].test(name)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0, len = createDebug.names.length; i < len; i++) {\n\t\t\tif (createDebug.names[i].test(name)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t* Convert regexp to namespace\n\t*\n\t* @param {RegExp} regxep\n\t* @return {String} namespace\n\t* @api private\n\t*/\n\tfunction toNamespace(regexp) {\n\t\treturn regexp.toString()\n\t\t\t.substring(2, regexp.toString().length - 2)\n\t\t\t.replace(/\\.\\*\\?$/, '*');\n\t}\n\n\t/**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/\n\tfunction coerce(val) {\n\t\tif (val instanceof Error) {\n\t\t\treturn val.stack || val.message;\n\t\t}\n\t\treturn val;\n\t}\n\n\t/**\n\t* XXX DO NOT USE. This is a temporary stub function.\n\t* XXX It WILL be removed in the next major release.\n\t*/\n\tfunction destroy() {\n\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t}\n\n\tcreateDebug.enable(createDebug.load());\n\n\treturn createDebug;\n}\n\nmodule.exports = setup;\n\n\n//# sourceURL=webpack://someLibName/./node_modules/simple-peer/node_modules/debug/src/common.js?");

/***/ }),

/***/ "./node_modules/simple-peer/node_modules/ms/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/simple-peer/node_modules/ms/index.js ***!
  \***********************************************************/
/***/ ((module) => {

eval("/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n\n\n//# sourceURL=webpack://someLibName/./node_modules/simple-peer/node_modules/ms/index.js?");

/***/ }),

/***/ "./node_modules/simple-peer/node_modules/readable-stream/errors-browser.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/simple-peer/node_modules/readable-stream/errors-browser.js ***!
  \*********************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nvar codes = {};\n\nfunction createErrorType(code, message, Base) {\n  if (!Base) {\n    Base = Error;\n  }\n\n  function getMessage(arg1, arg2, arg3) {\n    if (typeof message === 'string') {\n      return message;\n    } else {\n      return message(arg1, arg2, arg3);\n    }\n  }\n\n  var NodeError =\n  /*#__PURE__*/\n  function (_Base) {\n    _inheritsLoose(NodeError, _Base);\n\n    function NodeError(arg1, arg2, arg3) {\n      return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;\n    }\n\n    return NodeError;\n  }(Base);\n\n  NodeError.prototype.name = Base.name;\n  NodeError.prototype.code = code;\n  codes[code] = NodeError;\n} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js\n\n\nfunction oneOf(expected, thing) {\n  if (Array.isArray(expected)) {\n    var len = expected.length;\n    expected = expected.map(function (i) {\n      return String(i);\n    });\n\n    if (len > 2) {\n      return \"one of \".concat(thing, \" \").concat(expected.slice(0, len - 1).join(', '), \", or \") + expected[len - 1];\n    } else if (len === 2) {\n      return \"one of \".concat(thing, \" \").concat(expected[0], \" or \").concat(expected[1]);\n    } else {\n      return \"of \".concat(thing, \" \").concat(expected[0]);\n    }\n  } else {\n    return \"of \".concat(thing, \" \").concat(String(expected));\n  }\n} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith\n\n\nfunction startsWith(str, search, pos) {\n  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;\n} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith\n\n\nfunction endsWith(str, search, this_len) {\n  if (this_len === undefined || this_len > str.length) {\n    this_len = str.length;\n  }\n\n  return str.substring(this_len - search.length, this_len) === search;\n} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes\n\n\nfunction includes(str, search, start) {\n  if (typeof start !== 'number') {\n    start = 0;\n  }\n\n  if (start + search.length > str.length) {\n    return false;\n  } else {\n    return str.indexOf(search, start) !== -1;\n  }\n}\n\ncreateErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {\n  return 'The value \"' + value + '\" is invalid for option \"' + name + '\"';\n}, TypeError);\ncreateErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {\n  // determiner: 'must be' or 'must not be'\n  var determiner;\n\n  if (typeof expected === 'string' && startsWith(expected, 'not ')) {\n    determiner = 'must not be';\n    expected = expected.replace(/^not /, '');\n  } else {\n    determiner = 'must be';\n  }\n\n  var msg;\n\n  if (endsWith(name, ' argument')) {\n    // For cases like 'first argument'\n    msg = \"The \".concat(name, \" \").concat(determiner, \" \").concat(oneOf(expected, 'type'));\n  } else {\n    var type = includes(name, '.') ? 'property' : 'argument';\n    msg = \"The \\\"\".concat(name, \"\\\" \").concat(type, \" \").concat(determiner, \" \").concat(oneOf(expected, 'type'));\n  }\n\n  msg += \". Received type \".concat(typeof actual);\n  return msg;\n}, TypeError);\ncreateErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');\ncreateErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {\n  return 'The ' + name + ' method is not implemented';\n});\ncreateErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');\ncreateErrorType('ERR_STREAM_DESTROYED', function (name) {\n  return 'Cannot call ' + name + ' after a stream was destroyed';\n});\ncreateErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');\ncreateErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');\ncreateErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');\ncreateErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);\ncreateErrorType('ERR_UNKNOWN_ENCODING', function (arg) {\n  return 'Unknown encoding: ' + arg;\n}, TypeError);\ncreateErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');\nmodule.exports.codes = codes;\n\n\n//# sourceURL=webpack://someLibName/./node_modules/simple-peer/node_modules/readable-stream/errors-browser.js?");

/***/ }),

/***/ "./node_modules/simple-peer/node_modules/readable-stream/lib/_stream_duplex.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/simple-peer/node_modules/readable-stream/lib/_stream_duplex.js ***!
  \*************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n\n/*<replacement>*/\n\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n\n  for (var key in obj) {\n    keys.push(key);\n  }\n\n  return keys;\n};\n/*</replacement>*/\n\n\nmodule.exports = Duplex;\n\nvar Readable = __webpack_require__(/*! ./_stream_readable */ \"./node_modules/simple-peer/node_modules/readable-stream/lib/_stream_readable.js\");\n\nvar Writable = __webpack_require__(/*! ./_stream_writable */ \"./node_modules/simple-peer/node_modules/readable-stream/lib/_stream_writable.js\");\n\n__webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")(Duplex, Readable);\n\n{\n  // Allow the keys array to be GC'ed.\n  var keys = objectKeys(Writable.prototype);\n\n  for (var v = 0; v < keys.length; v++) {\n    var method = keys[v];\n    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n  }\n}\n\nfunction Duplex(options) {\n  if (!(this instanceof Duplex)) return new Duplex(options);\n  Readable.call(this, options);\n  Writable.call(this, options);\n  this.allowHalfOpen = true;\n\n  if (options) {\n    if (options.readable === false) this.readable = false;\n    if (options.writable === false) this.writable = false;\n\n    if (options.allowHalfOpen === false) {\n      this.allowHalfOpen = false;\n      this.once('end', onend);\n    }\n  }\n}\n\nObject.defineProperty(Duplex.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.highWaterMark;\n  }\n});\nObject.defineProperty(Duplex.prototype, 'writableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState && this._writableState.getBuffer();\n  }\n});\nObject.defineProperty(Duplex.prototype, 'writableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.length;\n  }\n}); // the no-half-open enforcer\n\nfunction onend() {\n  // If the writable side ended, then we're ok.\n  if (this._writableState.ended) return; // no more data can be written.\n  // But allow more writes to happen in this tick.\n\n  process.nextTick(onEndNT, this);\n}\n\nfunction onEndNT(self) {\n  self.end();\n}\n\nObject.defineProperty(Duplex.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return false;\n    }\n\n    return this._readableState.destroyed && this._writableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return;\n    } // backward compatibility, the user is explicitly\n    // managing destroyed\n\n\n    this._readableState.destroyed = value;\n    this._writableState.destroyed = value;\n  }\n});\n\n//# sourceURL=webpack://someLibName/./node_modules/simple-peer/node_modules/readable-stream/lib/_stream_duplex.js?");

/***/ }),

/***/ "./node_modules/simple-peer/node_modules/readable-stream/lib/_stream_passthrough.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/simple-peer/node_modules/readable-stream/lib/_stream_passthrough.js ***!
  \******************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n\n\nmodule.exports = PassThrough;\n\nvar Transform = __webpack_require__(/*! ./_stream_transform */ \"./node_modules/simple-peer/node_modules/readable-stream/lib/_stream_transform.js\");\n\n__webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")(PassThrough, Transform);\n\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough)) return new PassThrough(options);\n  Transform.call(this, options);\n}\n\nPassThrough.prototype._transform = function (chunk, encoding, cb) {\n  cb(null, chunk);\n};\n\n//# sourceURL=webpack://someLibName/./node_modules/simple-peer/node_modules/readable-stream/lib/_stream_passthrough.js?");

/***/ }),

/***/ "./node_modules/simple-peer/node_modules/readable-stream/lib/_stream_readable.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/simple-peer/node_modules/readable-stream/lib/_stream_readable.js ***!
  \***************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\nmodule.exports = Readable;\n/*<replacement>*/\n\nvar Duplex;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n/*<replacement>*/\n\nvar EE = __webpack_require__(/*! events */ \"./node_modules/events/events.js\").EventEmitter;\n\nvar EElistenerCount = function EElistenerCount(emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\n/*<replacement>*/\n\n\nvar Stream = __webpack_require__(/*! ./internal/streams/stream */ \"./node_modules/simple-peer/node_modules/readable-stream/lib/internal/streams/stream-browser.js\");\n/*</replacement>*/\n\n\nvar Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\").Buffer;\n\nvar OurUint8Array = __webpack_require__.g.Uint8Array || function () {};\n\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\n\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n/*<replacement>*/\n\n\nvar debugUtil = __webpack_require__(/*! util */ \"?2581\");\n\nvar debug;\n\nif (debugUtil && debugUtil.debuglog) {\n  debug = debugUtil.debuglog('stream');\n} else {\n  debug = function debug() {};\n}\n/*</replacement>*/\n\n\nvar BufferList = __webpack_require__(/*! ./internal/streams/buffer_list */ \"./node_modules/simple-peer/node_modules/readable-stream/lib/internal/streams/buffer_list.js\");\n\nvar destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ \"./node_modules/simple-peer/node_modules/readable-stream/lib/internal/streams/destroy.js\");\n\nvar _require = __webpack_require__(/*! ./internal/streams/state */ \"./node_modules/simple-peer/node_modules/readable-stream/lib/internal/streams/state.js\"),\n    getHighWaterMark = _require.getHighWaterMark;\n\nvar _require$codes = __webpack_require__(/*! ../errors */ \"./node_modules/simple-peer/node_modules/readable-stream/errors-browser.js\").codes,\n    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,\n    ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,\n    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n    ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; // Lazy loaded to improve the startup performance.\n\n\nvar StringDecoder;\nvar createReadableStreamAsyncIterator;\nvar from;\n\n__webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")(Readable, Stream);\n\nvar errorOrDestroy = destroyImpl.errorOrDestroy;\nvar kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\n\nfunction prependListener(emitter, event, fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any\n  // userland ones.  NEVER DO THIS. This is here only because this code needs\n  // to continue to work with older versions of Node.js that do not include\n  // the prependListener() method. The goal is to eventually remove this hack.\n\n  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n}\n\nfunction ReadableState(options, stream, isDuplex) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/simple-peer/node_modules/readable-stream/lib/_stream_duplex.js\");\n  options = options || {}; // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n\n  this.objectMode = !!options.objectMode;\n  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n\n  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift()\n\n  this.buffer = new BufferList();\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted\n  // immediately, or on a later tick.  We set this to true at first, because\n  // any actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first read call.\n\n  this.sync = true; // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n  this.paused = true; // Should close be emitted on destroy. Defaults to true.\n\n  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'end' (and potentially 'finish')\n\n  this.autoDestroy = !!options.autoDestroy; // has it been destroyed\n\n  this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n\n  this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s\n\n  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled\n\n  this.readingMore = false;\n  this.decoder = null;\n  this.encoding = null;\n\n  if (options.encoding) {\n    if (!StringDecoder) StringDecoder = __webpack_require__(/*! string_decoder/ */ \"./node_modules/string_decoder/lib/string_decoder.js\").StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/simple-peer/node_modules/readable-stream/lib/_stream_duplex.js\");\n  if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the ReadableState constructor, at least with V8 6.5\n\n  var isDuplex = this instanceof Duplex;\n  this._readableState = new ReadableState(options, this, isDuplex); // legacy\n\n  this.readable = true;\n\n  if (options) {\n    if (typeof options.read === 'function') this._read = options.read;\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n  }\n\n  Stream.call(this);\n}\n\nObject.defineProperty(Readable.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._readableState === undefined) {\n      return false;\n    }\n\n    return this._readableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._readableState) {\n      return;\n    } // backward compatibility, the user is explicitly\n    // managing destroyed\n\n\n    this._readableState.destroyed = value;\n  }\n});\nReadable.prototype.destroy = destroyImpl.destroy;\nReadable.prototype._undestroy = destroyImpl.undestroy;\n\nReadable.prototype._destroy = function (err, cb) {\n  cb(err);\n}; // Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\n\n\nReadable.prototype.push = function (chunk, encoding) {\n  var state = this._readableState;\n  var skipChunkCheck;\n\n  if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      encoding = encoding || state.defaultEncoding;\n\n      if (encoding !== state.encoding) {\n        chunk = Buffer.from(chunk, encoding);\n        encoding = '';\n      }\n\n      skipChunkCheck = true;\n    }\n  } else {\n    skipChunkCheck = true;\n  }\n\n  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\n}; // Unshift should *always* be something directly out of read()\n\n\nReadable.prototype.unshift = function (chunk) {\n  return readableAddChunk(this, chunk, null, true, false);\n};\n\nfunction readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n  debug('readableAddChunk', chunk);\n  var state = stream._readableState;\n\n  if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else {\n    var er;\n    if (!skipChunkCheck) er = chunkInvalid(state, chunk);\n\n    if (er) {\n      errorOrDestroy(stream, er);\n    } else if (state.objectMode || chunk && chunk.length > 0) {\n      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\n        chunk = _uint8ArrayToBuffer(chunk);\n      }\n\n      if (addToFront) {\n        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);\n      } else if (state.ended) {\n        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());\n      } else if (state.destroyed) {\n        return false;\n      } else {\n        state.reading = false;\n\n        if (state.decoder && !encoding) {\n          chunk = state.decoder.write(chunk);\n          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);\n        } else {\n          addChunk(stream, state, chunk, false);\n        }\n      }\n    } else if (!addToFront) {\n      state.reading = false;\n      maybeReadMore(stream, state);\n    }\n  } // We can push more data if we are below the highWaterMark.\n  // Also, if we have no data yet, we can stand some more bytes.\n  // This is to work around cases where hwm=0, such as the repl.\n\n\n  return !state.ended && (state.length < state.highWaterMark || state.length === 0);\n}\n\nfunction addChunk(stream, state, chunk, addToFront) {\n  if (state.flowing && state.length === 0 && !state.sync) {\n    state.awaitDrain = 0;\n    stream.emit('data', chunk);\n  } else {\n    // update the buffer info.\n    state.length += state.objectMode ? 1 : chunk.length;\n    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n    if (state.needReadable) emitReadable(stream);\n  }\n\n  maybeReadMore(stream, state);\n}\n\nfunction chunkInvalid(state, chunk) {\n  var er;\n\n  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);\n  }\n\n  return er;\n}\n\nReadable.prototype.isPaused = function () {\n  return this._readableState.flowing === false;\n}; // backwards compatibility.\n\n\nReadable.prototype.setEncoding = function (enc) {\n  if (!StringDecoder) StringDecoder = __webpack_require__(/*! string_decoder/ */ \"./node_modules/string_decoder/lib/string_decoder.js\").StringDecoder;\n  var decoder = new StringDecoder(enc);\n  this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8\n\n  this._readableState.encoding = this._readableState.decoder.encoding; // Iterate over current buffer to convert already stored Buffers:\n\n  var p = this._readableState.buffer.head;\n  var content = '';\n\n  while (p !== null) {\n    content += decoder.write(p.data);\n    p = p.next;\n  }\n\n  this._readableState.buffer.clear();\n\n  if (content !== '') this._readableState.buffer.push(content);\n  this._readableState.length = content.length;\n  return this;\n}; // Don't raise the hwm > 1GB\n\n\nvar MAX_HWM = 0x40000000;\n\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n\n  return n;\n} // This function is designed to be inlinable, so please take care when making\n// changes to the function body.\n\n\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || state.length === 0 && state.ended) return 0;\n  if (state.objectMode) return 1;\n\n  if (n !== n) {\n    // Only flow one buffer at a time\n    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n  } // If we're asking for more than the current hwm, then raise the hwm.\n\n\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n  if (n <= state.length) return n; // Don't have enough\n\n  if (!state.ended) {\n    state.needReadable = true;\n    return 0;\n  }\n\n  return state.length;\n} // you can override either this method, or the async _read(n) below.\n\n\nReadable.prototype.read = function (n) {\n  debug('read', n);\n  n = parseInt(n, 10);\n  var state = this._readableState;\n  var nOrig = n;\n  if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n\n  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.\n\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this);\n    return null;\n  } // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n  // if we need a readable event, then we need to do some reading.\n\n\n  var doRead = state.needReadable;\n  debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some\n\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  } // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n\n\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  } else if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true; // if the length is currently zero, then we *need* a readable event.\n\n    if (state.length === 0) state.needReadable = true; // call internal read method\n\n    this._read(state.highWaterMark);\n\n    state.sync = false; // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n\n    if (!state.reading) n = howMuchToRead(nOrig, state);\n  }\n\n  var ret;\n  if (n > 0) ret = fromList(n, state);else ret = null;\n\n  if (ret === null) {\n    state.needReadable = state.length <= state.highWaterMark;\n    n = 0;\n  } else {\n    state.length -= n;\n    state.awaitDrain = 0;\n  }\n\n  if (state.length === 0) {\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.\n\n    if (nOrig !== n && state.ended) endReadable(this);\n  }\n\n  if (ret !== null) this.emit('data', ret);\n  return ret;\n};\n\nfunction onEofChunk(stream, state) {\n  debug('onEofChunk');\n  if (state.ended) return;\n\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n\n  state.ended = true;\n\n  if (state.sync) {\n    // if we are sync, wait until next tick to emit the data.\n    // Otherwise we risk emitting data in the flow()\n    // the readable code triggers during a read() call\n    emitReadable(stream);\n  } else {\n    // emit 'readable' now to make sure it gets picked up.\n    state.needReadable = false;\n\n    if (!state.emittedReadable) {\n      state.emittedReadable = true;\n      emitReadable_(stream);\n    }\n  }\n} // Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\n\n\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  debug('emitReadable', state.needReadable, state.emittedReadable);\n  state.needReadable = false;\n\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    process.nextTick(emitReadable_, stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  var state = stream._readableState;\n  debug('emitReadable_', state.destroyed, state.length, state.ended);\n\n  if (!state.destroyed && (state.length || state.ended)) {\n    stream.emit('readable');\n    state.emittedReadable = false;\n  } // The stream needs another readable event if\n  // 1. It is not flowing, as the flow mechanism will take\n  //    care of it.\n  // 2. It is not ended.\n  // 3. It is below the highWaterMark, so we can schedule\n  //    another readable later.\n\n\n  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;\n  flow(stream);\n} // at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\n\n\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    process.nextTick(maybeReadMore_, stream, state);\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  // Attempt to read more data if we should.\n  //\n  // The conditions for reading more data are (one of):\n  // - Not enough data buffered (state.length < state.highWaterMark). The loop\n  //   is responsible for filling the buffer with enough data if such data\n  //   is available. If highWaterMark is 0 and we are not in the flowing mode\n  //   we should _not_ attempt to buffer any extra data. We'll get more data\n  //   when the stream consumer calls read() instead.\n  // - No data in the buffer, and the stream is in flowing mode. In this mode\n  //   the loop below is responsible for ensuring read() is called. Failing to\n  //   call read here would abort the flow and there's no other mechanism for\n  //   continuing the flow if the stream consumer has just subscribed to the\n  //   'data' event.\n  //\n  // In addition to the above conditions to keep reading data, the following\n  // conditions prevent the data from being read:\n  // - The stream has ended (state.ended).\n  // - There is already a pending 'read' operation (state.reading). This is a\n  //   case where the the stream has called the implementation defined _read()\n  //   method, but they are processing the call asynchronously and have _not_\n  //   called push() with new data. In this case we skip performing more\n  //   read()s. The execution ends in this method again after the _read() ends\n  //   up calling push() with more data.\n  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {\n    var len = state.length;\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length) // didn't get any data, stop spinning.\n      break;\n  }\n\n  state.readingMore = false;\n} // abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\n\n\nReadable.prototype._read = function (n) {\n  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));\n};\n\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n  var endFn = doEnd ? onend : unpipe;\n  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);\n  dest.on('unpipe', onunpipe);\n\n  function onunpipe(readable, unpipeInfo) {\n    debug('onunpipe');\n\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true;\n        cleanup();\n      }\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  } // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n\n\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n  var cleanedUp = false;\n\n  function cleanup() {\n    debug('cleanup'); // cleanup event handlers once the pipe is broken\n\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', unpipe);\n    src.removeListener('data', ondata);\n    cleanedUp = true; // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n  }\n\n  src.on('data', ondata);\n\n  function ondata(chunk) {\n    debug('ondata');\n    var ret = dest.write(chunk);\n    debug('dest.write', ret);\n\n    if (ret === false) {\n      // If the user unpiped during `dest.write()`, it is possible\n      // to get stuck in a permanently paused state if that write\n      // also returned false.\n      // => Check whether `dest` is still a piping destination.\n      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n        debug('false write response, pause', state.awaitDrain);\n        state.awaitDrain++;\n      }\n\n      src.pause();\n    }\n  } // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n\n\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);\n  } // Make sure our error handler is attached before userland ones.\n\n\n  prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.\n\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n\n  dest.once('close', onclose);\n\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  } // tell the dest that it's being piped to\n\n\n  dest.emit('pipe', src); // start the flow if it hasn't been started already.\n\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function pipeOnDrainFunctionResult() {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain) state.awaitDrain--;\n\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n\nReadable.prototype.unpipe = function (dest) {\n  var state = this._readableState;\n  var unpipeInfo = {\n    hasUnpiped: false\n  }; // if we're not piping anywhere, then do nothing.\n\n  if (state.pipesCount === 0) return this; // just one destination.  most common case.\n\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes) return this;\n    if (!dest) dest = state.pipes; // got a match.\n\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest) dest.emit('unpipe', this, unpipeInfo);\n    return this;\n  } // slow case. multiple pipe destinations.\n\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++) {\n      dests[i].emit('unpipe', this, {\n        hasUnpiped: false\n      });\n    }\n\n    return this;\n  } // try to find the right one.\n\n\n  var index = indexOf(state.pipes, dest);\n  if (index === -1) return this;\n  state.pipes.splice(index, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1) state.pipes = state.pipes[0];\n  dest.emit('unpipe', this, unpipeInfo);\n  return this;\n}; // set up data events if they are asked for\n// Ensure readable listeners eventually get something\n\n\nReadable.prototype.on = function (ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n  var state = this._readableState;\n\n  if (ev === 'data') {\n    // update readableListening so that resume() may be a no-op\n    // a few lines down. This is needed to support once('readable').\n    state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused\n\n    if (state.flowing !== false) this.resume();\n  } else if (ev === 'readable') {\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true;\n      state.flowing = false;\n      state.emittedReadable = false;\n      debug('on readable', state.length, state.reading);\n\n      if (state.length) {\n        emitReadable(this);\n      } else if (!state.reading) {\n        process.nextTick(nReadingNextTick, this);\n      }\n    }\n  }\n\n  return res;\n};\n\nReadable.prototype.addListener = Readable.prototype.on;\n\nReadable.prototype.removeListener = function (ev, fn) {\n  var res = Stream.prototype.removeListener.call(this, ev, fn);\n\n  if (ev === 'readable') {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this);\n  }\n\n  return res;\n};\n\nReadable.prototype.removeAllListeners = function (ev) {\n  var res = Stream.prototype.removeAllListeners.apply(this, arguments);\n\n  if (ev === 'readable' || ev === undefined) {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this);\n  }\n\n  return res;\n};\n\nfunction updateReadableListening(self) {\n  var state = self._readableState;\n  state.readableListening = self.listenerCount('readable') > 0;\n\n  if (state.resumeScheduled && !state.paused) {\n    // flowing needs to be set to true now, otherwise\n    // the upcoming resume will not flow.\n    state.flowing = true; // crude way to check if we should resume\n  } else if (self.listenerCount('data') > 0) {\n    self.resume();\n  }\n}\n\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n} // pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\n\n\nReadable.prototype.resume = function () {\n  var state = this._readableState;\n\n  if (!state.flowing) {\n    debug('resume'); // we flow only if there is no one listening\n    // for readable, but we still have to call\n    // resume()\n\n    state.flowing = !state.readableListening;\n    resume(this, state);\n  }\n\n  state.paused = false;\n  return this;\n};\n\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    process.nextTick(resume_, stream, state);\n  }\n}\n\nfunction resume_(stream, state) {\n  debug('resume', state.reading);\n\n  if (!state.reading) {\n    stream.read(0);\n  }\n\n  state.resumeScheduled = false;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading) stream.read(0);\n}\n\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing);\n\n  if (this._readableState.flowing !== false) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n\n  this._readableState.paused = true;\n  return this;\n};\n\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n\n  while (state.flowing && stream.read() !== null) {\n    ;\n  }\n} // wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\n\n\nReadable.prototype.wrap = function (stream) {\n  var _this = this;\n\n  var state = this._readableState;\n  var paused = false;\n  stream.on('end', function () {\n    debug('wrapped end');\n\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length) _this.push(chunk);\n    }\n\n    _this.push(null);\n  });\n  stream.on('data', function (chunk) {\n    debug('wrapped data');\n    if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode\n\n    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n\n    var ret = _this.push(chunk);\n\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  }); // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n\n  for (var i in stream) {\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = function methodWrap(method) {\n        return function methodWrapReturnFunction() {\n          return stream[method].apply(stream, arguments);\n        };\n      }(i);\n    }\n  } // proxy certain important events.\n\n\n  for (var n = 0; n < kProxyEvents.length; n++) {\n    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));\n  } // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n\n\n  this._read = function (n) {\n    debug('wrapped _read', n);\n\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return this;\n};\n\nif (typeof Symbol === 'function') {\n  Readable.prototype[Symbol.asyncIterator] = function () {\n    if (createReadableStreamAsyncIterator === undefined) {\n      createReadableStreamAsyncIterator = __webpack_require__(/*! ./internal/streams/async_iterator */ \"./node_modules/simple-peer/node_modules/readable-stream/lib/internal/streams/async_iterator.js\");\n    }\n\n    return createReadableStreamAsyncIterator(this);\n  };\n}\n\nObject.defineProperty(Readable.prototype, 'readableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.highWaterMark;\n  }\n});\nObject.defineProperty(Readable.prototype, 'readableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState && this._readableState.buffer;\n  }\n});\nObject.defineProperty(Readable.prototype, 'readableFlowing', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.flowing;\n  },\n  set: function set(state) {\n    if (this._readableState) {\n      this._readableState.flowing = state;\n    }\n  }\n}); // exposed for testing purposes only.\n\nReadable._fromList = fromList;\nObject.defineProperty(Readable.prototype, 'readableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.length;\n  }\n}); // Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\n\nfunction fromList(n, state) {\n  // nothing buffered\n  if (state.length === 0) return null;\n  var ret;\n  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n    // read it all, truncate the list\n    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);\n    state.buffer.clear();\n  } else {\n    // read part of list\n    ret = state.buffer.consume(n, state.decoder);\n  }\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n  debug('endReadable', state.endEmitted);\n\n  if (!state.endEmitted) {\n    state.ended = true;\n    process.nextTick(endReadableNT, state, stream);\n  }\n}\n\nfunction endReadableNT(state, stream) {\n  debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.\n\n  if (!state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit('end');\n\n    if (state.autoDestroy) {\n      // In case of duplex streams we need a way to detect\n      // if the writable side is ready for autoDestroy as well\n      var wState = stream._writableState;\n\n      if (!wState || wState.autoDestroy && wState.finished) {\n        stream.destroy();\n      }\n    }\n  }\n}\n\nif (typeof Symbol === 'function') {\n  Readable.from = function (iterable, opts) {\n    if (from === undefined) {\n      from = __webpack_require__(/*! ./internal/streams/from */ \"./node_modules/simple-peer/node_modules/readable-stream/lib/internal/streams/from-browser.js\");\n    }\n\n    return from(Readable, iterable, opts);\n  };\n}\n\nfunction indexOf(xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n\n  return -1;\n}\n\n//# sourceURL=webpack://someLibName/./node_modules/simple-peer/node_modules/readable-stream/lib/_stream_readable.js?");

/***/ }),

/***/ "./node_modules/simple-peer/node_modules/readable-stream/lib/_stream_transform.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/simple-peer/node_modules/readable-stream/lib/_stream_transform.js ***!
  \****************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\n\nmodule.exports = Transform;\n\nvar _require$codes = __webpack_require__(/*! ../errors */ \"./node_modules/simple-peer/node_modules/readable-stream/errors-browser.js\").codes,\n    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,\n    ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,\n    ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;\n\nvar Duplex = __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/simple-peer/node_modules/readable-stream/lib/_stream_duplex.js\");\n\n__webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")(Transform, Duplex);\n\nfunction afterTransform(er, data) {\n  var ts = this._transformState;\n  ts.transforming = false;\n  var cb = ts.writecb;\n\n  if (cb === null) {\n    return this.emit('error', new ERR_MULTIPLE_CALLBACK());\n  }\n\n  ts.writechunk = null;\n  ts.writecb = null;\n  if (data != null) // single equals check for both `null` and `undefined`\n    this.push(data);\n  cb(er);\n  var rs = this._readableState;\n  rs.reading = false;\n\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    this._read(rs.highWaterMark);\n  }\n}\n\nfunction Transform(options) {\n  if (!(this instanceof Transform)) return new Transform(options);\n  Duplex.call(this, options);\n  this._transformState = {\n    afterTransform: afterTransform.bind(this),\n    needTransform: false,\n    transforming: false,\n    writecb: null,\n    writechunk: null,\n    writeencoding: null\n  }; // start out asking for a readable event once data is transformed.\n\n  this._readableState.needReadable = true; // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n\n  this._readableState.sync = false;\n\n  if (options) {\n    if (typeof options.transform === 'function') this._transform = options.transform;\n    if (typeof options.flush === 'function') this._flush = options.flush;\n  } // When the writable side finishes, then flush out anything remaining.\n\n\n  this.on('prefinish', prefinish);\n}\n\nfunction prefinish() {\n  var _this = this;\n\n  if (typeof this._flush === 'function' && !this._readableState.destroyed) {\n    this._flush(function (er, data) {\n      done(_this, er, data);\n    });\n  } else {\n    done(this, null, null);\n  }\n}\n\nTransform.prototype.push = function (chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n}; // This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\n\n\nTransform.prototype._transform = function (chunk, encoding, cb) {\n  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));\n};\n\nTransform.prototype._write = function (chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n  }\n}; // Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\n\n\nTransform.prototype._read = function (n) {\n  var ts = this._transformState;\n\n  if (ts.writechunk !== null && !ts.transforming) {\n    ts.transforming = true;\n\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\n\nTransform.prototype._destroy = function (err, cb) {\n  Duplex.prototype._destroy.call(this, err, function (err2) {\n    cb(err2);\n  });\n};\n\nfunction done(stream, er, data) {\n  if (er) return stream.emit('error', er);\n  if (data != null) // single equals check for both `null` and `undefined`\n    stream.push(data); // TODO(BridgeAR): Write a test for these two error cases\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n\n  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();\n  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();\n  return stream.push(null);\n}\n\n//# sourceURL=webpack://someLibName/./node_modules/simple-peer/node_modules/readable-stream/lib/_stream_transform.js?");

/***/ }),

/***/ "./node_modules/simple-peer/node_modules/readable-stream/lib/_stream_writable.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/simple-peer/node_modules/readable-stream/lib/_stream_writable.js ***!
  \***************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n\n\nmodule.exports = Writable;\n/* <replacement> */\n\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n  this.next = null;\n} // It seems a linked list but it is not\n// there will be only 2 of these for each stream\n\n\nfunction CorkedRequest(state) {\n  var _this = this;\n\n  this.next = null;\n  this.entry = null;\n\n  this.finish = function () {\n    onCorkedFinish(_this, state);\n  };\n}\n/* </replacement> */\n\n/*<replacement>*/\n\n\nvar Duplex;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n/*<replacement>*/\n\nvar internalUtil = {\n  deprecate: __webpack_require__(/*! util-deprecate */ \"./node_modules/util-deprecate/browser.js\")\n};\n/*</replacement>*/\n\n/*<replacement>*/\n\nvar Stream = __webpack_require__(/*! ./internal/streams/stream */ \"./node_modules/simple-peer/node_modules/readable-stream/lib/internal/streams/stream-browser.js\");\n/*</replacement>*/\n\n\nvar Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\").Buffer;\n\nvar OurUint8Array = __webpack_require__.g.Uint8Array || function () {};\n\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\n\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\nvar destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ \"./node_modules/simple-peer/node_modules/readable-stream/lib/internal/streams/destroy.js\");\n\nvar _require = __webpack_require__(/*! ./internal/streams/state */ \"./node_modules/simple-peer/node_modules/readable-stream/lib/internal/streams/state.js\"),\n    getHighWaterMark = _require.getHighWaterMark;\n\nvar _require$codes = __webpack_require__(/*! ../errors */ \"./node_modules/simple-peer/node_modules/readable-stream/errors-browser.js\").codes,\n    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,\n    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,\n    ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,\n    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,\n    ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,\n    ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,\n    ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;\n\nvar errorOrDestroy = destroyImpl.errorOrDestroy;\n\n__webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")(Writable, Stream);\n\nfunction nop() {}\n\nfunction WritableState(options, stream, isDuplex) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/simple-peer/node_modules/readable-stream/lib/_stream_duplex.js\");\n  options = options || {}; // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream,\n  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.\n\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n\n  this.objectMode = !!options.objectMode;\n  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n\n  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex); // if _final has been called\n\n  this.finalCalled = false; // drain event flag.\n\n  this.needDrain = false; // at the start of calling end()\n\n  this.ending = false; // when end() has been called, and returned\n\n  this.ended = false; // when 'finish' is emitted\n\n  this.finished = false; // has it been destroyed\n\n  this.destroyed = false; // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n\n  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n\n  this.length = 0; // a flag to see when we're in the middle of a write.\n\n  this.writing = false; // when true all writes will be buffered until .uncork() call\n\n  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n\n  this.sync = true; // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n\n  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)\n\n  this.onwrite = function (er) {\n    onwrite(stream, er);\n  }; // the callback that the user supplies to write(chunk,encoding,cb)\n\n\n  this.writecb = null; // the amount that is being written when _write is called.\n\n  this.writelen = 0;\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n\n  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n\n  this.prefinished = false; // True if the error was already emitted and should not be thrown again\n\n  this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.\n\n  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'finish' (and potentially 'end')\n\n  this.autoDestroy = !!options.autoDestroy; // count buffered requests\n\n  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always\n  // one allocated and free to use, and we maintain at most two\n\n  this.corkedRequestsFree = new CorkedRequest(this);\n}\n\nWritableState.prototype.getBuffer = function getBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n\n  return out;\n};\n\n(function () {\n  try {\n    Object.defineProperty(WritableState.prototype, 'buffer', {\n      get: internalUtil.deprecate(function writableStateBufferGetter() {\n        return this.getBuffer();\n      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')\n    });\n  } catch (_) {}\n})(); // Test _writableState for inheritance to account for Duplex streams,\n// whose prototype chain only points to Readable.\n\n\nvar realHasInstance;\n\nif (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {\n  realHasInstance = Function.prototype[Symbol.hasInstance];\n  Object.defineProperty(Writable, Symbol.hasInstance, {\n    value: function value(object) {\n      if (realHasInstance.call(this, object)) return true;\n      if (this !== Writable) return false;\n      return object && object._writableState instanceof WritableState;\n    }\n  });\n} else {\n  realHasInstance = function realHasInstance(object) {\n    return object instanceof this;\n  };\n}\n\nfunction Writable(options) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/simple-peer/node_modules/readable-stream/lib/_stream_duplex.js\"); // Writable ctor is applied to Duplexes, too.\n  // `realHasInstance` is necessary because using plain `instanceof`\n  // would return false, as no `_writableState` property is attached.\n  // Trying to use the custom `instanceof` for Writable here will also break the\n  // Node.js LazyTransform implementation, which has a non-trivial getter for\n  // `_writableState` that would lead to infinite recursion.\n  // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the WritableState constructor, at least with V8 6.5\n\n  var isDuplex = this instanceof Duplex;\n  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);\n  this._writableState = new WritableState(options, this, isDuplex); // legacy.\n\n  this.writable = true;\n\n  if (options) {\n    if (typeof options.write === 'function') this._write = options.write;\n    if (typeof options.writev === 'function') this._writev = options.writev;\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n    if (typeof options.final === 'function') this._final = options.final;\n  }\n\n  Stream.call(this);\n} // Otherwise people can pipe Writable streams, which is just wrong.\n\n\nWritable.prototype.pipe = function () {\n  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());\n};\n\nfunction writeAfterEnd(stream, cb) {\n  var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb\n\n  errorOrDestroy(stream, er);\n  process.nextTick(cb, er);\n} // Checks that a user-supplied chunk is valid, especially for the particular\n// mode the stream is in. Currently this means that `null` is never accepted\n// and undefined/non-string values are only allowed in object mode.\n\n\nfunction validChunk(stream, state, chunk, cb) {\n  var er;\n\n  if (chunk === null) {\n    er = new ERR_STREAM_NULL_VALUES();\n  } else if (typeof chunk !== 'string' && !state.objectMode) {\n    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);\n  }\n\n  if (er) {\n    errorOrDestroy(stream, er);\n    process.nextTick(cb, er);\n    return false;\n  }\n\n  return true;\n}\n\nWritable.prototype.write = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n\n  var isBuf = !state.objectMode && _isUint8Array(chunk);\n\n  if (isBuf && !Buffer.isBuffer(chunk)) {\n    chunk = _uint8ArrayToBuffer(chunk);\n  }\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n  if (typeof cb !== 'function') cb = nop;\n  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\n  }\n  return ret;\n};\n\nWritable.prototype.cork = function () {\n  this._writableState.corked++;\n};\n\nWritable.prototype.uncork = function () {\n  var state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n  }\n};\n\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);\n  this._writableState.defaultEncoding = encoding;\n  return this;\n};\n\nObject.defineProperty(Writable.prototype, 'writableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState && this._writableState.getBuffer();\n  }\n});\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n    chunk = Buffer.from(chunk, encoding);\n  }\n\n  return chunk;\n}\n\nObject.defineProperty(Writable.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.highWaterMark;\n  }\n}); // if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\n\nfunction writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\n  if (!isBuf) {\n    var newChunk = decodeChunk(state, chunk, encoding);\n\n    if (chunk !== newChunk) {\n      isBuf = true;\n      encoding = 'buffer';\n      chunk = newChunk;\n    }\n  }\n\n  var len = state.objectMode ? 1 : chunk.length;\n  state.length += len;\n  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.\n\n  if (!ret) state.needDrain = true;\n\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = {\n      chunk: chunk,\n      encoding: encoding,\n      isBuf: isBuf,\n      callback: cb,\n      next: null\n    };\n\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n\n    state.bufferedRequestCount += 1;\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n\n  return ret;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n\n  if (sync) {\n    // defer the callback if we are being called synchronously\n    // to avoid piling up things on the stack\n    process.nextTick(cb, er); // this can emit finish, and it will always happen\n    // after error\n\n    process.nextTick(finishMaybe, stream, state);\n    stream._writableState.errorEmitted = true;\n    errorOrDestroy(stream, er);\n  } else {\n    // the caller expect this to happen before if\n    // it is async\n    cb(er);\n    stream._writableState.errorEmitted = true;\n    errorOrDestroy(stream, er); // this can emit finish, but finish must\n    // always follow error\n\n    finishMaybe(stream, state);\n  }\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();\n  onwriteStateUpdate(state);\n  if (er) onwriteError(stream, state, sync, er, cb);else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state) || stream.destroyed;\n\n    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n\n    if (sync) {\n      process.nextTick(afterWrite, stream, state, finished, cb);\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished) onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n} // Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\n\n\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n} // if there's something in the buffer waiting, then process it\n\n\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var l = state.bufferedRequestCount;\n    var buffer = new Array(l);\n    var holder = state.corkedRequestsFree;\n    holder.entry = entry;\n    var count = 0;\n    var allBuffers = true;\n\n    while (entry) {\n      buffer[count] = entry;\n      if (!entry.isBuf) allBuffers = false;\n      entry = entry.next;\n      count += 1;\n    }\n\n    buffer.allBuffers = allBuffers;\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time\n    // as the hot path ends with doWrite\n\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n\n    if (holder.next) {\n      state.corkedRequestsFree = holder.next;\n      holder.next = null;\n    } else {\n      state.corkedRequestsFree = new CorkedRequest(state);\n    }\n\n    state.bufferedRequestCount = 0;\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n\n      if (state.writing) {\n        break;\n      }\n    }\n\n    if (entry === null) state.lastBufferedRequest = null;\n  }\n\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function (chunk, encoding, cb) {\n  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function (chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks\n\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  } // ignore unnecessary end() calls.\n\n\n  if (!state.ending) endWritable(this, state, cb);\n  return this;\n};\n\nObject.defineProperty(Writable.prototype, 'writableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.length;\n  }\n});\n\nfunction needFinish(state) {\n  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n}\n\nfunction callFinal(stream, state) {\n  stream._final(function (err) {\n    state.pendingcb--;\n\n    if (err) {\n      errorOrDestroy(stream, err);\n    }\n\n    state.prefinished = true;\n    stream.emit('prefinish');\n    finishMaybe(stream, state);\n  });\n}\n\nfunction prefinish(stream, state) {\n  if (!state.prefinished && !state.finalCalled) {\n    if (typeof stream._final === 'function' && !state.destroyed) {\n      state.pendingcb++;\n      state.finalCalled = true;\n      process.nextTick(callFinal, stream, state);\n    } else {\n      state.prefinished = true;\n      stream.emit('prefinish');\n    }\n  }\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n\n  if (need) {\n    prefinish(stream, state);\n\n    if (state.pendingcb === 0) {\n      state.finished = true;\n      stream.emit('finish');\n\n      if (state.autoDestroy) {\n        // In case of duplex streams we need a way to detect\n        // if the readable side is ready for autoDestroy as well\n        var rState = stream._readableState;\n\n        if (!rState || rState.autoDestroy && rState.endEmitted) {\n          stream.destroy();\n        }\n      }\n    }\n  }\n\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n\n  if (cb) {\n    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);\n  }\n\n  state.ended = true;\n  stream.writable = false;\n}\n\nfunction onCorkedFinish(corkReq, state, err) {\n  var entry = corkReq.entry;\n  corkReq.entry = null;\n\n  while (entry) {\n    var cb = entry.callback;\n    state.pendingcb--;\n    cb(err);\n    entry = entry.next;\n  } // reuse the free corkReq.\n\n\n  state.corkedRequestsFree.next = corkReq;\n}\n\nObject.defineProperty(Writable.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._writableState === undefined) {\n      return false;\n    }\n\n    return this._writableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._writableState) {\n      return;\n    } // backward compatibility, the user is explicitly\n    // managing destroyed\n\n\n    this._writableState.destroyed = value;\n  }\n});\nWritable.prototype.destroy = destroyImpl.destroy;\nWritable.prototype._undestroy = destroyImpl.undestroy;\n\nWritable.prototype._destroy = function (err, cb) {\n  cb(err);\n};\n\n//# sourceURL=webpack://someLibName/./node_modules/simple-peer/node_modules/readable-stream/lib/_stream_writable.js?");

/***/ }),

/***/ "./node_modules/simple-peer/node_modules/readable-stream/lib/internal/streams/async_iterator.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/simple-peer/node_modules/readable-stream/lib/internal/streams/async_iterator.js ***!
  \******************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar _Object$setPrototypeO;\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar finished = __webpack_require__(/*! ./end-of-stream */ \"./node_modules/simple-peer/node_modules/readable-stream/lib/internal/streams/end-of-stream.js\");\n\nvar kLastResolve = Symbol('lastResolve');\nvar kLastReject = Symbol('lastReject');\nvar kError = Symbol('error');\nvar kEnded = Symbol('ended');\nvar kLastPromise = Symbol('lastPromise');\nvar kHandlePromise = Symbol('handlePromise');\nvar kStream = Symbol('stream');\n\nfunction createIterResult(value, done) {\n  return {\n    value: value,\n    done: done\n  };\n}\n\nfunction readAndResolve(iter) {\n  var resolve = iter[kLastResolve];\n\n  if (resolve !== null) {\n    var data = iter[kStream].read(); // we defer if data is null\n    // we can be expecting either 'end' or\n    // 'error'\n\n    if (data !== null) {\n      iter[kLastPromise] = null;\n      iter[kLastResolve] = null;\n      iter[kLastReject] = null;\n      resolve(createIterResult(data, false));\n    }\n  }\n}\n\nfunction onReadable(iter) {\n  // we wait for the next tick, because it might\n  // emit an error with process.nextTick\n  process.nextTick(readAndResolve, iter);\n}\n\nfunction wrapForNext(lastPromise, iter) {\n  return function (resolve, reject) {\n    lastPromise.then(function () {\n      if (iter[kEnded]) {\n        resolve(createIterResult(undefined, true));\n        return;\n      }\n\n      iter[kHandlePromise](resolve, reject);\n    }, reject);\n  };\n}\n\nvar AsyncIteratorPrototype = Object.getPrototypeOf(function () {});\nvar ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {\n  get stream() {\n    return this[kStream];\n  },\n\n  next: function next() {\n    var _this = this;\n\n    // if we have detected an error in the meanwhile\n    // reject straight away\n    var error = this[kError];\n\n    if (error !== null) {\n      return Promise.reject(error);\n    }\n\n    if (this[kEnded]) {\n      return Promise.resolve(createIterResult(undefined, true));\n    }\n\n    if (this[kStream].destroyed) {\n      // We need to defer via nextTick because if .destroy(err) is\n      // called, the error will be emitted via nextTick, and\n      // we cannot guarantee that there is no error lingering around\n      // waiting to be emitted.\n      return new Promise(function (resolve, reject) {\n        process.nextTick(function () {\n          if (_this[kError]) {\n            reject(_this[kError]);\n          } else {\n            resolve(createIterResult(undefined, true));\n          }\n        });\n      });\n    } // if we have multiple next() calls\n    // we will wait for the previous Promise to finish\n    // this logic is optimized to support for await loops,\n    // where next() is only called once at a time\n\n\n    var lastPromise = this[kLastPromise];\n    var promise;\n\n    if (lastPromise) {\n      promise = new Promise(wrapForNext(lastPromise, this));\n    } else {\n      // fast path needed to support multiple this.push()\n      // without triggering the next() queue\n      var data = this[kStream].read();\n\n      if (data !== null) {\n        return Promise.resolve(createIterResult(data, false));\n      }\n\n      promise = new Promise(this[kHandlePromise]);\n    }\n\n    this[kLastPromise] = promise;\n    return promise;\n  }\n}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {\n  return this;\n}), _defineProperty(_Object$setPrototypeO, \"return\", function _return() {\n  var _this2 = this;\n\n  // destroy(err, cb) is a private API\n  // we can guarantee we have that here, because we control the\n  // Readable class this is attached to\n  return new Promise(function (resolve, reject) {\n    _this2[kStream].destroy(null, function (err) {\n      if (err) {\n        reject(err);\n        return;\n      }\n\n      resolve(createIterResult(undefined, true));\n    });\n  });\n}), _Object$setPrototypeO), AsyncIteratorPrototype);\n\nvar createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {\n  var _Object$create;\n\n  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {\n    value: stream,\n    writable: true\n  }), _defineProperty(_Object$create, kLastResolve, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kLastReject, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kError, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kEnded, {\n    value: stream._readableState.endEmitted,\n    writable: true\n  }), _defineProperty(_Object$create, kHandlePromise, {\n    value: function value(resolve, reject) {\n      var data = iterator[kStream].read();\n\n      if (data) {\n        iterator[kLastPromise] = null;\n        iterator[kLastResolve] = null;\n        iterator[kLastReject] = null;\n        resolve(createIterResult(data, false));\n      } else {\n        iterator[kLastResolve] = resolve;\n        iterator[kLastReject] = reject;\n      }\n    },\n    writable: true\n  }), _Object$create));\n  iterator[kLastPromise] = null;\n  finished(stream, function (err) {\n    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {\n      var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise\n      // returned by next() and store the error\n\n      if (reject !== null) {\n        iterator[kLastPromise] = null;\n        iterator[kLastResolve] = null;\n        iterator[kLastReject] = null;\n        reject(err);\n      }\n\n      iterator[kError] = err;\n      return;\n    }\n\n    var resolve = iterator[kLastResolve];\n\n    if (resolve !== null) {\n      iterator[kLastPromise] = null;\n      iterator[kLastResolve] = null;\n      iterator[kLastReject] = null;\n      resolve(createIterResult(undefined, true));\n    }\n\n    iterator[kEnded] = true;\n  });\n  stream.on('readable', onReadable.bind(null, iterator));\n  return iterator;\n};\n\nmodule.exports = createReadableStreamAsyncIterator;\n\n//# sourceURL=webpack://someLibName/./node_modules/simple-peer/node_modules/readable-stream/lib/internal/streams/async_iterator.js?");

/***/ }),

/***/ "./node_modules/simple-peer/node_modules/readable-stream/lib/internal/streams/buffer_list.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/simple-peer/node_modules/readable-stream/lib/internal/streams/buffer_list.js ***!
  \***************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar _require = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\"),\n    Buffer = _require.Buffer;\n\nvar _require2 = __webpack_require__(/*! util */ \"?6e84\"),\n    inspect = _require2.inspect;\n\nvar custom = inspect && inspect.custom || 'inspect';\n\nfunction copyBuffer(src, target, offset) {\n  Buffer.prototype.copy.call(src, target, offset);\n}\n\nmodule.exports =\n/*#__PURE__*/\nfunction () {\n  function BufferList() {\n    _classCallCheck(this, BufferList);\n\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n\n  _createClass(BufferList, [{\n    key: \"push\",\n    value: function push(v) {\n      var entry = {\n        data: v,\n        next: null\n      };\n      if (this.length > 0) this.tail.next = entry;else this.head = entry;\n      this.tail = entry;\n      ++this.length;\n    }\n  }, {\n    key: \"unshift\",\n    value: function unshift(v) {\n      var entry = {\n        data: v,\n        next: this.head\n      };\n      if (this.length === 0) this.tail = entry;\n      this.head = entry;\n      ++this.length;\n    }\n  }, {\n    key: \"shift\",\n    value: function shift() {\n      if (this.length === 0) return;\n      var ret = this.head.data;\n      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;\n      --this.length;\n      return ret;\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.head = this.tail = null;\n      this.length = 0;\n    }\n  }, {\n    key: \"join\",\n    value: function join(s) {\n      if (this.length === 0) return '';\n      var p = this.head;\n      var ret = '' + p.data;\n\n      while (p = p.next) {\n        ret += s + p.data;\n      }\n\n      return ret;\n    }\n  }, {\n    key: \"concat\",\n    value: function concat(n) {\n      if (this.length === 0) return Buffer.alloc(0);\n      var ret = Buffer.allocUnsafe(n >>> 0);\n      var p = this.head;\n      var i = 0;\n\n      while (p) {\n        copyBuffer(p.data, ret, i);\n        i += p.data.length;\n        p = p.next;\n      }\n\n      return ret;\n    } // Consumes a specified amount of bytes or characters from the buffered data.\n\n  }, {\n    key: \"consume\",\n    value: function consume(n, hasStrings) {\n      var ret;\n\n      if (n < this.head.data.length) {\n        // `slice` is the same for buffers and strings.\n        ret = this.head.data.slice(0, n);\n        this.head.data = this.head.data.slice(n);\n      } else if (n === this.head.data.length) {\n        // First chunk is a perfect match.\n        ret = this.shift();\n      } else {\n        // Result spans more than one buffer.\n        ret = hasStrings ? this._getString(n) : this._getBuffer(n);\n      }\n\n      return ret;\n    }\n  }, {\n    key: \"first\",\n    value: function first() {\n      return this.head.data;\n    } // Consumes a specified amount of characters from the buffered data.\n\n  }, {\n    key: \"_getString\",\n    value: function _getString(n) {\n      var p = this.head;\n      var c = 1;\n      var ret = p.data;\n      n -= ret.length;\n\n      while (p = p.next) {\n        var str = p.data;\n        var nb = n > str.length ? str.length : n;\n        if (nb === str.length) ret += str;else ret += str.slice(0, n);\n        n -= nb;\n\n        if (n === 0) {\n          if (nb === str.length) {\n            ++c;\n            if (p.next) this.head = p.next;else this.head = this.tail = null;\n          } else {\n            this.head = p;\n            p.data = str.slice(nb);\n          }\n\n          break;\n        }\n\n        ++c;\n      }\n\n      this.length -= c;\n      return ret;\n    } // Consumes a specified amount of bytes from the buffered data.\n\n  }, {\n    key: \"_getBuffer\",\n    value: function _getBuffer(n) {\n      var ret = Buffer.allocUnsafe(n);\n      var p = this.head;\n      var c = 1;\n      p.data.copy(ret);\n      n -= p.data.length;\n\n      while (p = p.next) {\n        var buf = p.data;\n        var nb = n > buf.length ? buf.length : n;\n        buf.copy(ret, ret.length - n, 0, nb);\n        n -= nb;\n\n        if (n === 0) {\n          if (nb === buf.length) {\n            ++c;\n            if (p.next) this.head = p.next;else this.head = this.tail = null;\n          } else {\n            this.head = p;\n            p.data = buf.slice(nb);\n          }\n\n          break;\n        }\n\n        ++c;\n      }\n\n      this.length -= c;\n      return ret;\n    } // Make sure the linked list only shows the minimal necessary information.\n\n  }, {\n    key: custom,\n    value: function value(_, options) {\n      return inspect(this, _objectSpread({}, options, {\n        // Only inspect one level.\n        depth: 0,\n        // It should not recurse.\n        customInspect: false\n      }));\n    }\n  }]);\n\n  return BufferList;\n}();\n\n//# sourceURL=webpack://someLibName/./node_modules/simple-peer/node_modules/readable-stream/lib/internal/streams/buffer_list.js?");

/***/ }),

/***/ "./node_modules/simple-peer/node_modules/readable-stream/lib/internal/streams/destroy.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/simple-peer/node_modules/readable-stream/lib/internal/streams/destroy.js ***!
  \***********************************************************************************************/
/***/ ((module) => {

"use strict";
eval(" // undocumented cb() API, needed for core, not for public API\n\nfunction destroy(err, cb) {\n  var _this = this;\n\n  var readableDestroyed = this._readableState && this._readableState.destroyed;\n  var writableDestroyed = this._writableState && this._writableState.destroyed;\n\n  if (readableDestroyed || writableDestroyed) {\n    if (cb) {\n      cb(err);\n    } else if (err) {\n      if (!this._writableState) {\n        process.nextTick(emitErrorNT, this, err);\n      } else if (!this._writableState.errorEmitted) {\n        this._writableState.errorEmitted = true;\n        process.nextTick(emitErrorNT, this, err);\n      }\n    }\n\n    return this;\n  } // we set destroyed to true before firing error callbacks in order\n  // to make it re-entrance safe in case destroy() is called within callbacks\n\n\n  if (this._readableState) {\n    this._readableState.destroyed = true;\n  } // if this is a duplex stream mark the writable part as destroyed as well\n\n\n  if (this._writableState) {\n    this._writableState.destroyed = true;\n  }\n\n  this._destroy(err || null, function (err) {\n    if (!cb && err) {\n      if (!_this._writableState) {\n        process.nextTick(emitErrorAndCloseNT, _this, err);\n      } else if (!_this._writableState.errorEmitted) {\n        _this._writableState.errorEmitted = true;\n        process.nextTick(emitErrorAndCloseNT, _this, err);\n      } else {\n        process.nextTick(emitCloseNT, _this);\n      }\n    } else if (cb) {\n      process.nextTick(emitCloseNT, _this);\n      cb(err);\n    } else {\n      process.nextTick(emitCloseNT, _this);\n    }\n  });\n\n  return this;\n}\n\nfunction emitErrorAndCloseNT(self, err) {\n  emitErrorNT(self, err);\n  emitCloseNT(self);\n}\n\nfunction emitCloseNT(self) {\n  if (self._writableState && !self._writableState.emitClose) return;\n  if (self._readableState && !self._readableState.emitClose) return;\n  self.emit('close');\n}\n\nfunction undestroy() {\n  if (this._readableState) {\n    this._readableState.destroyed = false;\n    this._readableState.reading = false;\n    this._readableState.ended = false;\n    this._readableState.endEmitted = false;\n  }\n\n  if (this._writableState) {\n    this._writableState.destroyed = false;\n    this._writableState.ended = false;\n    this._writableState.ending = false;\n    this._writableState.finalCalled = false;\n    this._writableState.prefinished = false;\n    this._writableState.finished = false;\n    this._writableState.errorEmitted = false;\n  }\n}\n\nfunction emitErrorNT(self, err) {\n  self.emit('error', err);\n}\n\nfunction errorOrDestroy(stream, err) {\n  // We have tests that rely on errors being emitted\n  // in the same tick, so changing this is semver major.\n  // For now when you opt-in to autoDestroy we allow\n  // the error to be emitted nextTick. In a future\n  // semver major update we should change the default to this.\n  var rState = stream._readableState;\n  var wState = stream._writableState;\n  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);\n}\n\nmodule.exports = {\n  destroy: destroy,\n  undestroy: undestroy,\n  errorOrDestroy: errorOrDestroy\n};\n\n//# sourceURL=webpack://someLibName/./node_modules/simple-peer/node_modules/readable-stream/lib/internal/streams/destroy.js?");

/***/ }),

/***/ "./node_modules/simple-peer/node_modules/readable-stream/lib/internal/streams/end-of-stream.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/simple-peer/node_modules/readable-stream/lib/internal/streams/end-of-stream.js ***!
  \*****************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Ported from https://github.com/mafintosh/end-of-stream with\n// permission from the author, Mathias Buus (@mafintosh).\n\n\nvar ERR_STREAM_PREMATURE_CLOSE = __webpack_require__(/*! ../../../errors */ \"./node_modules/simple-peer/node_modules/readable-stream/errors-browser.js\").codes.ERR_STREAM_PREMATURE_CLOSE;\n\nfunction once(callback) {\n  var called = false;\n  return function () {\n    if (called) return;\n    called = true;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    callback.apply(this, args);\n  };\n}\n\nfunction noop() {}\n\nfunction isRequest(stream) {\n  return stream.setHeader && typeof stream.abort === 'function';\n}\n\nfunction eos(stream, opts, callback) {\n  if (typeof opts === 'function') return eos(stream, null, opts);\n  if (!opts) opts = {};\n  callback = once(callback || noop);\n  var readable = opts.readable || opts.readable !== false && stream.readable;\n  var writable = opts.writable || opts.writable !== false && stream.writable;\n\n  var onlegacyfinish = function onlegacyfinish() {\n    if (!stream.writable) onfinish();\n  };\n\n  var writableEnded = stream._writableState && stream._writableState.finished;\n\n  var onfinish = function onfinish() {\n    writable = false;\n    writableEnded = true;\n    if (!readable) callback.call(stream);\n  };\n\n  var readableEnded = stream._readableState && stream._readableState.endEmitted;\n\n  var onend = function onend() {\n    readable = false;\n    readableEnded = true;\n    if (!writable) callback.call(stream);\n  };\n\n  var onerror = function onerror(err) {\n    callback.call(stream, err);\n  };\n\n  var onclose = function onclose() {\n    var err;\n\n    if (readable && !readableEnded) {\n      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();\n      return callback.call(stream, err);\n    }\n\n    if (writable && !writableEnded) {\n      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();\n      return callback.call(stream, err);\n    }\n  };\n\n  var onrequest = function onrequest() {\n    stream.req.on('finish', onfinish);\n  };\n\n  if (isRequest(stream)) {\n    stream.on('complete', onfinish);\n    stream.on('abort', onclose);\n    if (stream.req) onrequest();else stream.on('request', onrequest);\n  } else if (writable && !stream._writableState) {\n    // legacy streams\n    stream.on('end', onlegacyfinish);\n    stream.on('close', onlegacyfinish);\n  }\n\n  stream.on('end', onend);\n  stream.on('finish', onfinish);\n  if (opts.error !== false) stream.on('error', onerror);\n  stream.on('close', onclose);\n  return function () {\n    stream.removeListener('complete', onfinish);\n    stream.removeListener('abort', onclose);\n    stream.removeListener('request', onrequest);\n    if (stream.req) stream.req.removeListener('finish', onfinish);\n    stream.removeListener('end', onlegacyfinish);\n    stream.removeListener('close', onlegacyfinish);\n    stream.removeListener('finish', onfinish);\n    stream.removeListener('end', onend);\n    stream.removeListener('error', onerror);\n    stream.removeListener('close', onclose);\n  };\n}\n\nmodule.exports = eos;\n\n//# sourceURL=webpack://someLibName/./node_modules/simple-peer/node_modules/readable-stream/lib/internal/streams/end-of-stream.js?");

/***/ }),

/***/ "./node_modules/simple-peer/node_modules/readable-stream/lib/internal/streams/from-browser.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/simple-peer/node_modules/readable-stream/lib/internal/streams/from-browser.js ***!
  \****************************************************************************************************/
/***/ ((module) => {

eval("module.exports = function () {\n  throw new Error('Readable.from is not available in the browser')\n};\n\n\n//# sourceURL=webpack://someLibName/./node_modules/simple-peer/node_modules/readable-stream/lib/internal/streams/from-browser.js?");

/***/ }),

/***/ "./node_modules/simple-peer/node_modules/readable-stream/lib/internal/streams/pipeline.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/simple-peer/node_modules/readable-stream/lib/internal/streams/pipeline.js ***!
  \************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Ported from https://github.com/mafintosh/pump with\n// permission from the author, Mathias Buus (@mafintosh).\n\n\nvar eos;\n\nfunction once(callback) {\n  var called = false;\n  return function () {\n    if (called) return;\n    called = true;\n    callback.apply(void 0, arguments);\n  };\n}\n\nvar _require$codes = __webpack_require__(/*! ../../../errors */ \"./node_modules/simple-peer/node_modules/readable-stream/errors-browser.js\").codes,\n    ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,\n    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;\n\nfunction noop(err) {\n  // Rethrow the error if it exists to avoid swallowing it\n  if (err) throw err;\n}\n\nfunction isRequest(stream) {\n  return stream.setHeader && typeof stream.abort === 'function';\n}\n\nfunction destroyer(stream, reading, writing, callback) {\n  callback = once(callback);\n  var closed = false;\n  stream.on('close', function () {\n    closed = true;\n  });\n  if (eos === undefined) eos = __webpack_require__(/*! ./end-of-stream */ \"./node_modules/simple-peer/node_modules/readable-stream/lib/internal/streams/end-of-stream.js\");\n  eos(stream, {\n    readable: reading,\n    writable: writing\n  }, function (err) {\n    if (err) return callback(err);\n    closed = true;\n    callback();\n  });\n  var destroyed = false;\n  return function (err) {\n    if (closed) return;\n    if (destroyed) return;\n    destroyed = true; // request.destroy just do .end - .abort is what we want\n\n    if (isRequest(stream)) return stream.abort();\n    if (typeof stream.destroy === 'function') return stream.destroy();\n    callback(err || new ERR_STREAM_DESTROYED('pipe'));\n  };\n}\n\nfunction call(fn) {\n  fn();\n}\n\nfunction pipe(from, to) {\n  return from.pipe(to);\n}\n\nfunction popCallback(streams) {\n  if (!streams.length) return noop;\n  if (typeof streams[streams.length - 1] !== 'function') return noop;\n  return streams.pop();\n}\n\nfunction pipeline() {\n  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {\n    streams[_key] = arguments[_key];\n  }\n\n  var callback = popCallback(streams);\n  if (Array.isArray(streams[0])) streams = streams[0];\n\n  if (streams.length < 2) {\n    throw new ERR_MISSING_ARGS('streams');\n  }\n\n  var error;\n  var destroys = streams.map(function (stream, i) {\n    var reading = i < streams.length - 1;\n    var writing = i > 0;\n    return destroyer(stream, reading, writing, function (err) {\n      if (!error) error = err;\n      if (err) destroys.forEach(call);\n      if (reading) return;\n      destroys.forEach(call);\n      callback(error);\n    });\n  });\n  return streams.reduce(pipe);\n}\n\nmodule.exports = pipeline;\n\n//# sourceURL=webpack://someLibName/./node_modules/simple-peer/node_modules/readable-stream/lib/internal/streams/pipeline.js?");

/***/ }),

/***/ "./node_modules/simple-peer/node_modules/readable-stream/lib/internal/streams/state.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/simple-peer/node_modules/readable-stream/lib/internal/streams/state.js ***!
  \*********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar ERR_INVALID_OPT_VALUE = __webpack_require__(/*! ../../../errors */ \"./node_modules/simple-peer/node_modules/readable-stream/errors-browser.js\").codes.ERR_INVALID_OPT_VALUE;\n\nfunction highWaterMarkFrom(options, isDuplex, duplexKey) {\n  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;\n}\n\nfunction getHighWaterMark(state, options, duplexKey, isDuplex) {\n  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);\n\n  if (hwm != null) {\n    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {\n      var name = isDuplex ? duplexKey : 'highWaterMark';\n      throw new ERR_INVALID_OPT_VALUE(name, hwm);\n    }\n\n    return Math.floor(hwm);\n  } // Default value\n\n\n  return state.objectMode ? 16 : 16 * 1024;\n}\n\nmodule.exports = {\n  getHighWaterMark: getHighWaterMark\n};\n\n//# sourceURL=webpack://someLibName/./node_modules/simple-peer/node_modules/readable-stream/lib/internal/streams/state.js?");

/***/ }),

/***/ "./node_modules/simple-peer/node_modules/readable-stream/lib/internal/streams/stream-browser.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/simple-peer/node_modules/readable-stream/lib/internal/streams/stream-browser.js ***!
  \******************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! events */ \"./node_modules/events/events.js\").EventEmitter;\n\n\n//# sourceURL=webpack://someLibName/./node_modules/simple-peer/node_modules/readable-stream/lib/internal/streams/stream-browser.js?");

/***/ }),

/***/ "./node_modules/simple-peer/node_modules/readable-stream/readable-browser.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/simple-peer/node_modules/readable-stream/readable-browser.js ***!
  \***********************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("exports = module.exports = __webpack_require__(/*! ./lib/_stream_readable.js */ \"./node_modules/simple-peer/node_modules/readable-stream/lib/_stream_readable.js\");\nexports.Stream = exports;\nexports.Readable = exports;\nexports.Writable = __webpack_require__(/*! ./lib/_stream_writable.js */ \"./node_modules/simple-peer/node_modules/readable-stream/lib/_stream_writable.js\");\nexports.Duplex = __webpack_require__(/*! ./lib/_stream_duplex.js */ \"./node_modules/simple-peer/node_modules/readable-stream/lib/_stream_duplex.js\");\nexports.Transform = __webpack_require__(/*! ./lib/_stream_transform.js */ \"./node_modules/simple-peer/node_modules/readable-stream/lib/_stream_transform.js\");\nexports.PassThrough = __webpack_require__(/*! ./lib/_stream_passthrough.js */ \"./node_modules/simple-peer/node_modules/readable-stream/lib/_stream_passthrough.js\");\nexports.finished = __webpack_require__(/*! ./lib/internal/streams/end-of-stream.js */ \"./node_modules/simple-peer/node_modules/readable-stream/lib/internal/streams/end-of-stream.js\");\nexports.pipeline = __webpack_require__(/*! ./lib/internal/streams/pipeline.js */ \"./node_modules/simple-peer/node_modules/readable-stream/lib/internal/streams/pipeline.js\");\n\n\n//# sourceURL=webpack://someLibName/./node_modules/simple-peer/node_modules/readable-stream/readable-browser.js?");

/***/ }),

/***/ "./node_modules/string_decoder/lib/string_decoder.js":
/*!***********************************************************!*\
  !*** ./node_modules/string_decoder/lib/string_decoder.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n/*<replacement>*/\n\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer;\n/*</replacement>*/\n\nvar isEncoding = Buffer.isEncoding || function (encoding) {\n  encoding = '' + encoding;\n  switch (encoding && encoding.toLowerCase()) {\n    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':\n      return true;\n    default:\n      return false;\n  }\n};\n\nfunction _normalizeEncoding(enc) {\n  if (!enc) return 'utf8';\n  var retried;\n  while (true) {\n    switch (enc) {\n      case 'utf8':\n      case 'utf-8':\n        return 'utf8';\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return 'utf16le';\n      case 'latin1':\n      case 'binary':\n        return 'latin1';\n      case 'base64':\n      case 'ascii':\n      case 'hex':\n        return enc;\n      default:\n        if (retried) return; // undefined\n        enc = ('' + enc).toLowerCase();\n        retried = true;\n    }\n  }\n};\n\n// Do not cache `Buffer.isEncoding` when checking encoding names as some\n// modules monkey-patch it to support additional encodings\nfunction normalizeEncoding(enc) {\n  var nenc = _normalizeEncoding(enc);\n  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);\n  return nenc || enc;\n}\n\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters.\nexports.StringDecoder = StringDecoder;\nfunction StringDecoder(encoding) {\n  this.encoding = normalizeEncoding(encoding);\n  var nb;\n  switch (this.encoding) {\n    case 'utf16le':\n      this.text = utf16Text;\n      this.end = utf16End;\n      nb = 4;\n      break;\n    case 'utf8':\n      this.fillLast = utf8FillLast;\n      nb = 4;\n      break;\n    case 'base64':\n      this.text = base64Text;\n      this.end = base64End;\n      nb = 3;\n      break;\n    default:\n      this.write = simpleWrite;\n      this.end = simpleEnd;\n      return;\n  }\n  this.lastNeed = 0;\n  this.lastTotal = 0;\n  this.lastChar = Buffer.allocUnsafe(nb);\n}\n\nStringDecoder.prototype.write = function (buf) {\n  if (buf.length === 0) return '';\n  var r;\n  var i;\n  if (this.lastNeed) {\n    r = this.fillLast(buf);\n    if (r === undefined) return '';\n    i = this.lastNeed;\n    this.lastNeed = 0;\n  } else {\n    i = 0;\n  }\n  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);\n  return r || '';\n};\n\nStringDecoder.prototype.end = utf8End;\n\n// Returns only complete characters in a Buffer\nStringDecoder.prototype.text = utf8Text;\n\n// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer\nStringDecoder.prototype.fillLast = function (buf) {\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);\n  this.lastNeed -= buf.length;\n};\n\n// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a\n// continuation byte. If an invalid byte is detected, -2 is returned.\nfunction utf8CheckByte(byte) {\n  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;\n  return byte >> 6 === 0x02 ? -1 : -2;\n}\n\n// Checks at most 3 bytes at the end of a Buffer in order to detect an\n// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)\n// needed to complete the UTF-8 character (if applicable) are returned.\nfunction utf8CheckIncomplete(self, buf, i) {\n  var j = buf.length - 1;\n  if (j < i) return 0;\n  var nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 1;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 2;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) {\n      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;\n    }\n    return nb;\n  }\n  return 0;\n}\n\n// Validates as many continuation bytes for a multi-byte UTF-8 character as\n// needed or are available. If we see a non-continuation byte where we expect\n// one, we \"replace\" the validated continuation bytes we've seen so far with\n// a single UTF-8 replacement character ('\\ufffd'), to match v8's UTF-8 decoding\n// behavior. The continuation byte check is included three times in the case\n// where all of the continuation bytes for a character exist in the same buffer.\n// It is also done this way as a slight performance increase instead of using a\n// loop.\nfunction utf8CheckExtraBytes(self, buf, p) {\n  if ((buf[0] & 0xC0) !== 0x80) {\n    self.lastNeed = 0;\n    return '\\ufffd';\n  }\n  if (self.lastNeed > 1 && buf.length > 1) {\n    if ((buf[1] & 0xC0) !== 0x80) {\n      self.lastNeed = 1;\n      return '\\ufffd';\n    }\n    if (self.lastNeed > 2 && buf.length > 2) {\n      if ((buf[2] & 0xC0) !== 0x80) {\n        self.lastNeed = 2;\n        return '\\ufffd';\n      }\n    }\n  }\n}\n\n// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.\nfunction utf8FillLast(buf) {\n  var p = this.lastTotal - this.lastNeed;\n  var r = utf8CheckExtraBytes(this, buf, p);\n  if (r !== undefined) return r;\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, p, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, p, 0, buf.length);\n  this.lastNeed -= buf.length;\n}\n\n// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a\n// partial character, the character's bytes are buffered until the required\n// number of bytes are available.\nfunction utf8Text(buf, i) {\n  var total = utf8CheckIncomplete(this, buf, i);\n  if (!this.lastNeed) return buf.toString('utf8', i);\n  this.lastTotal = total;\n  var end = buf.length - (total - this.lastNeed);\n  buf.copy(this.lastChar, 0, end);\n  return buf.toString('utf8', i, end);\n}\n\n// For UTF-8, a replacement character is added when ending on a partial\n// character.\nfunction utf8End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + '\\ufffd';\n  return r;\n}\n\n// UTF-16LE typically needs two bytes per character, but even if we have an even\n// number of bytes available, we need to check if we end on a leading/high\n// surrogate. In that case, we need to wait for the next two bytes in order to\n// decode the last character properly.\nfunction utf16Text(buf, i) {\n  if ((buf.length - i) % 2 === 0) {\n    var r = buf.toString('utf16le', i);\n    if (r) {\n      var c = r.charCodeAt(r.length - 1);\n      if (c >= 0xD800 && c <= 0xDBFF) {\n        this.lastNeed = 2;\n        this.lastTotal = 4;\n        this.lastChar[0] = buf[buf.length - 2];\n        this.lastChar[1] = buf[buf.length - 1];\n        return r.slice(0, -1);\n      }\n    }\n    return r;\n  }\n  this.lastNeed = 1;\n  this.lastTotal = 2;\n  this.lastChar[0] = buf[buf.length - 1];\n  return buf.toString('utf16le', i, buf.length - 1);\n}\n\n// For UTF-16LE we do not explicitly append special replacement characters if we\n// end on a partial character, we simply let v8 handle that.\nfunction utf16End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) {\n    var end = this.lastTotal - this.lastNeed;\n    return r + this.lastChar.toString('utf16le', 0, end);\n  }\n  return r;\n}\n\nfunction base64Text(buf, i) {\n  var n = (buf.length - i) % 3;\n  if (n === 0) return buf.toString('base64', i);\n  this.lastNeed = 3 - n;\n  this.lastTotal = 3;\n  if (n === 1) {\n    this.lastChar[0] = buf[buf.length - 1];\n  } else {\n    this.lastChar[0] = buf[buf.length - 2];\n    this.lastChar[1] = buf[buf.length - 1];\n  }\n  return buf.toString('base64', i, buf.length - n);\n}\n\nfunction base64End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);\n  return r;\n}\n\n// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)\nfunction simpleWrite(buf) {\n  return buf.toString(this.encoding);\n}\n\nfunction simpleEnd(buf) {\n  return buf && buf.length ? this.write(buf) : '';\n}\n\n//# sourceURL=webpack://someLibName/./node_modules/string_decoder/lib/string_decoder.js?");

/***/ }),

/***/ "./node_modules/util-deprecate/browser.js":
/*!************************************************!*\
  !*** ./node_modules/util-deprecate/browser.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n/**\n * Module exports.\n */\n\nmodule.exports = deprecate;\n\n/**\n * Mark that a method should not be used.\n * Returns a modified function which warns once by default.\n *\n * If `localStorage.noDeprecation = true` is set, then it is a no-op.\n *\n * If `localStorage.throwDeprecation = true` is set, then deprecated functions\n * will throw an Error when invoked.\n *\n * If `localStorage.traceDeprecation = true` is set, then deprecated functions\n * will invoke `console.trace()` instead of `console.error()`.\n *\n * @param {Function} fn - the function to deprecate\n * @param {String} msg - the string to print to the console when `fn` is invoked\n * @returns {Function} a new \"deprecated\" version of `fn`\n * @api public\n */\n\nfunction deprecate (fn, msg) {\n  if (config('noDeprecation')) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (config('throwDeprecation')) {\n        throw new Error(msg);\n      } else if (config('traceDeprecation')) {\n        console.trace(msg);\n      } else {\n        console.warn(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n}\n\n/**\n * Checks `localStorage` for boolean values for the given `name`.\n *\n * @param {String} name\n * @returns {Boolean}\n * @api private\n */\n\nfunction config (name) {\n  // accessing global.localStorage can trigger a DOMException in sandboxed iframes\n  try {\n    if (!__webpack_require__.g.localStorage) return false;\n  } catch (_) {\n    return false;\n  }\n  var val = __webpack_require__.g.localStorage[name];\n  if (null == val) return false;\n  return String(val).toLowerCase() === 'true';\n}\n\n\n//# sourceURL=webpack://someLibName/./node_modules/util-deprecate/browser.js?");

/***/ }),

/***/ "./wpsrc/app/appinit.js":
/*!******************************!*\
  !*** ./wpsrc/app/appinit.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("const myapp = __webpack_require__(/*! ./myapp */ \"./wpsrc/app/myapp.js\");\r\nconst serverComunicate = __webpack_require__(/*! ./serverComunicate */ \"./wpsrc/app/serverComunicate.js\");\r\nconst chtmsLstnr = __webpack_require__(/*! ./chatmouseListener */ \"./wpsrc/app/chatmouseListener.js\");\r\nconst token = __webpack_require__(/*! ../app/token */ \"./wpsrc/app/token.js\");\r\nconst chatapp = __webpack_require__(/*! ../chat/chatapp */ \"./wpsrc/chat/chatapp.js\");\r\nconst chatBox = __webpack_require__(/*! ../chat/chatbox/chatBox */ \"./wpsrc/chat/chatbox/chatBox.js\");\r\nconst cbxcntrl = __webpack_require__(/*! ../chat/chatbox/chtbxcontrol */ \"./wpsrc/chat/chatbox/chtbxcontrol.js\");\r\nconst chtbxtool = __webpack_require__(/*! ../chat/chatbox/chtbxtool */ \"./wpsrc/chat/chatbox/chtbxtool.js\");\r\nconst rcntcontact = __webpack_require__(/*! ../chat/recentContact */ \"./wpsrc/chat/recentContact.js\");\r\nconst bubble = __webpack_require__(/*! ../menu/bubble */ \"./wpsrc/menu/bubble.js\");\r\nconst mainMenu = __webpack_require__(/*! ../menu/mainMenu */ \"./wpsrc/menu/mainMenu.js\");\r\nconst srvcetool = __webpack_require__(/*! ../service/servicetool */ \"./wpsrc/service/servicetool.js\");\r\nconst chatsvctsk = __webpack_require__(/*! ../service/chattask/chatsvctsk */ \"./wpsrc/service/chattask/chatsvctsk.js\");\r\nconst chattask = __webpack_require__(/*! ../service/chattask/chattask */ \"./wpsrc/service/chattask/chattask.js\");\r\nconst service = __webpack_require__(/*! ../service/service */ \"./wpsrc/service/service.js\");\r\nconst tmvwtsk = __webpack_require__(/*! ../service/teamviewtask/teamvwtask */ \"./wpsrc/service/teamviewtask/teamvwtask.js\");\r\nconst contact = __webpack_require__(/*! ../contact/contact */ \"./wpsrc/contact/contact.js\");\r\nconst scrncapture = __webpack_require__(/*! ../teamviewer/screencapture */ \"./wpsrc/teamviewer/screencapture.js\");\r\nconst teamview = __webpack_require__(/*! ../teamviewer/teamview */ \"./wpsrc/teamviewer/teamview.js\");\r\nconst tvwcontrol = __webpack_require__(/*! ../teamviewer/tvwcontrol */ \"./wpsrc/teamviewer/tvwcontrol.js\");\r\n\r\nlet svrCom = {};// server communicate\r\nasync function authorized () {\r\n  token.init();\r\n  serverComunicate.init(token);\r\n  svrCom = serverComunicate.svrCom;\r\n}\r\n\r\nwindow.init = function (userid, username){\r\n  authorized();\r\n\r\n  myapp.init(svrCom, /*init user data*/ userid, username);\r\n  chtmsLstnr.init(myapp);\r\n  chatapp.init(myapp, service);\r\n  chtbxtool.init(myapp, chatBox, cbxcntrl, contact, srvcetool, service, token, svrCom);\r\n  chatBox.init(myapp, chtbxtool, cbxcntrl);\r\n  cbxcntrl.init(myapp, chatBox, teamview, svrCom);\r\n  rcntcontact.init(myapp, cbxcntrl, service, svrCom);\r\n  tmvwtsk.init(myapp, svrCom);\r\n  srvcetool.init(myapp);\r\n  chattask.init(myapp, srvcetool, chtbxtool, cbxcntrl, svrCom);\r\n  chatsvctsk.init(myapp, chattask, srvcetool, cbxcntrl, token, svrCom);\r\n  service.init(myapp, chatsvctsk, tmvwtsk, srvcetool);\r\n  bubble.init(myapp, service, token, svrCom);\r\n  mainMenu.init(myapp, contact, service, svrCom);\r\n  contact.init(myapp, service, svrCom);\r\n  tvwcontrol.init(myapp, svrCom);\r\n  scrncapture.init(tvwcontrol);\r\n  teamview.init(scrncapture);\r\n}\r\n\n\n//# sourceURL=webpack://someLibName/./wpsrc/app/appinit.js?");

/***/ }),

/***/ "./wpsrc/app/chatmouseListener.js":
/*!****************************************!*\
  !*** ./wpsrc/app/chatmouseListener.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"init\": () => (/* binding */ init)\n/* harmony export */ });\nlet MOUSESTATE;\r\n\r\nconst init = function (myapp) {\r\n  MOUSESTATE = myapp.MOUSESTATE;\r\n  initdocMouseEvt();\r\n  document.addEventListener('mousemove', function(e) {\r\n    if(!MOUSESTATE.LEFTMOUSEBUTTONONLYDOWN) return;\r\n\r\n    const currPos = {x: e.clientX, y: e.clientY};\r\n    updateCursor(currPos);\r\n\r\n    if(!(catched||chbxcatched||teamviewcatched))\r\n    switch ((document.elementFromPoint(currPos.x, currPos.y)||{className: false}).className) {\r\n      case \"puple\":\r\n      catched = true;\r\n      box = document.getElementById(\"pupleboxID\");\r\n      boxsizeX = box.clientWidth;\r\n      boxsizeY = box.clientHeight;\r\n      boxmousePointX = 25;// currPos.x - box.getBoundingClientRect().x;\r\n      boxmousePointY = 25;//currPos.y - box.getBoundingClientRect().y;\r\n      endX = document.documentElement.clientWidth - boxsizeX;\r\n      endY = document.documentElement.clientHeight -boxsizeY;\r\n      break;\r\n      case \"titlechatbox\":\r\n      chbxcatched = true;\r\n      id = document.elementFromPoint(currPos.x, currPos.y).getAttribute(\"chatboxid\");\r\n      box = document.getElementById(\"chatboxID\" + id);\r\n      boxsizeX = box.offsetWidth;\r\n      boxsizeY = box.offsetHeight;\r\n      boxmousePointX = currPos.x - box.getBoundingClientRect().x;\r\n      boxmousePointY = currPos.y - box.getBoundingClientRect().y + 55 /*chatpanel margin*/;\r\n      endX = document.documentElement.clientWidth - boxsizeX;\r\n      endY = document.documentElement.clientHeight - boxsizeY - 55 /*chatpanel margin*/;\r\n      break;\r\n      case \"teamviewcontrol\":\r\n      teamviewcatched = true;\r\n      const teamviewcontrol = document.elementFromPoint(currPos.x, currPos.y);\r\n\r\n      const chatboxid = teamviewcontrol.getAttribute(\"chatboxid\");\r\n      const userid = teamviewcontrol.getAttribute(\"userid\");\r\n\r\n      box = document.getElementById(\"teamviewwindowID\" + chatboxid + \"-\" + userid);\r\n      boxsizeX = box.offsetWidth;\r\n      boxsizeY = box.offsetHeight;\r\n      boxmousePointX = currPos.x - teamviewcontrol.getBoundingClientRect().x;\r\n      boxmousePointY = currPos.y - teamviewcontrol.getBoundingClientRect().y;\r\n      endX = document.documentElement.clientWidth - boxsizeX;\r\n      endY = document.documentElement.clientHeight - boxsizeY;\r\n      break;\r\n\r\n    }\r\n\r\n    if(ismoving) return;\r\n\r\n    switch (true) {\r\n      case (catched||chbxcatched||teamviewcatched):\r\n      moveTo(box, pos);\r\n      break;\r\n    }\r\n\r\n  });\r\n}\r\n\r\nlet endX, endY;\r\nfunction initdocMouseEvt(){\r\n  document.body.onmousedown = setLeftButtonState_onmousedown;\r\n  document.body.onmousemove = setLeftButtonState_onmousemove;\r\n  document.body.onmouseup = setLeftButtonState_onmouseup;\r\n  endX = document.documentElement.clientWidth - ppboxsize;\r\n  endY = document.documentElement.clientHeight - ppboxsize;\r\n}\r\n\r\nfunction setLeftButtonState_onmousemove(e) {\r\n  MOUSESTATE.LEFTMOUSEBUTTONONLYDOWN = (e.buttons === undefined ? e.which === 1 : e.buttons === 1);\r\n  MOUSESTATE.PRESSANDMOVE = true;\r\n}\r\n\r\nfunction setLeftButtonState_onmousedown(e) {\r\n  MOUSESTATE.LEFTMOUSEBUTTONONLYDOWN = (e.buttons === undefined ? e.which === 1 : e.buttons === 1);\r\n  MOUSESTATE.PRESSANDMOVE = false;\r\n}\r\n\r\nfunction setLeftButtonState_onmouseup(e) {\r\n  MOUSESTATE.LEFTMOUSEBUTTONONLYDOWN = (e.buttons === undefined ? e.which === 1 : e.buttons === 1);\r\n  catched = false;\r\n  chbxcatched = false;\r\n  teamviewcatched = false;\r\n}\r\n\r\nconst ppboxsize = 50;\r\nconst boxcenter = ppboxsize/2;\r\nlet boxsizeX = 0, boxsizeY = 0, boxmousePointX = 0, boxmousePointY = 0;\r\nconst pos = {posX: 0, posY: 0}\r\nlet catched = false, chbxcatched = false, teamviewcatched = false;\r\nlet ismoving = false;\r\nlet box = {};\r\nlet id = 0;\r\n\r\nfunction updateCursor(currPos) {\r\n  ismoving = false;\r\n  pos.posX = currPos.x-boxmousePointX, pos.posY = currPos.y-boxmousePointY;\r\n  if(pos.posX>=0&&pos.posX+boxsizeX<=document.documentElement.clientWidth&&pos.posY>=0&&pos.posY+boxsizeY<=document.documentElement.clientHeight) {\r\n    return;\r\n  }\r\n  if(pos.posX<0) { // duong vien cua viewport...\r\n    pos.posX = 0;\r\n    if(pos.posY <0) {\r\n      pos.posY = 0;\r\n    } else if(pos.posY+boxsizeY>document.documentElement.clientHeight) {\r\n      pos.posY = endY;\r\n    }\r\n    return;\r\n  } else if(pos.posX+boxsizeX>document.documentElement.clientWidth) {\r\n    pos.posX = endX;\r\n  }\r\n  if(pos.posY <0) {\r\n    pos.posY = 0;\r\n  } else if(pos.posY+boxsizeY>document.documentElement.clientHeight) {\r\n    pos.posY = endY;\r\n  }\r\n}\r\n\r\nasync function moveTo(box, pos) {\r\n  const currX = box.offsetLeft;\r\n  const currY = box.offsetTop;\r\n  const Dx = pos.posX - currX;\r\n  const Dy = pos.posY - currY;\r\n  const basicHandSpeed = 12;\r\n  let Dx_ = 0, Dy_= 0;\r\n  const stepx = Dx/basicHandSpeed, stepy = Dy/basicHandSpeed;\r\n  // box.style.left = (currX+Dx)+\"px\";\r\n  // box.style.top = (currY+Dy)+\"px\";\r\n  new Promise(function(resolve, reject) {\r\n    ismoving = true;\r\n    for(let i = 0; i < basicHandSpeed; i++) {\r\n      box.style.left = (currX+(Dx_+=stepx))+\"px\";\r\n      box.style.top = (currY+(Dy_+=stepy))+\"px\";\r\n    }\r\n    resolve();\r\n  }).then(async()=>{\r\n    ismoving = false;\r\n  });\r\n}\r\n\n\n//# sourceURL=webpack://someLibName/./wpsrc/app/chatmouseListener.js?");

/***/ }),

/***/ "./wpsrc/app/domtl.js":
/*!****************************!*\
  !*** ./wpsrc/app/domtl.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"domtool\": () => (/* binding */ domtool)\n/* harmony export */ });\n\r\nconst domtool = {\r\n\r\n  creatediv: function (classname, id) {\r\n    const ele = document.createElement(\"div\");\r\n    ele.classList.add(classname);\r\n    if(typeof id === \"undefined\") return ele;\r\n    ele.id = id;\r\n    return ele;\r\n  },\r\n\r\n  createinput: function (type, classname, id) {\r\n    const ele = document.createElement(\"input\");\r\n    ele.type = type\r\n    ele.classList.add(classname);\r\n    if(typeof id === \"undefined\") return ele;\r\n    ele.id = id;\r\n    return ele;\r\n  },\r\n\r\n  createlabel: function (classname, id) {\r\n    const ele = document.createElement(\"label\");\r\n    ele.classList.add(classname);\r\n    if(typeof id === \"undefined\") return ele;\r\n    ele.id = id;\r\n    return ele;\r\n  },\r\n\r\n  createimg: function (classname, id) {\r\n    const ele = document.createElement(\"img\");\r\n    ele.classList.add(classname);\r\n    if(typeof id === \"undefined\") return ele;\r\n    ele.id = id;\r\n    return ele;\r\n  },\r\n\r\n  createa: function (classname, id) {\r\n    const ele = document.createElement(\"a\");\r\n    ele.classList.add(classname);\r\n    if(typeof id === \"undefined\") return ele;\r\n    ele.id = id;\r\n    return ele;\r\n  },\r\n\r\n  createiframe: function (classname, id) {\r\n    const ele = document.createElement(\"iframe\");\r\n    ele.classList.add(classname);\r\n    if(typeof id === \"undefined\") return ele;\r\n    ele.id = id;\r\n    return ele;\r\n  },\r\n\r\n  createvideo: function (classname, id) {\r\n    const ele = document.createElement(\"video\");\r\n    ele.classList.add(classname);\r\n    if(typeof id === \"undefined\") return ele;\r\n    ele.id = id;\r\n    return ele;\r\n  },\r\n  \r\n}\r\n\n\n//# sourceURL=webpack://someLibName/./wpsrc/app/domtl.js?");

/***/ }),

/***/ "./wpsrc/app/myapp.js":
/*!****************************!*\
  !*** ./wpsrc/app/myapp.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"init\": () => (/* binding */ init),\n/* harmony export */   \"USERDATA\": () => (/* binding */ USERDATA),\n/* harmony export */   \"CHATROOMTYPE\": () => (/* binding */ CHATROOMTYPE),\n/* harmony export */   \"CONTACTMODE\": () => (/* binding */ CONTACTMODE),\n/* harmony export */   \"TIMEFORGIVE\": () => (/* binding */ TIMEFORGIVE),\n/* harmony export */   \"CHATBOXSTATE\": () => (/* binding */ CHATBOXSTATE),\n/* harmony export */   \"NOTIFYTYPE\": () => (/* binding */ NOTIFYTYPE),\n/* harmony export */   \"MOUSESTATE\": () => (/* binding */ MOUSESTATE),\n/* harmony export */   \"UPDATER\": () => (/* binding */ UPDATER),\n/* harmony export */   \"APP\": () => (/* binding */ APP),\n/* harmony export */   \"ACTIVECHATBOX\": () => (/* binding */ ACTIVECHATBOX),\n/* harmony export */   \"PUPLESTATE\": () => (/* binding */ PUPLESTATE),\n/* harmony export */   \"TOUCH\": () => (/* binding */ TOUCH),\n/* harmony export */   \"getDateString\": () => (/* binding */ getDateString),\n/* harmony export */   \"sleep\": () => (/* binding */ sleep),\n/* harmony export */   \"executeAsync\": () => (/* binding */ executeAsync)\n/* harmony export */ });\nconst init = async function (svrCom, userid, username) {\r\n  USERDATA.ID = userid;\r\n  USERDATA.NAME = username;\r\n  Object.freeze(USERDATA); //set Enum\r\n\r\n  APP.DATA.chatboxlist = await(svrCom.serverchatcmnc.getChatboxlist());\r\n  (APP.DATA.chatboxlist||[]).forEach (async item => {\r\n    item.members = await(svrCom.serverchatcmnc.getchatboxMember(item.chatboxid));\r\n  });\r\n}\r\n\r\nconst USERDATA = {};\r\nconst CHATROOMTYPE = {TYPEFRIEND: \"friend\", TYPEGROUP: \"group\"};\r\nconst CONTACTMODE = {SELECT: \"select\", CHECKER: \"checker\"};\r\nconst TIMEFORGIVE = {ONLINE: 15000, CONVERSATION: 720000};\r\nconst CHATBOXSTATE = {MAXIMIZE: 2, MINIMIZE: 0, NORMAL: 1};\r\nconst NOTIFYTYPE = {TYPEADDFRIEND: \"addfriend\", TYPEADDGROUP: \"addgroup\", TYPEUNREADMESSAGE: \"unreadmessages\"};\r\nconst MOUSESTATE = {LEFTMOUSEBUTTONONLYDOWN: false, PRESSANDMOVE: false};\r\nconst UPDATER = {// sevice delay\r\n  neweventrate: {timeoutid: 0, delay: 3000, fullpower: 3000, limittocldn: 380, cldnrate: 20, cldnstep: 300, cldndelay: 1200},\r\n  srvrcchrate: {timeoutid: 0, delay: 3000, fullpower: 3000, limittocldn: 380, cldnrate: 20, cldnstep: 300, cldndelay: 1200},\r\n  brnsrcchrate: {timeoutid: 0, delay: 1000, fullpower: 1000, limittocldn: 180, cldnrate: 10,cldnstep: 100, cldndelay: 1200},\r\n  olnstatusrate: {timeoutid: 0, delay: 5000},\r\n  beatrate: {timeoutid: 0, delay: 1800},\r\n  cnfrate: {timeoutid: 0, delay: 1200},\r\n  useractionrate: {timeoutid: 0, delay: 220},\r\n  ISWAKEDUP: false,// wakeup\r\n  WAKEDUPDONE: false,// wakeup\r\n  dpslp: 40,\r\n}\r\n\r\nconst APP = {\r\n  DATA: {\r\n    inited: false,\r\n    chatboxlist:[],\r\n  },\r\n  NOTICE: {chatboxUnreadmessage : [], makerelateRequest: [], invitechatboxNotify: []}\r\n};\r\n\r\nconst ACTIVECHATBOX = {\r\n  selector: {\r\n    openlist:[],\r\n    last: new Date(),\r\n    isreadytoshow: function () {\r\n      if(new Date() - this.last > 500) {\r\n        this.last = new Date(); return true;\r\n      }\r\n      return false;\r\n    },\r\n    select: function(chatboxid) {\r\n      this.openlist.push(chatboxid);\r\n      for (var i = 0, len = this.openlist.length; i < len; i++) {\r\n        if (i< ACTIVECHATBOX.chatboxStack.maxWindows) continue;\r\n        this.openlist.remove(this.openlist[0]);\r\n      }\r\n    },\r\n  },\r\n\r\n  chatboxStack: {maxWindows: 3, data:[]},\r\n  recentchatbox: {hide: true, maxRecent: parseInt(window.innerWidth/150), data:[]}\r\n};\r\n\r\nconst PUPLESTATE = {showpuplebox_toolbar: true, show_addfriend: true, show_newgroup: true, show_story: true};\r\nconst TOUCH = {touchme: false, havechange: {value: false, last: false}, VOTEUPDATE: {updaterTotalVote: 0, newevent : {ticket: 1}, servercache: {ticket: 1}, brownsercache: {ticket: 1}}};\r\n\r\nObject.freeze(NOTIFYTYPE); //set Enum\r\nObject.freeze(CHATBOXSTATE); //set Enum\r\nObject.freeze(CHATROOMTYPE); //set Enum\r\nObject.freeze(TIMEFORGIVE); //set Enum\r\nObject.freeze(CONTACTMODE); //set Enum\r\n\r\nfunction getDateString(d){\r\n  const ye = new Intl.DateTimeFormat('en', { year: 'numeric' }).format(d);\r\n  const mo = new Intl.DateTimeFormat('en', { month: '2-digit' }).format(d);\r\n  const da = new Intl.DateTimeFormat('en', { day: '2-digit' }).format(d);\r\n  var hh = new Intl.DateTimeFormat('en', { hour: '2-digit', hour12: false }).format(d);\r\n  const mm = new Intl.DateTimeFormat('en', { minute: '2-digit' }).format(d);\r\n  const ss = new Intl.DateTimeFormat('en', { second: '2-digit' }).format(d);\r\n  if (parseInt(hh)>23) { hh = \"00\"; }\r\n  return `${ye}-${mo}-${da} ${hh}:${mm}:${ss}`;\r\n}\r\n\r\nArray.prototype.remove = function() {\r\n  var what, a = arguments, L = a.length, ax;\r\n  while (L && this.length) {\r\n    what = a[--L];\r\n    while ((ax = this.indexOf(what))!== -1) {\r\n      this.splice(ax, 1);\r\n    }\r\n  }\r\n  return this;\r\n};\r\n\r\nfunction sleep(ms) {\r\n  return new Promise(resolve => setTimeout(resolve, ms));\r\n}\r\n\r\nfunction executeAsync(func, delay) {\r\n  setTimeout(func, delay);\r\n}\r\n\n\n//# sourceURL=webpack://someLibName/./wpsrc/app/myapp.js?");

/***/ }),

/***/ "./wpsrc/app/serverComunicate.js":
/*!***************************************!*\
  !*** ./wpsrc/app/serverComunicate.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"init\": () => (/* binding */ init),\n/* harmony export */   \"svrCom\": () => (/* binding */ svrCom)\n/* harmony export */ });\nconst xmlHttpRequest = __webpack_require__(/*! ./xmlhttp */ \"./wpsrc/app/xmlhttp.js\");\r\n\r\nlet xmlhttp = {};\r\nlet token = {};\r\n\r\nconst init = function (_token) {\r\n  token = _token;\r\n  xmlHttpRequest(token.TOKEN, xmlhttp);\r\n}\r\n\r\nconst svrCom = {\r\n  serverchatcmnc: {\r\n\r\n    signout: function(){\r\n      xmlhttp.Get_XMLHttpRequest(\"/logout?token=\"+token.TOKEN.ACCESSTOKEN);\r\n    },\r\n\r\n    getChatboxlist: function(){\r\n      return xmlhttp.Get_XMLHttpRequest(\"/getChatboxlist\", \"\");\r\n    },\r\n\r\n    getchatboxMember: function (chatboxID){\r\n      return xmlhttp.Get_XMLHttpRequest(\"/getchatboxMember?chatboxid=\"+chatboxID, \"\");\r\n    },\r\n\r\n    getChatboxInfo: function (chatboxID){\r\n      return xmlhttp.Get_XMLHttpRequest(\"/getChatboxInfo?chatboxid=\"+chatboxID, \"\");\r\n    },\r\n\r\n    getConversationlist: function (chatboxID){\r\n      return xmlhttp.Get_XMLHttpRequest(\"/getConversationlist?chatboxid=\"+chatboxID, \"\");\r\n    },\r\n\r\n    getconversationData: function (conversationid, unhideUsermindid){\r\n      return xmlhttp.Get_XMLHttpRequest(\"/getconversationData?conversationid=\"+conversationid+\"&unhideUsermindid=\"+unhideUsermindid, \"\");\r\n    },\r\n\r\n    getLastConversation: function (chatboxid, datetime){ // datetime default undefined\r\n      return xmlhttp.Get_XMLHttpRequest(\"/getLastConversation?chatboxid=\"+chatboxid+\"&datetime=\"+datetime, \"\");\r\n    },\r\n\r\n    createConversation: function (chatboxid){\r\n      return xmlhttp.Get_XMLHttpRequest(\"createConversation?chatboxid=\"+chatboxid, \"\");\r\n    },\r\n\r\n    sendMessagetochatbox: async function (conversationid, item){\r\n      const formdata = new FormData();\r\n      formdata.append('conversationid', conversationid);\r\n      formdata.append('message',item.message);\r\n      formdata.append('datetimesend',item.datetimesend);\r\n      const rs = await xmlhttp.Post_XMLHttpRequest('/postMessagetochatbox', formdata);\r\n      return rs;\r\n    },\r\n\r\n    getChatboxUnreadmessage: function (conversationid){\r\n      const rs = xmlhttp.Get_XMLHttpRequest(\"/getChatboxUnreadmessage?conversationid=\"+conversationid, \"\")\r\n      return rs;\r\n    },\r\n\r\n    setmessageReaded: function (messageID, datetimeRead){\r\n      return xmlhttp.Get_XMLHttpRequest(\"setchatboxMessageReaded?unhideUsermindid=\"+messageID+\"&datetimeRead=\"+datetimeRead, \"\");\r\n    },\r\n\r\n    getfriendstillonline: function (friendid){\r\n      return xmlhttp.Get_XMLHttpRequest(\"/friendstillonline?friendid=\"+friendid, \"\");\r\n    },\r\n\r\n    istillonline: function (){\r\n      const xhr = new XMLHttpRequest();\r\n      xhr.open('GET',  \"/istillonline\", true);\r\n      xhr.timeout = 300; // time in milliseconds\r\n      xhr.setRequestHeader(\"x-access-token\", token.TOKEN.ACCESSTOKEN);\r\n      xhr.send(\"\");\r\n      return xhr.responseText;\r\n    },\r\n\r\n    getContactList: function (){\r\n      return xmlhttp.Get_XMLHttpRequest(\"/getcontactList\", \"\");\r\n    },\r\n\r\n    findUsername: function (pattern){\r\n      return xmlhttp.Get_XMLHttpRequest(\"/findUsername?pattern=\"+pattern, \"\");\r\n    },\r\n\r\n    gettouchMe: function (){\r\n      return xmlhttp.Get_XMLHttpRequest(\"/gettouchMe\", \"\");\r\n    },\r\n\r\n    settouchMe: function (){\r\n      return xmlhttp.Get_XMLHttpRequest(\"/settouchMe\", \"\");\r\n    },\r\n\r\n    sendmakerelateRequest: function (userid){\r\n      return xmlhttp.Get_XMLHttpRequest(\"/sendmakerelateRequest?userid=\"+userid, \"\");\r\n    },\r\n\r\n    getchatNotify: function (){\r\n      return xmlhttp.Get_XMLHttpRequest(\"getchatNotify\", \"\");\r\n    },\r\n\r\n    getMakerelateNotify: function () {\r\n      return xmlhttp.Get_XMLHttpRequest(\"/getMakerelateNotify\", \"\");\r\n    },\r\n\r\n    getInvitechatboxNotify: function () {\r\n      return xmlhttp.Get_XMLHttpRequest(\"/getInvitechatboxNotify\", \"\");\r\n    },\r\n\r\n    relateAccept: function (userid){\r\n      return xmlhttp.Get_XMLHttpRequest(\"/relateAccept?userid=\"+userid, \"\");\r\n    },\r\n\r\n    invitegroupAccept: function (userid, chatboxid){\r\n      return xmlhttp.Get_XMLHttpRequest(\"/invitegroupAccept?chatboxid=\"+chatboxid+\"&userid=\"+userid, \"\");\r\n    },\r\n\r\n    relateRefuse: function (userid){\r\n      return xmlhttp.Get_XMLHttpRequest(\"/relateRefuse?userid=\"+userid, \"\");\r\n    },\r\n\r\n    invitegroupRefuse: function (userid, chatboxid){\r\n      return xmlhttp.Get_XMLHttpRequest(\"/invitegroupRefuse?chatboxid=\"+chatboxid+\"&userid=\"+userid, \"\");\r\n    },\r\n\r\n    createChatbox: function (name) {\r\n      return xmlhttp.Get_XMLHttpRequest(\"/createChatbox?name=\"+name, \"\");\r\n    },\r\n\r\n    sendgroupRequest: function (chatboxid, receiverid){\r\n      return xmlhttp.Get_XMLHttpRequest(\"/groupRequest?chatboxid=\"+chatboxid+\"&receiverid=\"+receiverid, \"\");\r\n    },\r\n\r\n    removeContact: function (contactid){\r\n      return xmlhttp.Get_XMLHttpRequest(\"/removeContact?contactid=\"+contactid, \"\");\r\n    },\r\n\r\n    removechatboxMember: function (chatboxid, memberid){\r\n      return xmlhttp.Get_XMLHttpRequest(\"/removechatboxMember?chatboxid=\"+chatboxid+\"&memberid=\"+memberid, \"\");\r\n    },\r\n\r\n    getfriendchatbox: function (friendid) {\r\n      return xmlhttp.Get_XMLHttpRequest(\"/getfriendchatbox?friendid=\"+friendid, \"\");\r\n    },\r\n\r\n    createfriendchatbox: function (friendid, username) {\r\n      return xmlhttp.Get_XMLHttpRequest(\"/createfriendchatbox?friendid=\"+friendid+\"&username=\"+username, \"\");\r\n    },\r\n\r\n    updatememberChatboxname: function (chatboxid, userchatboxname) {\r\n      return xmlhttp.Get_XMLHttpRequest(\"/updatememberChatboxname?chatboxid=\"+chatboxid+\"&userchatboxname=\"+userchatboxname, \"\");\r\n    },\r\n\r\n    leaveChatbox: function (chatboxid) {\r\n      return xmlhttp.Get_XMLHttpRequest(\"/leaveChatbox?chatboxid=\"+chatboxid, \"\");\r\n    },\r\n\r\n    dissolateGroup: function (chatboxid) {\r\n      return xmlhttp.Get_XMLHttpRequest(\"/dissolateGroup?chatboxid=\"+chatboxid, \"\");\r\n    },\r\n\r\n    getSeenlist:function (unhideUsermindid) {\r\n      return xmlhttp.Get_XMLHttpRequest(\"/getSeenlist?unhideUsermindid=\"+unhideUsermindid, \"\");\r\n    },\r\n\r\n  },\r\n\r\n  serverstreamcmnc: {\r\n\r\n    jointochatbox: function (chatboxid) {\r\n      return xmlhttp.Get_XMLHttpRequest(\"/Sjointochatbox?chatboxid=\"+chatboxid, \"\");\r\n    },\r\n\r\n    leaveoutchatbox: function (chatboxid) {\r\n      return xmlhttp.Get_XMLHttpRequest(\"/Sleaveoutchatbox?chatboxid=\"+chatboxid, \"\");\r\n    },\r\n\r\n    userstilllivestream: function (chatboxid) {\r\n      return xmlhttp.Get_XMLHttpRequest(\"/Suserstilllivestream?chatboxid=\"+chatboxid, \"\");\r\n    },\r\n\r\n    sendMessagetochatbox: async function (conversationid, item){\r\n      const formdata = new FormData();\r\n      formdata.append('conversationid', conversationid);\r\n      formdata.append('message',item.message);\r\n      formdata.append('datetimesend',item.datetimesend);\r\n      const rs = await xmlhttp.Post_XMLHttpRequest('/SpostMessagetochatbox', formdata);\r\n      return rs;\r\n    },\r\n\r\n    getChatboxUnreadmessage: function (conversationid){\r\n      return xmlhttp.Get_XMLHttpRequest(\"/SgetChatboxUnreadmessage?conversationid=\"+conversationid, \"\")\r\n    },\r\n\r\n    requestfileuploadidid: function (chatboxid) {\r\n      return xmlhttp.Get_XMLHttpRequest(\"/Srequestfileuploadidid?chatboxid=\"+chatboxid, \"\");\r\n    },\r\n\r\n    getactiveChatboxlist: function (chatlist) {\r\n      const formdata = new FormData();\r\n      formdata.append('chatlist', chatlist);\r\n      const rs = xmlhttp.Post_XMLHttpRequest('/SgetactiveChatboxlist', formdata);\r\n      return rs;\r\n    },\r\n\r\n    getuserstreamchatbox: async function (chatboxid){\r\n      return xmlhttp.Get_XMLHttpRequest('/Suserismakemediacall?chatboxid='+chatboxid, \"\");\r\n    },\r\n\r\n    sendoffer: async function (chatboxid, offer){\r\n      const formdata = new FormData();\r\n      formdata.append('chatboxid', chatboxid);\r\n      formdata.append('offer', offer);\r\n      return xmlhttp.Post_XMLHttpRequest('/Ssendoffer', formdata);\r\n    },\r\n\r\n    getoffer: async function(chatboxid, userid){\r\n      return xmlhttp.Get_XMLHttpRequest('/Sgetoffer?chatboxid='+chatboxid+\"&userid=\"+userid, \"\");\r\n    },\r\n\r\n    sendanswer: async function(chatboxid, userid, answer){\r\n      const formdata = new FormData();\r\n      formdata.append('chatboxid', chatboxid);\r\n      formdata.append('userid', userid);\r\n      formdata.append('answer', answer);\r\n      return xmlhttp.Post_XMLHttpRequest('/Ssendanswer', formdata);\r\n    },\r\n\r\n    getanswer: async function(chatboxid){\r\n      return xmlhttp.Get_XMLHttpRequest('/Sgetanswer?chatboxid='+chatboxid, \"\");\r\n    },\r\n\r\n    offersideconnected: async function(chatboxid){\r\n      return xmlhttp.Get_XMLHttpRequest('/Soffersideconnected?chatboxid='+chatboxid, \"\");\r\n    },\r\n\r\n    answersideconnected: async function(chatboxid, userid){\r\n      return xmlhttp.Get_XMLHttpRequest('/Sanswersideconnected?chatboxid='+chatboxid+\"&userid=\"+userid, \"\");\r\n    },\r\n  }\r\n\r\n};\r\n\n\n//# sourceURL=webpack://someLibName/./wpsrc/app/serverComunicate.js?");

/***/ }),

/***/ "./wpsrc/app/token.js":
/*!****************************!*\
  !*** ./wpsrc/app/token.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"TOKEN\": () => (/* binding */ TOKEN),\n/* harmony export */   \"init\": () => (/* binding */ init),\n/* harmony export */   \"initToken\": () => (/* binding */ initToken),\n/* harmony export */   \"refreshtoken\": () => (/* binding */ refreshtoken)\n/* harmony export */ });\nconst xmlHttpRequest = __webpack_require__(/*! ./xmlhttp */ \"./wpsrc/app/xmlhttp.js\");\r\nlet xmlhttp = {};\r\n\r\nconst TOKEN = {ACCESSTOKEN: \"\", REFRESHTOKEN: \"\", UPDATEDAT: \"\"};\r\n\r\nconst init = function () {\r\n  initToken();\r\n}\r\n\r\nconst initToken = function () {\r\n  TOKEN.ACCESSTOKEN = getCookieTOKEN(\"chattoken\");\r\n  TOKEN.REFRESHTOKEN = getCookieTOKEN(\"chatrefreshtoken\");\r\n  xmlHttpRequest(TOKEN, xmlhttp);\r\n  updatetimestamp();\r\n}\r\n\r\nasync function updatetimestamp() {\r\n  const timestamp = await (getTokenTimestamp());\r\n  TOKEN.UPDATEDAT = timestamp.updatedAt;\r\n}\r\n\r\nfunction getCookieTOKEN(type){\r\n  for (const item of document.cookie.split(\";\")) {\r\n    const n = item.indexOf(type);\r\n    if(n<0)continue;\r\n    return (item.split(\"=\")[1]);\r\n  }\r\n}\r\n\r\nasync function saveChatTOKEN(token){\r\n  return new Promise(function(resolve, reject) {\r\n    document.cookie = \"chattoken=\"+token.accessToken;\r\n    document.cookie = \"chatrefreshtoken=\"+token.refreshToken;\r\n    resolve();\r\n  });\r\n}\r\n\r\nfunction refreshtoken() {// view more in serverUpdater\r\n  return new Promise(async function(resolve, reject) {\r\n    console.log(\"TOKEN: \", TOKEN);\r\n    const tokenRevice = JSON.parse(getnewChatTOKEN(TOKEN.REFRESHTOKEN));\r\n    resolve(tokenRevice);\r\n  }).then(async(tokenRevice)=>{\r\n    await saveChatTOKEN({accessToken: tokenRevice.accessToken, refreshToken: TOKEN.REFRESHTOKEN});\r\n    await initToken();\r\n    console.log(\"new TOKEN: \", TOKEN);\r\n  });\r\n}\r\n\r\nfunction getTokenTimestamp(){\r\n  return xmlhttp.Get_XMLHttpRequest(\"/tokenTimeStamp\", \"\");\r\n}\r\n\r\nfunction getnewChatTOKEN(refreshToken){\r\n  const xmlHttp = new XMLHttpRequest();\r\n  xmlHttp.open( \"GET\", \"/refresh_token\", false );\r\n  xmlHttp.setRequestHeader(\"x-access-token\", refreshToken);\r\n  xmlHttp.send( \"\" );\r\n  return(xmlHttp.responseText);\r\n}\r\n\n\n//# sourceURL=webpack://someLibName/./wpsrc/app/token.js?");

/***/ }),

/***/ "./wpsrc/app/xmlhttp.js":
/*!******************************!*\
  !*** ./wpsrc/app/xmlhttp.js ***!
  \******************************/
/***/ ((module) => {

eval("module.exports = (TOKEN, xmlhttp) => {\r\n\r\n  xmlhttp.Get_XMLHttpRequest = function (path, sendData) {\r\n\r\n    return new Promise((resolve, reject) => {\r\n\r\n      const xhr = new XMLHttpRequest();\r\n      xhr.open('GET', path, true);\r\n      xhr.timeout = 1200;\r\n      xhr.responseType = 'json';\r\n      const genericErrorText = \"Couldn't Get data\";\r\n      // add listeners\r\n      xhr.addEventListener('error', () => reject(genericErrorText));\r\n      xhr.addEventListener('abort', () => reject());\r\n      xhr.addEventListener('load', () => {\r\n        const response = xhr.response;\r\n        if (response && response.error) {\r\n          reject(response && response.error ? response.error.message : genericErrorText);\r\n        }\r\n        resolve(response);\r\n      });\r\n\r\n      xhr.ontimeout = function (e) {\r\n        console.log(\"timeout\");\r\n        alert(\"timeout\");\r\n        resolve({message: \"timeout\"});\r\n      };\r\n\r\n      xhr.setRequestHeader(\"x-access-token\", TOKEN.ACCESSTOKEN);\r\n      xhr.send(sendData);\r\n\r\n    }).catch(e => {\r\n      console.log(\"Get_XMLHttpRequest error: \", e);\r\n    });\r\n  }\r\n\r\n  xmlhttp.Post_XMLHttpRequest = function (path, formdata){\r\n\r\n    return new Promise((resolve, reject) => {\r\n\r\n      const xhr = new XMLHttpRequest();\r\n      xhr.open('POST', path, true);\r\n      xhr.responseType = 'json';\r\n      xhr.timeout = 1000;\r\n      const genericErrorText = \"Couldn't upload data\";\r\n      // add listeners\r\n      xhr.addEventListener('error', () => reject(genericErrorText));\r\n      xhr.addEventListener('abort', () => reject());\r\n      xhr.addEventListener('load', () => {\r\n        const response = xhr.response;\r\n        if (!response || response.error) {\r\n          return reject(response && response.error ? response.error.message : genericErrorText);\r\n        }\r\n        resolve(response);\r\n      });\r\n\r\n      xhr.ontimeout = function (e) {\r\n        console.log(\"timeout\");\r\n        resolve([]);\r\n      };\r\n\r\n      xhr.setRequestHeader(\"x-access-token\", TOKEN.ACCESSTOKEN);\r\n      xhr.send(formdata);\r\n    });\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack://someLibName/./wpsrc/app/xmlhttp.js?");

/***/ }),

/***/ "./wpsrc/chat/chatapp.js":
/*!*******************************!*\
  !*** ./wpsrc/chat/chatapp.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"init\": () => (/* binding */ init),\n/* harmony export */   \"chtlsttool\": () => (/* binding */ chtlsttool)\n/* harmony export */ });\nconst dmt = __webpack_require__(/*! ../app/domtl */ \"./wpsrc/app/domtl.js\");\r\n\r\nlet CHATROOMTYPE;\r\nlet ACTIVECHATBOX;\r\nlet _chatService;\r\n\r\nconst init = function (myapp, service) {\r\n  _chatService = service._chatService;\r\n  CHATROOMTYPE = myapp.CHATROOMTYPE;\r\n  ACTIVECHATBOX = myapp.ACTIVECHATBOX;\r\n\r\n  intitChatboxlist();\r\n}\r\n\r\nconst chtlsttool = {\r\n  getgrpiconchatlistitem: function (type) {\r\n    switch (type) {\r\n      case CHATROOMTYPE.TYPEGROUP:\r\n      const groupiconparent = dmt.domtool.creatediv(\"groupicon\");\r\n      const groupicon1 = dmt.domtool.creatediv(\"groupicon\");\r\n      const groupicon2 = dmt.domtool.creatediv(\"groupicon\");\r\n      const groupicon3 = dmt.domtool.creatediv(\"groupicon\");\r\n      groupiconparent.appendChild(groupicon1);\r\n      groupiconparent.appendChild(groupicon2);\r\n      groupiconparent.appendChild(groupicon3);\r\n      return groupiconparent;\r\n      case CHATROOMTYPE.TYPEFRIEND:\r\n      const icon = dmt.domtool.creatediv(\"icon\");\r\n      return icon;\r\n    }\r\n  },\r\n\r\n  createchtbxnamechatlistitem: function (type, chatboxid, chatboxName) {\r\n    switch (type) {\r\n      case CHATROOMTYPE.TYPEGROUP:\r\n      var chatlistitemname = dmt.domtool.creatediv(\"chatlistitemname\", \"chatlistitemnameID\"+chatboxid);\r\n      chatlistitemname.innerHTML = chatboxName;\r\n      return chatlistitemname;\r\n      case CHATROOMTYPE.TYPEFRIEND:\r\n      var chatlistitemname = dmt.domtool.creatediv(\"chatlistitemname\", \"chatlistitemnameID\"+chatboxid);\r\n      chatlistitemname.innerHTML = chatboxName;\r\n      return chatlistitemname;\r\n    }\r\n  },\r\n\r\n  getcallitem: function (chatboxid){\r\n    const callbean = dmt.domtool.creatediv(\"callbean\");\r\n    const callstream =  dmt.domtool.creatediv(\"callstream\");\r\n    callbean.appendChild(callstream);\r\n    return callbean;\r\n  },\r\n\r\n  getnoticeitem: function (chatboxid){\r\n    const notice =  dmt.domtool.creatediv(\"notice\");\r\n    notice.classList.add(\"hidenotice\");\r\n    notice.id = \"chatlistitemnotice\"+chatboxid;\r\n    const noticevalue =  dmt.domtool.creatediv(\"noticevalue\", \"chatlistitemnoticevalue\"+chatboxid);\r\n    noticevalue.innerHTML = 0;\r\n    notice.appendChild(noticevalue);\r\n    return notice;\r\n  },\r\n\r\n  chatlistitemSelect: function () {\r\n    const chatboxid =  this.getAttribute(\"chatboxid\");\r\n    this.classList.add (\"chatlistitemwillSelect\");\r\n    _chatService.userhaveaAction();\r\n    ACTIVECHATBOX.selector.select(chatboxid);\r\n  }\r\n}\r\n\r\nfunction intitChatboxlist(){\r\n  const chatlist = document.getElementById(\"chatlistID\");\r\n  chatlist.innerHTML = \"\";\r\n  // service will be init last part\r\n}\r\n\n\n//# sourceURL=webpack://someLibName/./wpsrc/chat/chatapp.js?");

/***/ }),

/***/ "./wpsrc/chat/chatbox/chatBox.js":
/*!***************************************!*\
  !*** ./wpsrc/chat/chatbox/chatBox.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"init\": () => (/* binding */ init),\n/* harmony export */   \"loadChatboxInfo\": () => (/* binding */ loadChatboxInfo),\n/* harmony export */   \"initmessagebox\": () => (/* binding */ initmessagebox),\n/* harmony export */   \"addChatbox\": () => (/* binding */ addChatbox),\n/* harmony export */   \"sendMessage\": () => (/* binding */ sendMessage)\n/* harmony export */ });\nconst dmt = __webpack_require__(/*! ../../app/domtl */ \"./wpsrc/app/domtl.js\");\r\n\r\nlet APPDATA;\r\nlet USERDATA;\r\nlet CHATROOMTYPE;\r\nlet ACBchatboxStackdata\r\nlet getDateString;\r\nlet chtbxtool;\r\nlet chbxcontrol;\r\n\r\nconst init = function (myapp, cbtool, cbxcntrl) {\r\n  APPDATA = myapp.APP.DATA;\r\n  USERDATA = myapp.USERDATA;\r\n  CHATROOMTYPE = myapp.CHATROOMTYPE;\r\n  ACBchatboxStackdata = myapp.ACTIVECHATBOX.chatboxStack.data;\r\n  getDateString = myapp.getDateString;\r\n  chtbxtool = cbtool.chtbxtool;\r\n  chbxcontrol = cbxcntrl.chbxcontrol;\r\n}\r\n\r\nasync function loadChatboxInfo(chatbox){\r\n  switch (chatbox.mesage) { case \"Unauthorized.\": return; }\r\n  let chatboxname = document.querySelector(\"#chatboxnameID\"+ chatbox.chatboxid);\r\n  if (!chatboxname) return;\r\n\r\n  let members = {};\r\n  const getmembers = item => {if(chatbox.chatboxid == item.chatboxid) {members = (item.members||[]); return true;}}\r\n  APPDATA.chatboxlist.some(getmembers);\r\n  if (!members) return ;\r\n\r\n  const memberList = document.querySelector(\"#memberID\"+chatbox.chatboxid);\r\n  memberList.innerHTML = \"\";\r\n  let USER_ISKEY = members.some(item => {if(item.userid == USERDATA.ID) return item.chatboxuserkey;});\r\n  members.forEach(item => {\r\n\r\n    if(item.userchatboxname&&item.userid == USERDATA.ID){\r\n      chatboxname.innerHTML = item.userchatboxname;\r\n    }\r\n    const memberitem = chtbxtool.creatememberitem(chatbox.chatboxid, item.userid, item.username, item.lasttimelogin);\r\n    switch (chatbox.type) {\r\n      case CHATROOMTYPE.TYPEFRIEND:\r\n\r\n      break;\r\n      default:\r\n      if (USER_ISKEY&&item.userid != USERDATA.ID) {\r\n        const removemember = chtbxtool.creatermvmembutton(chatbox.chatboxid, item.userid);\r\n        memberitem.appendChild(removemember);\r\n      }\r\n    }\r\n    memberList.appendChild(memberitem);\r\n  });\r\n}\r\n\r\nasync function initmessagebox(chatbox, lastconv, conversationData) {\r\n  switch (chatbox.mesage) { case \"Unauthorized.\": return; }\r\n  const messagebox = document.querySelector(\"#messageboxID\" + chatbox.chatboxid);\r\n  if (!messagebox) return ;\r\n  messagebox.innerHTML = \"\";\r\n\r\n  var chtbxStckdt_item = {};\r\n  const getChtbxStkdt_item = item => {if (chatbox.chatboxid == item.chatboxid) {chtbxStckdt_item = item; return /*break s_ome*/true;}}\r\n  ACBchatboxStackdata.some(getChtbxStkdt_item);\r\n  if (!lastconv){ // no more\r\n    chtbxStckdt_item.initcomplete = true;\r\n    const nomore = dmt.domtool.creatediv(\"nomore\");\r\n    nomore.innerHTML = \"No more message\"\r\n    messagebox.prepend(nomore);\r\n    return ;\r\n  }\r\n  const converstationinfo = dmt.domtool.creatediv(\"converstationinfo\");\r\n  converstationinfo.setAttribute(\"conversationid\", lastconv.conversationid);\r\n  const converstationstartat = dmt.domtool.creatediv(\"converstationstartat\");\r\n  converstationstartat.setAttribute(\"endAt\", lastconv.endAt);\r\n  converstationstartat.innerHTML = new Date(lastconv.startAt);\r\n  converstationinfo.append(converstationstartat);\r\n  messagebox.prepend(converstationinfo);\r\n\r\n  // if(conversationData[0])\r\n  await chtbxtool.fillconversation(chtbxStckdt_item, converstationinfo, conversationData, messagebox);\r\n\r\n  chbxcontrol.chtbxautoscrolllast(chatbox.chatboxid);\r\n}\r\n\r\n\r\nfunction addChatbox(chatboxObj){\r\n  return new Promise(function(resolve, reject) {\r\n    switch (chatboxObj.mesage) { case \"Unauthorized.\": return; }\r\n    // console.log(type, id);\r\n    const chatbox = dmt.domtool.creatediv(\"chatbox\", \"chatboxID\" + chatboxObj.chatboxid);\r\n    chatbox.setAttribute(\"chatboxid\", chatboxObj.chatboxid);\r\n    // chatbox.classList.add(\"chatboxwindow\");\r\n    const typingbox = dmt.domtool.creatediv(\"typingbox\", \"typingboxID\" + chatboxObj.chatboxid);\r\n    typingbox.setAttribute(\"chatboxid\", chatboxObj.chatboxid);\r\n\r\n    const sendfilebutton = dmt.domtool.createlabel(\"sendfilebutton\", \"sendfileID\" + chatboxObj.chatboxid);\r\n    const sendfileinput = dmt.domtool.createinput(\"file\", \"sendfilebutton\", \"sendfileID\" + chatboxObj.chatboxid);\r\n    sendfileinput.setAttribute(\"chatboxid\", chatboxObj.chatboxid);\r\n    sendfileinput.addEventListener(\"change\", chtbxtool.handleFiles);\r\n\r\n    const sendfileico = dmt.domtool.creatediv(\"sendfileico\");\r\n    sendfilebutton.setAttribute(\"chatboxid\", chatboxObj.chatboxid);\r\n    sendfilebutton.appendChild(sendfileico);\r\n    sendfilebutton.appendChild(sendfileinput);\r\n    const mess = document.createElement(\"textarea\");\r\n    mess.classList.add(\"mess\");\r\n    mess.id = \"messID\" + chatboxObj.chatboxid;\r\n    mess.setAttribute(\"chatboxid\", chatboxObj.chatboxid);\r\n    mess.addEventListener(\"input\", chtbxtool.autogrow);\r\n    mess.addEventListener(\"keypress\", chtbxtool.typingboxFilterandAction);\r\n    const sendbutton = dmt.domtool.creatediv(\"sendbutton\", \"sendbuttonID\" + chatboxObj.chatboxid);\r\n    sendbutton.setAttribute(\"chatboxid\", chatboxObj.chatboxid);\r\n    sendbutton.innerHTML = \"send\";\r\n    sendbutton.addEventListener(\"click\", chtbxtool.sendmsgAction);\r\n\r\n    const messagebox = dmt.domtool.creatediv(\"messagebox\", \"messageboxID\"+ chatboxObj.chatboxid);\r\n    messagebox.setAttribute(\"chatboxid\", chatboxObj.chatboxid);\r\n    messagebox.addEventListener(\"wheel\", chtbxtool.userscrollchecker);\r\n\r\n    const memberList = dmt.domtool.creatediv(\"member\", \"memberID\"+ chatboxObj.chatboxid);\r\n    memberList.setAttribute(\"chatboxid\", chatboxObj.chatboxid);\r\n    const titlechatbox = dmt.domtool.creatediv(\"titlechatbox\", \"titlechatboxID\" + chatboxObj.chatboxid);\r\n    titlechatbox.setAttribute(\"chatboxid\", chatboxObj.chatboxid);\r\n\r\n    const chatboxname = dmt.domtool.creatediv(\"chatboxname\", \"chatboxnameID\"+ chatboxObj.chatboxid);\r\n    chatboxname.setAttribute(\"chatboxid\", chatboxObj.chatboxid);\r\n    chatboxname.contentEditable = \"false\";\r\n    chatboxname.setAttribute(\"placeholder\", \"Your chatbox name\");\r\n    chatboxname.setAttribute(\"realchatboxname\", chatboxObj.chatboxName);\r\n    chatboxname.addEventListener('dblclick', chtbxtool.enablechatboxEditcbName );\r\n    chatboxname.addEventListener('keypress', chtbxtool.chatboxNameEditor);\r\n    chatboxname.innerHTML = chatboxObj.chatboxName + chatboxObj.chatboxid ;\r\n\r\n    const controlchatbox = dmt.domtool.creatediv(\"controlchatbox\");\r\n    const chatbox_minimize = dmt.domtool.creatediv(\"chatbox_minimize\", \"chatbox_minimizeID\"+ chatboxObj.chatboxid);\r\n    chatbox_minimize.setAttribute(\"chatboxid\", chatboxObj.chatboxid);\r\n    chatbox_minimize.addEventListener('click', chbxcontrol.chatboxminimize);\r\n    const chatbox_maximize = dmt.domtool.creatediv(\"chatbox_maximize\", \"chatbox_maximize\"+ chatboxObj.chatboxid);\r\n    chatbox_maximize.setAttribute(\"chatboxid\", chatboxObj.chatboxid);\r\n    chatbox_maximize.addEventListener('click', chbxcontrol.chatboxmaximize);\r\n    const chatbox_close = dmt.domtool.creatediv(\"chatbox_close\", \"chatbox_closeID\"+ chatboxObj.chatboxid);\r\n    chatbox_close.setAttribute(\"chatboxid\", chatboxObj.chatboxid);\r\n    chatbox_close.addEventListener('click',chbxcontrol.closechatbox );\r\n    chatbox_close.innerHTML = \"&times;\";\r\n    controlchatbox.appendChild(chatbox_minimize);\r\n    controlchatbox.appendChild(chatbox_maximize);\r\n    controlchatbox.appendChild(chatbox_close);\r\n    titlechatbox.appendChild(chatboxname);\r\n    titlechatbox.appendChild(controlchatbox);\r\n    typingbox.appendChild(sendfilebutton);\r\n    typingbox.appendChild(mess);\r\n    typingbox.appendChild(sendbutton);\r\n\r\n    chatbox.appendChild(typingbox);\r\n    chatbox.appendChild(messagebox);\r\n    chatbox.appendChild(memberList);\r\n    chatbox.appendChild(titlechatbox);\r\n    resolve({chatbox, messagebox});\r\n  }).then((rs)=>{\r\n    // register:\r\n    chtbxtool.chatboxregister(rs.chatbox, rs.messagebox, chatboxObj.chatboxid, chatboxObj.type);\r\n  });\r\n}\r\n\r\n// send data\r\nlet post_data_id = 0;\r\nfunction sendMessage(chatboxid){\r\n  const typingbox = document.querySelector(\"#messID\"+ chatboxid);\r\n  const mess = typingbox.value.replace(/'/g, \"\\'\");\r\n  if(mess.localeCompare(\"\") == 0) return;\r\n  const post_data = {\r\n    post_data_id: post_data_id,\r\n    chatboxid: chatboxid,\r\n    message: mess,\r\n    datetimesend: getDateString(new Date()) ,\r\n    sended: false,\r\n    success: false,\r\n    sendingcount: 0,\r\n    updateinbrowser: false,\r\n    resID: -1\r\n  };\r\n\r\n  temporaryShowClientMessage(chatboxid, post_data_id, mess);\r\n  const addSending_chatdata_cache = item => {\r\n    if(chatboxid != item.chatboxid) return;\r\n    item.sending_chatdata_cache.push(post_data);\r\n    post_data_id += 1;\r\n    typingbox.value = \"\";\r\n    chbxcontrol.textboxAutogrow(typingbox);// enter key\r\n    return true;\r\n  }\r\n  ACBchatboxStackdata.some(addSending_chatdata_cache);\r\n}\r\n\r\nfunction temporaryShowClientMessage(chatboxid, post_data_id, mess) {\r\n  const messageitem = dmt.domtool.creatediv(\"messageitem\", \"tempmessageitemID\"+post_data_id);\r\n  const messageitem_icon = dmt.domtool.creatediv(\"messageitem_icon\");\r\n  const userchatboxmessagae = dmt.domtool.creatediv(\"userchatboxmessagae\");\r\n  const messageinfo = dmt.domtool.creatediv(\"hidemessageinfo\", \"tempmessageinfoID\"+post_data_id);\r\n  messageinfo.innerHTML = \"sending...\";\r\n  const messgetextbean = dmt.domtool.creatediv(\"messgetextbean\");\r\n  const messgetext = dmt.domtool.creatediv(\"messgetext\", \"tempmessagetextID\"+post_data_id);\r\n  messgetext.classList.add(\"messgetextpresend\");\r\n  messgetext.classList.add(\"msguser\");\r\n  messgetext.innerHTML = mess;\r\n  messgetextbean.appendChild(messgetext);\r\n  userchatboxmessagae.appendChild(messageinfo);\r\n  userchatboxmessagae.appendChild(messgetextbean);\r\n  // messageitem.appendChild(messageitem_icon);\r\n  const checksened = getchecksened(post_data_id);\r\n  messageitem.appendChild(checksened);\r\n  messageitem.appendChild(userchatboxmessagae);\r\n  document.querySelector(\"#messageboxID\"+chatboxid).appendChild(messageitem);\r\n  chbxcontrol.chtbxautoscrolllast(chatboxid);\r\n}\r\n\r\nfunction getchecksened(post_data_id) {\r\n  const checksened = document.createElement(\"span\");\r\n  checksened.className = \"hidechecksened\";\r\n  checksened.id = \"checksenedID\" + post_data_id;\r\n  const checksened_stem = document.createElement(\"checksened_stem\");\r\n  checksened_stem.className = \"checksened_stem\";\r\n  const checksened_kick = document.createElement(\"checksened_kick\");\r\n  checksened_kick.className = \"checksened_kick\";\r\n  checksened.appendChild(checksened_stem);\r\n  checksened.appendChild(checksened_kick);\r\n  return checksened;\r\n}\r\n\n\n//# sourceURL=webpack://someLibName/./wpsrc/chat/chatbox/chatBox.js?");

/***/ }),

/***/ "./wpsrc/chat/chatbox/chtbxcontrol.js":
/*!********************************************!*\
  !*** ./wpsrc/chat/chatbox/chtbxcontrol.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"init\": () => (/* binding */ init),\n/* harmony export */   \"chbxcontrol\": () => (/* binding */ chbxcontrol)\n/* harmony export */ });\nlet executeAsync;\r\nlet CHATBOXSTATE;\r\nlet USERDATA;\r\nlet ACBchatboxStackdata;\r\nlet chatBox;\r\nlet teamviewtool;\r\nlet serverstreamcmnc;\r\nlet serverchatcmnc;\r\n\r\nconst init = function (myapp, _chatBox, teamview, svrCom) {\r\n  executeAsync = myapp.executeAsync;\r\n  CHATBOXSTATE = myapp.CHATBOXSTATE;\r\n  USERDATA = myapp.USERDATA;\r\n  ACBchatboxStackdata = myapp.ACTIVECHATBOX.chatboxStack.data;\r\n  chatBox = _chatBox;\r\n  teamviewtool = teamview.teamviewtool;\r\n  serverstreamcmnc = svrCom.serverstreamcmnc;\r\n  serverchatcmnc  = svrCom.serverchatcmnc;\r\n}\r\n\r\nconst chbxcontrol = {\r\n\r\n  showChatbox: function (chatboxID) {\r\n    new Promise(async function(resolve, reject) {\r\n      const chatbox = await(serverchatcmnc.getChatboxInfo(chatboxID));\r\n      resolve(chatbox);\r\n    }).then(async(chatbox)=>{\r\n      await chatBox.addChatbox(chatbox);\r\n      return chatbox;\r\n    }).then((chatbox)=>{\r\n      executeAsync(function() {\r\n        chatBox.loadChatboxInfo(chatbox);\r\n        executeAsync(async function() {\r\n          serverstreamcmnc.jointochatbox(chatboxID);\r\n          const lastconv = await(serverchatcmnc.getLastConversation(chatbox.chatboxid));\r\n          const conversationData = lastconv?await(serverchatcmnc.getconversationData(lastconv.conversationid)):null;\r\n          chatBox.initmessagebox(chatbox, lastconv, conversationData);\r\n          chbxcontrol.hightlight();\r\n        }, 100);\r\n      }, 200);\r\n    });\r\n  },\r\n\r\n  chtbxdestroyer: async function (idx) {\r\n    const item = ACBchatboxStackdata[idx];\r\n    item.chatbox.classList.remove(\"chatboxmaximize\");\r\n    item.chatbox.setAttribute('style', 'animation: fade 0.5s ease forwards !important');\r\n    new Promise(function(resolve, reject) {\r\n      setTimeout(()=>{\r\n        serverstreamcmnc.leaveoutchatbox(item.chatboxid);\r\n        item.chatbox.remove();\r\n        ACBchatboxStackdata.remove(item);\r\n        chbxcontrol.hightlight();\r\n        resolve();\r\n      }, 800);\r\n    });\r\n  },\r\n\r\n  disposechatbox: async function (chatboxid) {\r\n    const _chatboxid = parseInt(chatboxid, 10);\r\n    ACBchatboxStackdata.some(chtbxstkitem=> {\r\n      if (_chatboxid != chtbxstkitem.chatboxid) return;\r\n      chtbxstkitem.dispose = true;\r\n      return true;\r\n    });\r\n  },\r\n\r\n  closechatbox: async function () {\r\n    this.style.color = \"red\";\r\n    const _chatboxid = parseInt(this.getAttribute(\"chatboxid\"), 10);\r\n    ACBchatboxStackdata.some(chtbxstkitem=> {\r\n      if (_chatboxid != chtbxstkitem.chatboxid) return;\r\n      chtbxstkitem.dispose = true;\r\n      return true;\r\n    });\r\n  },\r\n\r\n  chatboxminimize: function(){\r\n    const chatboxid = parseInt(this.getAttribute(\"chatboxid\"));\r\n    const chatbox = document.getElementById( \"chatboxID\" + chatboxid);\r\n    const setupChatboxsate = item => {\r\n      if (chatboxid != item.chatboxid)return ;\r\n      switch (item.CHATBOXSTATE) {\r\n        case CHATBOXSTATE.MINIMIZE:\r\n        item.CHATBOXSTATE = CHATBOXSTATE.NORMAL;\r\n        chatbox.className = \"chatbox\";\r\n        return /*break s_ome*/true;\r\n        default:\r\n        item.CHATBOXSTATE = CHATBOXSTATE.MINIMIZE;\r\n        chatbox.className = \"chatboxminimize\";\r\n        return /*break s_ome*/true;\r\n      }\r\n    }\r\n    ACBchatboxStackdata.some(setupChatboxsate);\r\n  },\r\n\r\n  chatboxmaximize: function(){\r\n    const chatboxid = this.getAttribute(\"chatboxid\");\r\n    const chatbox = document.getElementById( \"chatboxID\" + chatboxid);\r\n    const setupChatboxsate = item => {\r\n      if (chatboxid != item.chatboxid) return ;\r\n      switch (item.CHATBOXSTATE) {\r\n        case CHATBOXSTATE.MAXIMIZE:\r\n        item.CHATBOXSTATE = CHATBOXSTATE.NORMAL;\r\n        chatbox.className = \"chatbox\";\r\n        chatbox.classList.remove(\"chatboxmaximize\");\r\n        return /*break s_ome*/true;\r\n        default:\r\n        item.CHATBOXSTATE = CHATBOXSTATE.MAXIMIZE;\r\n        chatbox.className = \"chatbox\";\r\n        chatbox.classList.add(\"chatboxmaximize\");\r\n        chatbox.style.height = \"\";\r\n        return /*break s_ome*/true;\r\n      }\r\n    }\r\n    ACBchatboxStackdata.some(setupChatboxsate);\r\n  },\r\n\r\n  showinfomessage: function(){\r\n    const messageinfo = document.getElementById(\"messageinfoID\" + this.getAttribute(\"unhideUsermindid\"));\r\n    switch (messageinfo.className) {\r\n      case \"hidemessageinfo\": messageinfo.className = \"messageinfo\"; break;\r\n      case \"messageinfo\": messageinfo.className = \"hidemessageinfo\"; break;\r\n    }\r\n  },\r\n\r\n  showinfochbxmember: function(){\r\n    switch (true) {\r\n      case this.classList.contains(\"memberusernamefull\"):\r\n      this.classList.remove(\"memberusernamefull\");\r\n      break;\r\n      default:\r\n      this.classList.add(\"memberusernamefull\");\r\n    }\r\n  },\r\n\r\n  teamviewshare: function(){\r\n    const teamviewwindow = document.getElementsByClassName(\"teamviewwindow\");\r\n    if (teamviewwindow.length>0) return;\r\n    const chatboxid = this.getAttribute(\"chatboxid\");\r\n    teamviewtool.teamviewshare(chatboxid, USERDATA.ID);\r\n  },\r\n\r\n  teamviewreceive: function(){\r\n    const teamviewwindow = document.getElementsByClassName(\"teamviewwindow\");\r\n    if (teamviewwindow.length>0) return;\r\n    const chatboxid = this.getAttribute(\"chatboxid\");\r\n    const userid = this.getAttribute(\"userid\");\r\n    teamviewtool.teamviewreceive(chatboxid, userid);\r\n  },\r\n\r\n  downloadmmf: function(){\r\n    const a = document.createElement('a');\r\n    a.style.display = 'none';\r\n    a.href = this.getAttribute(\"path\");\r\n    a.download = this.getAttribute(\"name\");\r\n    document.body.appendChild(a);\r\n    a.click();\r\n    window.URL.revokeObjectURL(this.getAttribute(\"path\"));\r\n  },\r\n\r\n  hightlight: function(){\r\n    const list = document.getElementsByClassName(\"chatlistitem\");\r\n    for (let item of list) {\r\n      item.classList.remove(\"chatlistitemSelected\");\r\n      item.classList.remove(\"chatlistitemwillSelect\");\r\n    }\r\n    for (var i = 0; i < ACBchatboxStackdata.length; i++) {\r\n      const selected = document.getElementById(\"chatlistitemID\" + ACBchatboxStackdata[i].chatboxid);\r\n      if (selected)selected.classList.add (\"chatlistitemSelected\");\r\n    }\r\n  },\r\n\r\n  setUserisscrollbox: function(chatboxid) {\r\n    // scroll is max position\r\n    const messagebox = document.getElementById(\"messageboxID\" + chatboxid);\r\n    if(!messagebox)return;\r\n    const d = messagebox.scrollHeight - messagebox.clientHeight;\r\n    const limit = window.scrollMaxY? Math.max (window.scrollMaxY, d):(d);\r\n    const setupScroll = item => {\r\n      if (chatboxid != item.chatboxid) return;\r\n      if (messagebox.scrollTop == limit) {\r\n        item.user_isscrollchatbox = false;\r\n        return;\r\n      }\r\n      item.user_isscrollchatbox = true;\r\n      return;\r\n    }\r\n    ACBchatboxStackdata.some(setupScroll);\r\n  },\r\n\r\n  getUserisscrollbox: function (chatboxid) {\r\n    const getisscrollbox = item => {// do for all chatbox\r\n      if (chatboxid != item.chatboxid) return;\r\n      return item.user_isscrollchatbox;\r\n    }\r\n    return ACBchatboxStackdata.some(getisscrollbox);\r\n  },\r\n\r\n  textboxAutogrow: function (element) {\r\n    element.style.height = \"20px\";\r\n    element.style.height = (element.scrollHeight-8)+\"px\";\r\n  },\r\n\r\n  chtbxautoscrolllast: function (chatboxid) {\r\n    const messagebox = document.getElementById(\"messageboxID\"+ chatboxid);\r\n    if(!messagebox) return;\r\n    const d = messagebox.scrollHeight - messagebox.clientHeight;\r\n    const limit = window.scrollMaxY? Math.max (window.scrollMaxY, d): (d);\r\n    messagebox.scrollTop = limit;\r\n    const setUser_isscrollchatbox = item => { if (chatboxid = item.chatboxid) { item.user_isscrollchatbox = false; return true; } }\r\n    ACBchatboxStackdata.some(setUser_isscrollchatbox);\r\n  },\r\n\r\n}\r\n\n\n//# sourceURL=webpack://someLibName/./wpsrc/chat/chatbox/chtbxcontrol.js?");

/***/ }),

/***/ "./wpsrc/chat/chatbox/chtbxtool.js":
/*!*****************************************!*\
  !*** ./wpsrc/chat/chatbox/chtbxtool.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"init\": () => (/* binding */ init),\n/* harmony export */   \"chtbxtool\": () => (/* binding */ chtbxtool)\n/* harmony export */ });\nconst dmt = __webpack_require__(/*! ../../app/domtl */ \"./wpsrc/app/domtl.js\");\r\nconst rcntContact = __webpack_require__(/*! ../recentContact */ \"./wpsrc/chat/recentContact.js\");\r\nconst filetransfer = __webpack_require__(/*! ../../filetransfer/filetransfer */ \"./wpsrc/filetransfer/filetransfer.js\");\r\n\r\nlet chtbx;\r\nlet contact;\r\nlet _chtSrvc;\r\nlet serverstreamcmnc;\r\nlet serverchatcmnc;\r\nlet TOKEN;\r\nlet serviceTool;\r\nlet chbxcontrol;\r\nlet ACBchatboxStack;\r\nlet ACBrecentchatbox;\r\nlet ACBchatboxStackdata;\r\nlet ACBrecentchatboxdata;\r\nlet CHATBOXSTATE;\r\nlet APPDATA;\r\nlet USERDATA;\r\nlet CONTACTMODE;\r\nlet sleep;\r\nlet getDateString;\r\n\r\nconst init = function (myapp, _chtbx, cbcntrl, _contact, srvcetool, service, token, svrCom) {\r\n\r\n  chtbx = _chtbx;\r\n  contact = _contact;\r\n  _chtSrvc = service._chatService;\r\n  serverstreamcmnc = svrCom.serverstreamcmnc;\r\n  serverchatcmnc = svrCom.serverchatcmnc;\r\n  TOKEN = token.TOKEN;\r\n  serviceTool = srvcetool.serviceTool;\r\n  chbxcontrol = cbcntrl.chbxcontrol;\r\n  ACBchatboxStack = myapp.ACTIVECHATBOX.chatboxStack;\r\n  ACBrecentchatbox = myapp.ACTIVECHATBOX.recentchatbox;\r\n  ACBchatboxStackdata = myapp.ACTIVECHATBOX.chatboxStack.data;\r\n  ACBrecentchatboxdata = myapp.ACTIVECHATBOX.recentchatbox.data;\r\n  CHATBOXSTATE = myapp.CHATBOXSTATE;\r\n  APPDATA = myapp.APP.DATA;\r\n  USERDATA = myapp.USERDATA;\r\n  CONTACTMODE = myapp.CONTACTMODE;\r\n  sleep = myapp.sleep;\r\n  getDateString = myapp.getDateString;\r\n}\r\n\r\nconst chtbxtool = {\r\n  // register chatbox;\r\n  // add stack chat chatbox\r\n  // add recent chatbox\r\n  // remove old chat box\r\n  // style animation add\r\n  chatboxregister: async function (chatbox, messagebox, chatboxid, type) {//add chatbox, save chatbox info here:\r\n    if(ACBchatboxStackdata.some(item => {if(chatboxid == item.chatboxid) return true; })) return;// no double\r\n    const lastconversation = await(serverchatcmnc.getLastConversation(chatboxid, \"undefined\"));\r\n    const conversation = (lastconversation&&serviceTool.is_liveconversation(lastconversation))?lastconversation:null;\r\n\r\n    //create chtbxstkdata item\r\n    const chtbxstkdata = {\r\n      initcomplete: false,\r\n      dispose: false,\r\n      chatboxid: chatboxid,\r\n      members: [],\r\n      type: type,\r\n      user_isscrollchatbox: false,\r\n      lastCountConversation: 0,\r\n      CHATBOXSTATE: CHATBOXSTATE.NORMAL,\r\n      sending_chatdata_cache: [],\r\n      receive_chatdata_cache: [],\r\n      receive_streamdata_cache:[],\r\n      cachelen: 10,\r\n      chatbox: chatbox,//dom\r\n      messagebox: messagebox,//dom\r\n      conversation: conversation,\r\n      MAKECONVERSATION: false,\r\n      NOMORE: false,\r\n      ADDFIRSTDONE: 0,\r\n      LOADMOREMESSAGE: false,\r\n      LOADMOREMESSAGEID: 0,\r\n      LOADMOREMESSAGEDONEID: 0,\r\n    };\r\n\r\n    ACBchatboxStackdata.push(chtbxstkdata);\r\n\r\n    let anim = \"expandwh 0.5s ease both\";\r\n    if (ACBchatboxStackdata.length> ACBchatboxStack.maxWindows) {\r\n      anim = \"expandwh 1.0s ease 0.5s both\";// wait for last chatbox close\r\n    }\r\n\r\n    // add chat box to brownser\r\n    new Promise(function(resolve, reject) {\r\n      chatbox.style.animation = anim;\r\n      document.getElementById(\"chatboxbeanID\").append(chatbox);\r\n      setTimeout(()=>{\r\n        chatbox.style.animation = \"\";\r\n        resolve();\r\n      }, 1500);\r\n    });\r\n\r\n    // remove old recent chatbox\r\n    if(ACBrecentchatboxdata.some(item => { if (chatboxid == item.chatboxid) return true; }))return;/*no double*/\r\n    const rctcbx_dtlen = ACBrecentchatboxdata.length;\r\n    if ( rctcbx_dtlen >= ACBrecentchatbox.maxRecent) {\r\n      const idx = ACBrecentchatboxdata.length - ACBrecentchatbox.maxRecent;\r\n      for (var i = 0; i < idx; i++) {\r\n        const recentitem = document.getElementById(\"recentchatboxID\" + ACBrecentchatboxdata[i].chatboxid);// remove now, you will lost it\r\n        if (recentitem) recentitem.remove();\r\n        ACBrecentchatboxdata.remove(ACBrecentchatboxdata[i]);\r\n      }\r\n    }\r\n\r\n    ACBrecentchatboxdata.push({chatboxid: chatboxid, totalnoticecount: 0});\r\n    // save cookie and show recent icon\r\n    rcntContact.saverecentcontacttocookie(ACBrecentchatbox);\r\n    rcntContact.drawrecentchatbox(ACBrecentchatbox);\r\n  },\r\n\r\n  fillconversation: async function (chtbxstkitem, converstationinfo, conversationData, messagebox){\r\n    // fill conversation data\r\n    //(when init (chatapp.js), when scroll top (servicetaskbrowser.js))\r\n\r\n    // check type of message\r\n    for (var item of conversationData) {\r\n      switch (item.type) {\r\n        case \"mmf\":\r\n        var messageitem = this.createmultimediafileitem(item, chtbxstkitem.chatboxid, false);\r\n        messagebox.insertBefore(messageitem, converstationinfo.nextSibling, false);\r\n        break;\r\n        case \"msg\": //(mmf)\r\n        var messageitem = this.createmessageitem(item, chtbxstkitem.chatboxid, false);\r\n        messagebox.insertBefore(messageitem, converstationinfo.nextSibling);\r\n        break;\r\n      }\r\n\r\n      // limit message count by view\r\n      if (chtbxstkitem.ADDFIRSTDONE> (window.innerHeight/40 /*single line height*/)){await sleep(200);}\r\n      chtbxstkitem.ADDFIRSTDONE += 1;\r\n      if (item.unhideuserid == USERDATA.ID) continue;\r\n\r\n      // load old data from server to cache\r\n      const receivchat_data = {\r\n        unhideUsermindid: item.unhideUsermindid,\r\n        unhideuserid: item.unhideuserid,\r\n        datetimeUnhide: item.datetimeUnhide,\r\n        messageData: item.messageData,\r\n        datetimetell: item.datetimetell,\r\n        readerid: item.readerid,\r\n        datetimeread: item.datetimeread,\r\n        sended: false,\r\n        success: false,\r\n        sendingcount: 0,\r\n        viewinbrowser: true, // loaded to chatbox\r\n      };\r\n      chtbxstkitem.receive_chatdata_cache.push(receivchat_data);\r\n    };\r\n\r\n    // set chatbox inited\r\n    chtbxstkitem.initcomplete = true;\r\n    if (conversationData[0])\r\n    return conversationData[0].unhideUsermindid;\r\n  },\r\n\r\n\r\n  createmessageitem: function (item, chatboxid, iscurrconversatt) {\r\n    const messageitem = dmt.domtool.creatediv(\"messageitem\", \"messageitemID\" + item.unhideUsermindid);\r\n    messageitem.setAttribute(\"unhideUsermindid\", item.unhideUsermindid);\r\n    messageitem.setAttribute(\"chatboxid\", chatboxid);\r\n    messageitem.setAttribute(\"iscurrconversatt\", iscurrconversatt);// for sort\r\n    const messageitem_icon = dmt.domtool.creatediv(\"messageitem_icon\");\r\n    const _chatboxmessagae = dmt.domtool.creatediv(USERDATA.ID == item.unhideuserid?\"userchatboxmessagae\":\"guestchatboxmessagae\");\r\n    const hidemessageinfo = dmt.domtool.creatediv(\"hidemessageinfo\", \"messageinfoID\" + item.unhideUsermindid);\r\n    hidemessageinfo.innerHTML = getDateString (new Date (item.datetimeUnhide));\r\n    const messgetextbean = dmt.domtool.creatediv(\"messgetextbean\");\r\n    const messgetext = dmt.domtool.creatediv(\"messgetext\", \"message_dataID\" + item.unhideUsermindid);\r\n    // switch type of message\r\n    switch (USERDATA.ID) {\r\n      case item.unhideuserid: messgetext.classList.add(\"msguser\"); break;\r\n      default: messgetext.classList.add(\"msgguest\");\r\n    }\r\n    messgetext.setAttribute(\"unhideUsermindid\", item.unhideUsermindid);\r\n    messgetext.addEventListener(\"click\", chbxcontrol.showinfomessage);\r\n    messgetext.innerHTML = item.messageData + \"-\" + item.unhideUsermindid;\r\n\r\n    messgetextbean.appendChild (messgetext);\r\n    _chatboxmessagae.appendChild (hidemessageinfo);\r\n    _chatboxmessagae.appendChild (messgetextbean);\r\n    switch (USERDATA.ID) {\r\n      case item.unhideuserid:\r\n      const seenlistitem = chtbxtool.createseenlist(item.unhideUsermindid);\r\n      messgetextbean.appendChild(seenlistitem);\r\n      /** */ break; // hide user icon\r\n      default: messageitem.appendChild(messageitem_icon);\r\n    }\r\n    messageitem.appendChild (_chatboxmessagae);\r\n    messageitem.style.animation = \"opac 0.2s ease-in-out\";\r\n    return messageitem;\r\n  },\r\n\r\n  createmultimediafileitem: function (item /*multimedia file*/, chatboxid, iscurrconversatt) {\r\n    // create multimedia messageitem to fillconversation\r\n    //DECLARE variable\r\n    const unhideUsermindid = item.unhideUsermindid;\r\n    const unhideuserid = item.unhideuserid;\r\n    const datetimeUnhide = item.datetimeUnhide;\r\n    const name = item.messageData.split(\";\")[0];\r\n    const path = item.messageData.split(\";\")[1];\r\n    const datetimetell = item.datetimetell;\r\n    const readerid = item.readerid;\r\n    const datetimeread = item.datetimeread;\r\n\r\n    const messageitem = dmt.domtool.creatediv(\"messageitem\", \"messageitemID\" + unhideUsermindid);\r\n    messageitem.setAttribute(\"unhideUsermindid\", unhideUsermindid);\r\n    messageitem.setAttribute(\"chatboxid\", chatboxid);\r\n    messageitem.setAttribute(\"iscurrconversatt\", iscurrconversatt);// for sort\r\n    const messageitem_icon = dmt.domtool.creatediv(\"messageitem_icon\");\r\n    const mmfitembean = dmt.domtool.creatediv(\"mmfitembean\");\r\n    const mmfbean = dmt.domtool.creatediv(\"mmfbean\");\r\n    const mmfitem = dmt.domtool.creatediv(\"mmfitem\");\r\n    const mmfitemicon = dmt.domtool.creatediv(\"mmfitemicon\");\r\n    const mmfiteminfo = dmt.domtool.creatediv(\"mmfiteminfo\");\r\n    const mmfitemname = dmt.domtool.creatediv(\"mmfitemname\");\r\n    mmfitemname.classList.add(\"mmfinfo\");\r\n    mmfitemname.innerHTML = name;\r\n    const mmfitemsendeddate = dmt.domtool.creatediv(\"mmfitemsendeddate\");\r\n    mmfitemsendeddate.classList.add(\"mmfinfo\");\r\n    mmfitemsendeddate.innerHTML = \"sended time: \" + datetimeUnhide;\r\n    const download = dmt.domtool.creatediv(\"download\");\r\n    download.classList.add(\"mmfinfo\");\r\n    download.setAttribute(\"path\", path);\r\n    download.setAttribute(\"name\", name);\r\n    download.innerHTML = \"download\";\r\n    download.addEventListener(\"click\",chbxcontrol.downloadmmf);\r\n    mmfiteminfo.appendChild(mmfitemname);\r\n    mmfiteminfo.appendChild(mmfitemsendeddate);\r\n    mmfiteminfo.appendChild(download);\r\n    mmfitem.appendChild(mmfitemicon);\r\n    mmfitem.appendChild(mmfiteminfo);\r\n    mmfbean.appendChild(mmfitem);\r\n    mmfitembean.appendChild(mmfbean);\r\n    switch (USERDATA.ID) {\r\n      case unhideuserid: mmfitembean.classList.add(\"mmfitembeanuser\"); break;\r\n      default: messageitem.appendChild (messageitem_icon);\r\n    }\r\n    messageitem.appendChild (mmfitembean);\r\n    messageitem.style.animation = \"opac 0.2s ease-in-out\";\r\n    return messageitem;\r\n  },\r\n\r\n  creatermvmembutton: function (chatboxid, memberid) {\r\n    const removemember = dmt.domtool.creatediv(\"removemember\", \"removememberitemID\"+chatboxid+\"-\"+memberid);\r\n    removemember.addEventListener('click', async function() {\r\n      const _chatboxid = this.parentNode.getAttribute(\"chatboxid\");\r\n      const _memberid = parseInt(this.parentNode.getAttribute(\"userid\"));\r\n      if(memberid==USERDATA.ID) return;\r\n      const rs = await serverchatcmnc.removechatboxMember(_chatboxid, _memberid);\r\n      _chtSrvc.userhaveaAction(true);\r\n      if(rs<0) return;\r\n    });\r\n    removemember.innerHTML = \"&times;\";\r\n    return removemember;\r\n  },\r\n\r\n  createmberinvteitem: function (chatboxid) {\r\n    const memberitem = dmt.domtool.creatediv(\"memberitem\");\r\n    memberitem.setAttribute(\"chatboxid\", chatboxid);\r\n    const memberinvite = dmt.domtool.creatediv(\"memberinvite\", \"memberinviteID\" + chatboxid);\r\n    memberinvite.innerHTML = \"invite friend\";\r\n    memberinvite.addEventListener('click', function () {\r\n      const chatboxid = parseInt(this.parentNode.getAttribute(\"chatboxid\"));\r\n      // callback init contact to get list contact checked\r\n      contact.initContact(CONTACTMODE.CHECKER, listFriend => { //callback\r\n        APPDATA.chatboxlist.some( item => {\r\n          if(item.chatboxid!=chatboxid) return ;\r\n          listFriend.forEach(async userid => {\r\n            const getmember = mem =>{ if(mem.userid==userid)return true; }\r\n            const ismem = (item.members||[]).some(getmember);\r\n            if(!ismem) {await serverchatcmnc.sendgroupRequest(chatboxid, userid); console.log(userid);}\r\n          });\r\n          return true;\r\n        });\r\n      });\r\n      _chtSrvc.userhaveaAction(true);\r\n    });\r\n    memberitem.appendChild(memberinvite);\r\n    return memberitem;\r\n  },\r\n\r\n  createdissolutionitem: function (chatboxid) {\r\n    const memberitem = dmt.domtool.creatediv(\"memberitem\");\r\n    memberitem.setAttribute(\"chatboxid\", chatboxid);\r\n    const dissolution = dmt.domtool.creatediv(\"dissolution\", \"dissolutionID\" + chatboxid);\r\n    dissolution.innerHTML = \"dissolution\";\r\n    dissolution.addEventListener('click', async function () {\r\n      const chatboxid = this.parentNode.getAttribute(\"chatboxid\");\r\n      chbxcontrol.closechatbox(chatboxid);\r\n      await serverchatcmnc.dissolateGroup(chatboxid);\r\n      _chtSrvc.userhaveaAction(true);\r\n    });\r\n    memberitem.appendChild(dissolution);\r\n    return memberitem;\r\n  },\r\n\r\n  createleaveitem: function (chatboxid) {\r\n    const leaveitem = dmt.domtool.creatediv(\"memberitem\");\r\n    leaveitem.setAttribute(\"chatboxid\", chatboxid);\r\n    const leave = dmt.domtool.creatediv(\"leave\", \"leaveID\" + chatboxid);\r\n    leave.innerHTML = \"leave\";\r\n    leave.addEventListener('click', async function () {\r\n      const chatboxid = this.parentNode.getAttribute(\"chatboxid\");\r\n      chbxcontrol.disposechatbox(chatboxid);\r\n      await serverchatcmnc.leaveChatbox(chatboxid);\r\n      _chtSrvc.userhaveaAction(true);\r\n    });\r\n    leaveitem.appendChild(leave);\r\n    return leaveitem;\r\n  },\r\n\r\n  createlivestreamitem: function (chatboxid) {\r\n      const livestreamitem = dmt.domtool.creatediv(\"memberitem\");\r\n      livestreamitem.setAttribute(\"chatboxid\", chatboxid);\r\n      const livestream = dmt.domtool.creatediv(\"livestream\", \"livestreamID\" + chatboxid);\r\n      livestream.innerHTML = \"livestream\";\r\n      livestream.setAttribute(\"chatboxid\", chatboxid);\r\n      livestream.addEventListener('click', chbxcontrol.teamviewshare);\r\n      livestreamitem.appendChild(livestream);\r\n      return livestreamitem;\r\n    },\r\n\r\n  creatememberitem: function (chatboxid, userid, username, lasttimelogin) {\r\n    const memberitem = dmt.domtool.creatediv(\"memberitem\", \"memberitemID\" +chatboxid+\"-\"+ userid);\r\n    memberitem.setAttribute(\"chatboxid\", chatboxid);\r\n    memberitem.setAttribute(\"userid\", userid);\r\n    const onlinestatus = dmt.domtool.creatediv(\"onlinestatus\", \"chatboxUseronlinestatusID\"+ chatboxid+\"-\"+ userid);\r\n    onlinestatus.style.backgroundColor = (serviceTool.is_Stillonline(lasttimelogin)?\"#06FF0B\":\"#cc0000\");\r\n    const icon = dmt.domtool.creatediv(\"icon\");\r\n    const memberusername = dmt.domtool.creatediv(\"memberusername\", \"memberusernameID\" + chatboxid +\"-\"+ userid);\r\n    memberusername.innerHTML = username;\r\n    memberusername.addEventListener('click', chbxcontrol.showinfochbxmember);\r\n    const memberteamviewbean = dmt.domtool.creatediv(\"memberteamviewbean\");\r\n    const memberteamview = dmt.domtool.creatediv(\"memberteamview\", \"memberteamviewID\" + chatboxid +\"-\"+ userid);\r\n    memberteamview.setAttribute(\"chatboxid\",chatboxid);\r\n    memberteamview.setAttribute(\"userid\", userid);\r\n    memberteamview.addEventListener('click', chbxcontrol.teamviewreceive);\r\n    memberteamview.classList.add(\"hidememberteamview\");\r\n    memberteamviewbean.appendChild(memberteamview);\r\n    memberitem.appendChild(onlinestatus);\r\n    memberitem.appendChild(icon);\r\n    memberitem.appendChild(memberusername);\r\n    switch (userid) {\r\n      case (USERDATA.ID):\r\n      break;\r\n      default:\r\n      memberitem.appendChild(memberteamviewbean);\r\n    }\r\n    return memberitem;\r\n  },\r\n\r\n\r\n  createfiletransfer: function (chatboxid, fileuploadid) {\r\n    const messageitem = dmt.domtool.creatediv(\"messageitem\");\r\n    messageitem.setAttribute(\"unhideUsermindid\", \"S\" + fileuploadid);// forresort\r\n    messageitem.setAttribute(\"chatboxid\", chatboxid);\r\n    messageitem.setAttribute(\"iscurrconversatt\", true);// for sort\r\n    const filetransferbean = dmt.domtool.creatediv(\"filetransferbean\");\r\n    const preview = dmt.domtool.creatediv(\"preview\");\r\n    const previewcontent = dmt.domtool.createimg(\"previewcontent\", \"previewcontentID\"+fileuploadid);\r\n    const filetransfer = dmt.domtool.creatediv(\"filetransfer\");\r\n    const filetransfericonbox = dmt.domtool.creatediv(\"filetransfericonbox\");\r\n    const filetransfericon = dmt.domtool.creatediv(\"filetransfericon\");\r\n    const filetransferstatusbar = dmt.domtool.creatediv(\"filetransferstatusbar\", \"filetransferstatusbarID\" + fileuploadid);\r\n    const filetransferprogressbar = dmt.domtool.creatediv(\"filetransferprogressbar\", \"filetransferprogressbarID\" + fileuploadid);\r\n    const filetranspercent = dmt.domtool.creatediv(\"filetranspercent\", \"filetranspercentID\" + fileuploadid);\r\n    filetranspercent.innerHTML = \"0%\";\r\n    filetranspercent.classList.add(\"filetransferbutton\");\r\n    const filetransfercancel = dmt.domtool.creatediv(\"filetransfercancel\", \"filetransfercancelID\" + fileuploadid);\r\n    filetransfercancel.classList.add(\"filetransferbutton\");\r\n    filetransfercancel.setAttribute(\"iscancel\", false);\r\n\r\n    filetransfercancel.innerHTML = \"cancel\";\r\n    preview.appendChild(previewcontent);\r\n\r\n    filetransferstatusbar.appendChild(filetransferprogressbar);\r\n    filetransfericonbox.appendChild(filetransfericon);\r\n    filetransfer.appendChild(filetransfericonbox);\r\n    filetransfer.appendChild(filetransferstatusbar);\r\n    filetransfer.appendChild(filetranspercent);\r\n    filetransfer.appendChild(filetransfercancel);\r\n    filetransferbean.appendChild(filetransfer);\r\n    filetransferbean.appendChild(preview);\r\n    messageitem.appendChild(filetransferbean);\r\n    messageitem.style.animation = \"opac 0.2s ease-in-out\";\r\n    return messageitem;\r\n  },\r\n\r\n  createseenlist: function(unhideUsermindid) {\r\n    const seenlistitem = dmt.domtool.creatediv(\"seenlistitem\", \"seenlistitemID\" + unhideUsermindid);\r\n    seenlistitem.setAttribute(\"unhideUsermindid\",unhideUsermindid);\r\n    const seenlistitembean = dmt.domtool.creatediv(\"seenlistitembean\");\r\n    seenlistitem.appendChild(seenlistitembean);\r\n    return seenlistitem;\r\n  },\r\n\r\n  addseenitem: function(seenlistitem, userid, username, iconpath) {\r\n    const unhideUsermindid = seenlistitem.getAttribute(\"unhideUsermindid\");\r\n    const seenitem = dmt.domtool.creatediv(\"seenitem\", \"seenitemID\" + unhideUsermindid +\"-\"+ userid);\r\n    const seenicon = dmt.domtool.creatediv(\"seenicon\");\r\n    const seentooltipdesc = dmt.domtool.creatediv(\"seentooltipdesc\", \"seentooltipdescID\" + unhideUsermindid +\"-\"+ userid);\r\n    seentooltipdesc.innerHTML = username;\r\n    seenitem.appendChild(seenicon);\r\n    seenitem.appendChild(seentooltipdesc);\r\n    seenlistitem.firstChild.appendChild(seenitem);\r\n  },\r\n\r\n  updateseenitem: function(seenlistitem, userid, username, iconpath) {\r\n    const unhideUsermindid = seenlistitem.getAttribute(\"unhideUsermindid\");\r\n    const seenitem = document.getElementById(\"seenitemID\"+ unhideUsermindid +\"-\"+ userid);\r\n    const seenicon = dmt.domtool.creatediv(\"seenicon\");\r\n    const seentooltipdesc = document.getElementById(\"seentooltipdescID\"+ unhideUsermindid +\"-\"+ userid);\r\n    seentooltipdesc.innerHTML = username;\r\n  },\r\n\r\n  enablechatboxEditcbName: function () {\r\n    _chtSrvc.userhaveaAction();\r\n    this.contentEditable = \"true\";\r\n    this.focus();\r\n    switch (this.innerHTML) {\r\n      case this.getAttribute(\"realchatboxname\"):\r\n      this.innerHTML =\"\";\r\n      break;\r\n    }\r\n  },\r\n\r\n  chatboxNameEditor: async function (event) {\r\n    if(event.keyCode != 13) {\r\n      if(this.innerHTML.length > 300) {\r\n        event.preventDefault(); // Ensure it is only this code that runs\r\n      }\r\n      return;\r\n    }\r\n    event.preventDefault(); // Ensure it is only this code that runs\r\n    switch (this.innerHTML) {\r\n      case \"\":\r\n      this.innerHTML = this.getAttribute(\"realchatboxname\")\r\n      this.contentEditable = \"false\";\r\n      return;\r\n      default:\r\n      const chatboxid = this.getAttribute(\"chatboxid\");\r\n      const rs = await (serverchatcmnc.updatememberChatboxname(chatboxid, this.innerHTML));\r\n      _chtSrvc.userhaveaAction(true);\r\n      this.innerHTML = rs.userchatboxname;\r\n      this.contentEditable = \"false\";\r\n    }\r\n  },\r\n\r\n  autogrow:function () {\r\n    chbxcontrol.textboxAutogrow(this);\r\n  },\r\n\r\n  typingboxFilterandAction: function(event) {\r\n    switch (true) {\r\n      case (event.keyCode === 13):\r\n      event.preventDefault(); // Ensure it is only this code that runs\r\n      const chatboxid = this.getAttribute(\"chatboxid\");\r\n      chtbx.sendMessage(chatboxid);\r\n      _chtSrvc.userhaveaAction();\r\n      break;\r\n      case (this.value.length > 512):\r\n      event.preventDefault(); // Ensure it is only this code that runs\r\n      break;\r\n    }\r\n  },\r\n\r\n  userscrollchecker: function(event) {\r\n    const chatboxid = this.getAttribute(\"chatboxid\");\r\n    const messagebox = document.getElementById(\"messageboxID\" + chatboxid);\r\n    if (messagebox.scrollTop == 0) {\r\n      _chtSrvc.userhaveaAction();\r\n    }\r\n    chbxcontrol.setUserisscrollbox(messagebox.getAttribute(\"chatboxid\"));\r\n  },\r\n\r\n  sendmsgAction: function() {\r\n    const chatboxid = this.getAttribute(\"chatboxid\");\r\n    chtbx.sendMessage(chatboxid);\r\n    _chtSrvc.userhaveaAction();// update readed\r\n    console.log(\"userhaveaAction\");\r\n  },\r\n\r\n  handleFiles: async function() {\r\n    _chtSrvc.userhaveaAction();\r\n    const chatboxid = this.getAttribute(\"chatboxid\");\r\n    const messagebox = document.getElementById(\"messageboxID\"+ chatboxid);\r\n    let conversationid = 0;\r\n    for (var item of ACBchatboxStackdata) {\r\n      if (item.chatboxid != chatboxid) continue;\r\n      if (item.conversation) {\r\n        conversationid = item.conversation.conversationid;\r\n        break;\r\n      };\r\n      item.MAKECONVERSATION = true;\r\n      while (!item.conversation) {\r\n        await sleep(100);\r\n      }\r\n      conversationid = item.conversation.conversationid;\r\n      break;\r\n    };\r\n    const filetoupload = this.files[0]; /* now you can work with the file list */\r\n    if (!filetoupload){console.log(\"has no file\"); return};\r\n\r\n    const fileuploadid = ((await serverstreamcmnc.requestfileuploadidid(chatboxid))||{id:-1}).id;\r\n    const ftf = chtbxtool.createfiletransfer(chatboxid, fileuploadid);\r\n    messagebox.appendChild(ftf);\r\n\r\n    const loader = {file: new Promise(function(resolve, reject) {resolve(filetoupload);}), conversationid: conversationid, uploadTotal: 0, uploaded: 0, fileid:fileuploadid}\r\n    var updloader = new filetransfer.MyUploadAdapter(loader, TOKEN);\r\n\r\n    const up = await updloader.upload();\r\n\r\n    const filetransfercancel = document.getElementById(\"filetransfercancelID\" + fileuploadid);\r\n    filetransfercancel.addEventListener('click', function() {\r\n      const iscancel = this.getAttribute(\"iscancel\");\r\n      switch (iscancel) {\r\n        case \"true\": filetransfercancel.setAttribute(\"iscancel\", false); break;\r\n        case \"false\": updloader.abort(); filetransfercancel.setAttribute(\"iscancel\", true); break;\r\n      }\r\n    });\r\n    const filetransferprogressbar = document.getElementById(\"filetransferprogressbarID\" + fileuploadid);\r\n    const filetranspercent = document.getElementById( \"filetranspercentID\" + fileuploadid);\r\n\r\n    while(filetransfercancel.getAttribute(\"iscancel\").localeCompare(\"true\")!=0){\r\n      const perc = ((loader.uploaded/loader.uploadTotal)*100);\r\n      filetransferprogressbar.style.width = (perc+ \"%\");\r\n      filetranspercent.innerHTML = (perc+ \"%\");\r\n      if (perc>=100) break;\r\n      await new Promise(resolve => {setTimeout(resolve, 150)});\r\n      console.log(\"while\");\r\n    }\r\n\r\n    // ftf.style.animation = \"fade 0.5s ease both\";\r\n\r\n    // ftf.remove();\r\n    // }, 100);\r\n    this.value = \"\";\r\n    console.log(\"finish\");\r\n    chbxcontrol.chtbxautoscrolllast(chatboxid);\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack://someLibName/./wpsrc/chat/chatbox/chtbxtool.js?");

/***/ }),

/***/ "./wpsrc/chat/recentContact.js":
/*!*************************************!*\
  !*** ./wpsrc/chat/recentContact.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"init\": () => (/* binding */ init),\n/* harmony export */   \"saverecentcontacttocookie\": () => (/* binding */ saverecentcontacttocookie),\n/* harmony export */   \"drawrecentchatbox\": () => (/* binding */ drawrecentchatbox)\n/* harmony export */ });\nconst dmt = __webpack_require__(/*! ../app/domtl */ \"./wpsrc/app/domtl.js\");\r\n\r\nlet serverchatcmnc;\r\nlet _chatService;\r\nlet chbxcontrol;\r\nlet ACBrecentchatboxdata;\r\nlet ACBrecentchatbox;\r\nlet APPDATA;\r\nlet USERDATA;\r\nlet CHATROOMTYPE;\r\n\r\nconst init = function (myapp, cbxcntrl, service, svrCom) {\r\n  serverchatcmnc = svrCom.serverchatcmnc;\r\n  _chatService = service._chatService;\r\n  chbxcontrol = cbxcntrl.chbxcontrol;\r\n  ACBrecentchatboxdata = myapp.ACTIVECHATBOX.recentchatbox.data;\r\n  ACBrecentchatbox = myapp.ACTIVECHATBOX.recentchatbox;\r\n  APPDATA = myapp.APP.DATA;\r\n  USERDATA = myapp.USERDATA;\r\n  CHATROOMTYPE = myapp.CHATROOMTYPE;\r\n  initRecentcontact();\r\n}\r\n\r\nfunction initRecentcontact(){\r\n  const recentcontactcookie = getrecentcontacttocookie();\r\n  // check user stay in converstation\r\n  for (const item of (recentcontactcookie||\"\").split(\"-\")) {\r\n    const recentdata = {chatboxid: parseInt(item), totalnoticecount: 0};\r\n    ACBrecentchatboxdata.push(recentdata);\r\n  }\r\n  drawrecentchatbox(ACBrecentchatbox);\r\n}\r\n\r\nfunction getrecentcontacttocookie(){\r\n  for (var item of document.cookie.split(\";\")) {\r\n    if(item.indexOf(\"recentcontact\")>= 0)\r\n    return item.split(\"=\")[1];\r\n  }\r\n}\r\n\r\nfunction saverecentcontacttocookie(recentchatbox){\r\n  var recentcontact = \"\";\r\n  const makeCookiedata = (item, i) => { if(item.chatboxid) { recentcontact += (item.chatboxid +  ((i == recentchatbox.data.length-1)?\"\":\"-\"));}}\r\n  recentchatbox.data.some(makeCookiedata);\r\n  document.cookie = \"recentcontact=\"+recentcontact;//save\r\n}\r\n\r\nasync function drawrecentchatbox(recentdata){\r\n  const body = document.getElementById(\"bodyID\");\r\n  for (let item of document.getElementsByClassName(\"recentchatbox\")) { item.remove(); }\r\n  let i = 0;\r\n  for (var rcntchtbx of recentdata.data) {\r\n    const id = rcntchtbx.chatboxid;\r\n    const chatbox = await(serverchatcmnc.getChatboxInfo(id));\r\n    if(!chatbox) continue;\r\n    if(!chatbox.chatboxid) {continue};\r\n    (document.getElementById(\"recentchatboxID\" + id)||[]).remove();\r\n    // continue;\r\n    const recentchatbox = dmt.domtool.creatediv(\"recentchatbox\", \"recentchatboxID\" + id);\r\n    recentchatbox.setAttribute(\"chatboxid\", id);\r\n    recentchatbox.addEventListener(\"click\",async function() {\r\n      _chatService.userhaveaAction();\r\n      chbxcontrol.showChatbox(this.getAttribute(\"chatboxid\"));\r\n    });\r\n    recentchatbox.addEventListener(\"mousemove\",function() {\r\n      const thisid = this.getAttribute(\"chatboxid\");\r\n      const recentchatboxlabel = document.getElementById(\"recentchatboxlabelID\"+thisid);\r\n      recentchatboxlabel.className = \"recentchatboxlabel\";\r\n    });\r\n\r\n    recentchatbox.addEventListener(\"mouseout\",function() {\r\n      const thisid = this.getAttribute(\"chatboxid\");\r\n      const recentchatboxlabel = document.getElementById(\"recentchatboxlabelID\"+thisid);\r\n      recentchatboxlabel.className = \"hiderecentchatboxlabel\";\r\n    });\r\n    recentchatbox.style.right = (i * 50+3)+\"px\";\r\n    recentchatbox.style.top = 3+\"px\";\r\n\r\n    const recentchatboxlabel = dmt.domtool.creatediv(\"hiderecentchatboxlabel\", \"recentchatboxlabelID\" + id);\r\n    const pointer = dmt.domtool.creatediv(\"pointer\");\r\n    const recentchatboxname = dmt.domtool.creatediv(\"recentchatboxname\", \"recentchatboxnameID\" + id);\r\n    recentchatboxname.innerHTML = chatbox.chatboxName;\r\n    const onlinestatus = dmt.domtool.creatediv(\"onlinestatus\", \"recentonlinestatusID\" + id);\r\n    var online = false;\r\n    const setmemberol = item => {\r\n      if (item.chatboxid==id) {\r\n        (item.members||[]).some(item_ => {\r\n          if (item_.userid!= USERDATA.ID && item_.lastdatetimelogin)\r\n          if(is_Stillonline(item_.lastdatetimelogin)){online = true; return true;}\r\n        });\r\n      }\r\n      return true;\r\n    }\r\n    APPDATA.chatboxlist.some(setmemberol);\r\n\r\n    onlinestatus.style.backgroundColor = (online?\"#06FF0B\":\"#cc0000\");\r\n    const recentchatboxicon = dmt.domtool.creatediv(\"recentchatboxicon\");\r\n    switch (chatbox.type) {\r\n      case CHATROOMTYPE.TYPEGROUP:\r\n      const table = document.createElement(\"table\");\r\n      table.cellSpacing = \"1px\";\r\n      table.cellPadding = \"0\";\r\n      const tbody = document.createElement(\"tbody\");\r\n      const tr1 = document.createElement(\"tr\");\r\n      const td1 = document.createElement(\"td\");\r\n      const td2 = document.createElement(\"td\");\r\n      const tr2 = document.createElement(\"tr\");\r\n      const td3 = document.createElement(\"td\");\r\n      const td4 = document.createElement(\"td\");\r\n      const recentmembericon1 = dmt.domtool.creatediv(\"recentmembericon\");\r\n      const recentmembericon2 = dmt.domtool.creatediv(\"recentmembericon\");\r\n      const recentmembericon3 = dmt.domtool.creatediv(\"recentmembericon\");\r\n      const recentmembericon4 = dmt.domtool.creatediv(\"recentmembericon\");\r\n      td1.appendChild(recentmembericon1);\r\n      td2.appendChild(recentmembericon2);\r\n      td3.appendChild(recentmembericon3);\r\n      td4.appendChild(recentmembericon4);\r\n      tr1.appendChild(td1);\r\n      tr1.appendChild(td2);\r\n      tr2.appendChild(td3);\r\n      tr2.appendChild(td4);\r\n      tbody.appendChild(tr1);\r\n      tbody.appendChild(tr2);\r\n      table.appendChild(tbody);\r\n      recentchatboxicon.appendChild(table);\r\n      break;\r\n      case CHATROOMTYPE.TYPEFRIEND:\r\n      const recentcontacticon = dmt.domtool.creatediv(\"recentcontacticon\");\r\n      recentchatboxicon.appendChild(recentcontacticon);\r\n      break;\r\n    }\r\n    const noticebean = dmt.domtool.creatediv(\"noticebean\");\r\n\r\n    const notice =  dmt.domtool.creatediv(\"recentnotice\", \"recentnoticeID\" +  id);\r\n    notice.classList.add(\"hidenotice\");\r\n    const noticevalue = dmt.domtool.creatediv(\"noticevalue\", \"recentnoticevalueID\" + id);\r\n    noticevalue.innerHTML = \"0\";\r\n\r\n    const closebean = dmt.domtool.creatediv(\"closebean\");\r\n    const close = dmt.domtool.creatediv(\"close\");\r\n    const closeicon = dmt.domtool.creatediv(\"closeicon\", \"closeiconID\" + id);\r\n    closeicon.classList.add(\"hidecloseicon\");\r\n    closeicon.innerHTML = \"&times;\";\r\n    closeicon.addEventListener('click', () =>{\r\n      // remove here\r\n    });\r\n    close.appendChild(closeicon);\r\n    closebean.appendChild(close);\r\n\r\n    notice.appendChild(noticevalue);\r\n    noticebean.appendChild(notice);\r\n    recentchatbox.appendChild(noticebean);\r\n    recentchatbox.appendChild(onlinestatus);\r\n    recentchatbox.appendChild(recentchatboxicon);\r\n    recentchatboxlabel.appendChild(pointer);\r\n    recentchatboxlabel.appendChild(recentchatboxname);\r\n    recentchatbox.appendChild(recentchatboxlabel);\r\n    // recentchatbox.appendChild(closebean);\r\n    body.appendChild(recentchatbox);\r\n    i++;\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack://someLibName/./wpsrc/chat/recentContact.js?");

/***/ }),

/***/ "./wpsrc/contact/contact.js":
/*!**********************************!*\
  !*** ./wpsrc/contact/contact.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"init\": () => (/* binding */ init),\n/* harmony export */   \"initContact\": () => (/* binding */ initContact)\n/* harmony export */ });\nconst dmt = __webpack_require__(/*! ../app/domtl */ \"./wpsrc/app/domtl.js\");\r\n\r\n\r\nlet CONTACTMODE;\r\nlet ACTIVECHATBOX;\r\nlet serverchatcmnc;\r\nlet _chatService;\r\n\r\nconst init = function (myapp,  service, svrCom) {\r\n\r\n  CONTACTMODE = myapp.CONTACTMODE;\r\n  ACTIVECHATBOX = myapp.ACTIVECHATBOX;\r\n  serverchatcmnc = svrCom.serverchatcmnc;\r\n  _chatService = service._chatService;\r\n}\r\n\r\nasync function initContact(contactmode, callbackFunc) {\r\n  const preInit = document.getElementById(\"contactID\");\r\n  if(preInit)preInit.remove();\r\n\r\n  const contact = dmt.domtool.creatediv(\"contact\", \"contactID\");\r\n  const contactbean = dmt.domtool.creatediv(\"contactbean\");\r\n  const contacttile = dmt.domtool.creatediv(\"contacttile\");\r\n  const contacttitlename = dmt.domtool.creatediv(\"contacttitlename\");\r\n  contacttitlename.classList.add(\"contacttitlename\");\r\n  contacttitlename.classList.add(\"contacttitleitem\");\r\n  contacttitlename.innerHTML = \"Contact\";\r\n\r\n  const contactaccept = dmt.domtool.creatediv(\"contactaccept\");\r\n  contactaccept.classList.add(\"contacttitleitem\");\r\n  contactaccept.innerHTML = \"accept\";\r\n  contactaccept.addEventListener('click', function () {\r\n    _chatService.userhaveaAction();\r\n    const listItm = document.getElementsByClassName(\"contactitem_checker\");\r\n    const contactlstrslt = [];\r\n    for (var item of listItm) {\r\n      if(item.checked){\r\n        contactlstrslt.push(parseInt(item.getAttribute(\"imafriend_userid\")));\r\n      }\r\n    }\r\n    callbackFunc(contactlstrslt);\r\n    const dispose = document.getElementById(\"contactID\");\r\n    if(dispose)dispose.remove();\r\n  });\r\n  const contactcancel = dmt.domtool.creatediv(\"contactcancel\");\r\n  contactcancel.classList.add(\"contacttitleitem\");\r\n  contactcancel.innerHTML=\"cancel\";\r\n  contactcancel.addEventListener('click', function () {\r\n    const dispose = document.getElementById(\"contactID\");\r\n    if(dispose)dispose.remove();\r\n  });\r\n  switch (contactmode) {\r\n    case CONTACTMODE.SELECT:\r\n    contactaccept.style.visibility=\"hidden\";\r\n    break;\r\n    case CONTACTMODE.CHECKER:\r\n    break;\r\n  }\r\n  const contactlist = getContactlist();\r\n  await loadContactList(contactmode, contactlist);\r\n  contacttile.appendChild(contacttitlename);\r\n  if(contactaccept)\r\n  contacttile.appendChild(contactaccept);\r\n  if(contactcancel)\r\n  contacttile.appendChild(contactcancel);\r\n  contactbean.appendChild(contacttile);\r\n  contactbean.appendChild(contactlist);\r\n  contact.appendChild(contactbean);\r\n\r\n  await new Promise(function(resolve, reject) {\r\n    contact.style.animation = \"expandwh 0.12s cubic-bezier(0,0, 1, 1)  0.1s both\";\r\n    setTimeout(resolve, 200);\r\n  });\r\n  document.getElementById(\"chatsubpanelID\").prepend(contact);\r\n}\r\n\r\nfunction getContactlist() {\r\n  const contactlist = dmt.domtool.creatediv(\"contactlist\", \"contactlistID\");\r\n  contactlist.addEventListener('wheel', (e) =>{\r\n    if (event.deltaY<0) {\r\n      contactlist.scrollTop -= 12;\r\n      return;\r\n    } else {\r\n      contactlist.scrollTop += 12;\r\n      return;\r\n    }\r\n  });\r\n  return contactlist;\r\n}\r\n\r\n\r\nlet itemToolOver = false;\r\nasync function loadContactList(contactmode, contactlist) {\r\n  contactlist.innerHTML=\"\";\r\n  const contctLst = await(serverchatcmnc.getContactList());\r\n  contctLst.forEach( item => {\r\n    const contactitem = dmt.domtool.creatediv(\"contactitem\");\r\n    contactitem.addEventListener('click',async function() {\r\n      if(itemToolOver) return;\r\n      _chatService.userhaveaAction();\r\n\r\n      let chatbox = await(serverchatcmnc.getfriendchatbox(item.friendid));\r\n      if(chatbox==null||chatbox.length<=0){\r\n        chatbox = await(serverchatcmnc.createfriendchatbox(item.friendid, item.imafriend.username));\r\n        console.log(chatbox);\r\n        ACTIVECHATBOX.selector.select(chatbox.chatboxid);\r\n        return;\r\n      }\r\n      ACTIVECHATBOX.selector.select(chatbox[0].chatboxid);\r\n    });\r\n    contactitem.addEventListener('dblclick', function (e) {\r\n\r\n    });\r\n    const contactavatar = dmt.domtool.creatediv(\"contactavatar\");\r\n    const contactname = dmt.domtool.creatediv(\"contactname\");\r\n    contactname.innerHTML = item.imafriend.username;\r\n    switch (contactmode) {\r\n      case CONTACTMODE.SELECT:\r\n      var contactcallbean = dmt.domtool.creatediv(\"contactcallbean\");\r\n      const contactcall = dmt.domtool.creatediv(\"contactcall\");\r\n      var removebutton = dmt.domtool.creatediv(\"removebutton\", \"removebuttonID\" +  item.imafriend.userid);\r\n      removebutton.innerHTML=\"&times;\";\r\n      removebutton.setAttribute(\"imafriend_userid\", item.imafriend.userid);\r\n      removebutton.addEventListener('click', async function() {\r\n        _chatService.userhaveaAction();\r\n        const id = parseInt(this.getAttribute(\"imafriend_userid\"));\r\n        const rs = await serverchatcmnc.removeContact(id);\r\n        console.log(rs);\r\n        const contactlist = document.getElementById(\"contactlistID\");\r\n        loadContactList(CONTACTMODE.SELECT, contactlist);\r\n      });\r\n      removebutton.addEventListener('mouseover',()=>{\r\n        itemToolOver = true;\r\n      });\r\n      removebutton.addEventListener('mouseleave',()=>{\r\n        itemToolOver = false;\r\n      });\r\n      contactcallbean.appendChild(contactcall);\r\n      break;\r\n      case CONTACTMODE.CHECKER:\r\n      var contactitemselect = dmt.domtool.creatediv(\"contactitemselect\");\r\n      const contactitem_checker = document.createElement(\"input\");\r\n      contactitem_checker.classList.add(\"contactitem_checker\", \"contactitem_checkerID\" +  item.imafriend.userid);\r\n      contactitem_checker.type = \"checkbox\";\r\n      contactitem_checker.setAttribute(\"imafriend_userid\", item.imafriend.userid);\r\n      contactitem_checker.addEventListener('mouseover',()=>{\r\n        itemToolOver = true;\r\n      });\r\n      contactitem_checker.addEventListener('mouseleave',()=>{\r\n        itemToolOver = false;\r\n      });\r\n      contactitemselect.appendChild(contactitem_checker);\r\n      break;\r\n    }\r\n\r\n    contactitem.appendChild(contactavatar);\r\n    contactitem.appendChild(contactname);\r\n    if(contactcallbean)\r\n    contactitem.appendChild(contactcallbean);\r\n    if(contactitemselect)\r\n    contactitem.appendChild(contactitemselect);\r\n    if(removebutton)\r\n    contactitem.appendChild(removebutton);\r\n    contactlist.appendChild(contactitem);\r\n  });\r\n\r\n}\r\n\n\n//# sourceURL=webpack://someLibName/./wpsrc/contact/contact.js?");

/***/ }),

/***/ "./wpsrc/filetransfer/filetransfer.js":
/*!********************************************!*\
  !*** ./wpsrc/filetransfer/filetransfer.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MyUploadAdapter\": () => (/* binding */ MyUploadAdapter)\n/* harmony export */ });\nclass MyUploadAdapter {\r\n  constructor( loader, TOKEN) {\r\n    // The file loader instance to use during the upload.\r\n    console.log(\"your file has loaded\");\r\n    this.loader = loader;\r\n    this.TOKEN = TOKEN;\r\n  }\r\n\r\n  // Starts the upload process.\r\n  upload() {\r\n    console.log(\"you have posted a file\");\r\n    return this.loader.file\r\n    .then( file => new Promise( ( resolve, reject ) => {\r\n      this._initRequest();\r\n      this._initListeners( resolve, reject, file );\r\n      this._sendRequest( file );\r\n    } ) );\r\n  }\r\n\r\n  // Aborts the upload process.\r\n  abort() {\r\n    if ( this.xhr ) {\r\n      this.xhr.abort();\r\n    }\r\n  }\r\n\r\n  // Initializes the XMLHttpRequest object using the URL passed to the constructor.\r\n  _initRequest() {\r\n    const xhr = this.xhr = new XMLHttpRequest();\r\n    // Note that your request may look different. It is up to you and your editor\r\n    // integration to choose the right communication channel. This example uses\r\n    // a POST request with JSON as a data structure but your configuration\r\n    // could be different.\r\n    xhr.open( 'POST', '/Susertranferfile?conversationid='+this.loader.conversationid+\"&fileid=\"+this.loader.fileid, true );\r\n    xhr.setRequestHeader(\"x-access-token\", this.TOKEN.ACCESSTOKEN);\r\n    xhr.timeout = 1000;\r\n    xhr.responseType = 'json';\r\n  }\r\n\r\n  // Initializes XMLHttpRequest listeners.\r\n  _initListeners( resolve, reject, file ) {\r\n    const xhr = this.xhr;\r\n    const loader = this.loader;\r\n    const genericErrorText = `Couldn't upload file: ${ file.name }.`;\r\n\r\n    xhr.addEventListener( 'error', () => reject( genericErrorText ) );\r\n    xhr.addEventListener( 'abort', () => reject() );\r\n    xhr.addEventListener( 'load', () => {\r\n      const response = xhr.response;\r\n\r\n      if ( !response || response.error ) {\r\n        return reject( response && response.error ? response.error.message : genericErrorText );\r\n      }\r\n      console.log(\"response:\", response);\r\n      resolve(response);\r\n    } );\r\n    xhr.ontimeout = function (e) {\r\n      // XMLHttpRequest timed out. Do something here.\r\n      console.log(\"timeout...\");\r\n      resolve({message: \"timeout\"});\r\n    };\r\n\r\n    if ( xhr.upload ) {\r\n      xhr.upload.addEventListener( 'progress', evt => {\r\n        if ( evt.lengthComputable ) {\r\n          loader.uploadTotal = evt.total;\r\n          loader.uploaded = evt.loaded;\r\n        }\r\n      } );\r\n    }\r\n  }\r\n\r\n  // Prepares the data and sends the request.\r\n  _sendRequest( file ) {\r\n    // Prepare the form data.\r\n    const data = new FormData();\r\n    data.append( 'filetoupload', file);\r\n\r\n    // Send the request.\r\n    this.xhr.send( data );\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack://someLibName/./wpsrc/filetransfer/filetransfer.js?");

/***/ }),

/***/ "./wpsrc/menu/bubble.js":
/*!******************************!*\
  !*** ./wpsrc/menu/bubble.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"init\": () => (/* binding */ init)\n/* harmony export */ });\n// const vh = Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0);\r\nconst dmt = __webpack_require__(/*! ../app/domtl */ \"./wpsrc/app/domtl.js\");\r\n\r\nlet MOUSESTATE;\r\nlet USERDATA;\r\nlet PUPLESTATE;\r\nlet ACBrecentchatbox;\r\nlet executeAsync;\r\nlet sleep;\r\nlet serverchatcmnc;\r\nlet TOKEN;\r\nlet _chatService;\r\n\r\nconst init = function (myapp, service, token, svrCom) {\r\n\r\n  MOUSESTATE = myapp.MOUSESTATE;\r\n  USERDATA = myapp.USERDATA;\r\n  PUPLESTATE = myapp.PUPLESTATE;\r\n  ACBrecentchatbox = myapp.ACTIVECHATBOX.recentchatbox;\r\n  executeAsync = myapp.executeAsync;\r\n  sleep = myapp.sleep;\r\n  serverchatcmnc = svrCom.serverchatcmnc;\r\n  TOKEN = token.TOKEN;\r\n  _chatService = service._chatService;\r\n\r\n  initPuplebox();\r\n}\r\n\r\nasync function initPuplebox(){\r\n  document.getElementById(\"logout_buttonID\").style.display = \"\";\r\n  document.getElementById(\"login_buttonID\").style.display = \"none\";\r\n  const pupleuserName = document.getElementById(\"pupleuserNameID\");\r\n  pupleuserName.innerHTML = USERDATA.NAME;\r\n  const puplebox = document.getElementById(\"pupleboxID\");\r\n  const puple = document.getElementById(\"pupleID\");\r\n  puple.addEventListener('click', async () =>{\r\n    if(MOUSESTATE.PRESSANDMOVE)return;\r\n    if(PUPLESTATE.showpuplebox_toolbar){\r\n      executeAsync(function() {\r\n        _chatService.userhaveaAction(true);\r\n      }, 220);\r\n      document.getElementById(\"toolbarID\").className = \"toolbar\";\r\n    }else {\r\n      document.getElementById(\"toolbarID\").className = \"hidetoolbar\";\r\n      close_newgroup();\r\n      close_addfriend();\r\n    }\r\n    PUPLESTATE.showpuplebox_toolbar =!PUPLESTATE.showpuplebox_toolbar;\r\n  });\r\n\r\n  const addfriend = document.getElementById(\"addfriendID\");\r\n  addfriend.addEventListener('click', async () =>{\r\n    _chatService.userhaveaAction();\r\n    if(MOUSESTATE.PRESSANDMOVE)return;\r\n    return new Promise(async function(resolve, reject) {\r\n      close_newgroup();\r\n      await sleep(50);\r\n      resolve();\r\n    }).then(()=>{show_addfriend();});\r\n  });\r\n\r\n  const newfriendtext = document.getElementById(\"newfriendtextID\");\r\n  newfriendtext.addEventListener('keypress', function(event) {\r\n    switch (event.keyCode) {\r\n      case 13:\r\n      break;\r\n      default:\r\n      if(newfriendtext.value.length<50) return;\r\n    }\r\n    event.preventDefault();\r\n  });\r\n  newfriendtext.addEventListener('paste', function(event) {\r\n    if(newfriendtext.value.length>50){newfriendtext.value = newfriendtext.value.substring(0,50);}\r\n  });\r\n  newfriendtext.addEventListener('input', function(event) {\r\n    if(newfriendtext.value.length>50){newfriendtext.value = newfriendtext.value.substring(0,50);}\r\n  });\r\n\r\n  const searchbutton = document.getElementById(\"searchbuttonID\");\r\n  searchbutton.addEventListener('click',async function(){\r\n    const newfriendtext = document.getElementById(\"newfriendtextID\");\r\n    const pattern = newfriendtext.value;\r\n    // console.log(pattern);\r\n    if(pattern.localeCompare(\"\")===0) return;\r\n    const userresult = await(serverchatcmnc.findUsername (pattern));\r\n    if(userresult)\r\n    {\r\n      showfriendSreachresult(userresult);\r\n      return;\r\n    }\r\n    showfriendSreachresult({username: \"noresult for: \"+ pattern});\r\n    newfriendtext.value = \"\";\r\n  });\r\n\r\n  const newgroup = document.getElementById(\"newgroupID\");\r\n  newgroup.addEventListener('click',async () =>{\r\n    if(MOUSESTATE.PRESSANDMOVE) return;\r\n    return new Promise(async function(resolve, reject) {\r\n      close_addfriend();\r\n      await sleep(50);\r\n      resolve();\r\n    }).then(()=>{show_newgroup();});\r\n  });\r\n\r\n  const newgrouptext = document.getElementById(\"newgrouptext\");\r\n  newgrouptext.addEventListener('keypress', function(event) {\r\n    switch (event.keyCode) {\r\n      case 13:\r\n      break;\r\n      default:\r\n      if(newgrouptext.value.length<50) return;\r\n    }\r\n    event.preventDefault();\r\n  });\r\n  newgrouptext.addEventListener('paste', function(event) {\r\n    if(newgrouptext.value.length>80){newgrouptext.value = newgrouptext.value.substring(0,80);}\r\n  });\r\n  newgrouptext.addEventListener('input', function(event) {\r\n    if(newgrouptext.value.length>80){newgrouptext.value = newgrouptext.value.substring(0,80);}\r\n  });\r\n\r\n  const newgroupCreatebutton = document.getElementById(\"newgroupCreatebuttonID\");\r\n  newgroupCreatebutton.addEventListener('click', async function() {\r\n    _chatService.userhaveaAction();\r\n    const name = newgrouptext.value;\r\n    if(name.localeCompare(\"\")==0)return;\r\n    const newgroup = await(serverchatcmnc.createChatbox(name));\r\n    const chatboxid = newgroup.chatboxid;\r\n    if(!chatboxid||chatboxid<0) return;\r\n    const listfriendID = [];\r\n    const list = document.getElementsByClassName(\"friendlist_item_checker\");\r\n    for (var item of list) {\r\n      if(item.checked){\r\n        const id = item.getAttribute(\"imafriend_userid\");\r\n        console.log(\"item.checked:\" , id);\r\n        listfriendID.push(id);\r\n      }\r\n    }\r\n\r\n    listfriendID.forEach(userid => {\r\n      serverchatcmnc.sendgroupRequest(chatboxid, userid);\r\n    });\r\n\r\n    newgrouptext.value=\"\";\r\n    close_newgroup();\r\n  });\r\n\r\n  const openstory = document.getElementById(\"openstoryID\");\r\n  openstory.addEventListener('click', () =>{\r\n    // if(MOUSESTATE.PRESSANDMOVE)return;\r\n    // if(PUPLESTATE.show_story){\r\n    //   document.getElementById(\"listlistItmstoryID\").className = \"liststory\";\r\n    // }else {\r\n    //   document.getElementById(\"liststoryID\").className = \"hideliststory\";\r\n    // }\r\n    // PUPLESTATE.show_story =!PUPLESTATE.show_story;\r\n  });\r\n\r\n  const logout = document.getElementById(\"logout_buttonID\");\r\n  logout.addEventListener('click', function(){\r\n    // signout ();\r\n    window.location.replace(\"/logout?token=\"+TOKEN.ACCESSTOKEN);\r\n  });\r\n\r\n  const hiderecent = document.getElementById(\"hiderecentID\");\r\n  hiderecent.addEventListener('click', function () {\r\n    if (ACBrecentchatbox.hide) {\r\n      console.log(\"set hidden\");\r\n      for (let item of document.getElementsByClassName(\"recentchatbox\")) {item.style.visibility = \"hidden\";}\r\n      ACBrecentchatbox.hide=!ACBrecentchatbox.hide;\r\n      return ;\r\n    }\r\n    for (let item of document.getElementsByClassName(\"recentchatbox\")) { item.style.visibility='visible'; }\r\n    ACBrecentchatbox.hide=!ACBrecentchatbox.hide;\r\n  });\r\n}\r\n\r\n\r\nfunction show_newgroup() {\r\n  if(PUPLESTATE.show_newgroup){\r\n    document.getElementById(\"creategroupboxID\").className = \"creategroupbox\";\r\n    loadfriendlist(true);\r\n  }else {\r\n    document.getElementById(\"creategroupboxID\").className = \"hidecreategroupbox\";\r\n    loadfriendlist(false);\r\n  }\r\n  PUPLESTATE.show_newgroup =!PUPLESTATE.show_newgroup;\r\n}\r\n\r\nasync function loadfriendlist(show){\r\n  const listfriend = document.getElementById(\"creategroup_friendlistID\");\r\n  if(!show) {listfriend.innerHTML=\"\"; return;}\r\n  const contactList = await(serverchatcmnc.getContactList());\r\n  // console.log(contactList);\r\n  contactList.forEach(item => {\r\n    const creategroup_friendlist_item = dmt.domtool.creatediv(\"creategroup_friendlist_item\");\r\n    const friendlist_item_name = dmt.domtool.creatediv(\"friendlist_item_name\");\r\n    friendlist_item_name.innerHTML = item.imafriend.username;\r\n    const friendlist_item_checker = document.createElement(\"input\");\r\n    friendlist_item_checker.classList.add(\"friendlist_item_checker\");\r\n    friendlist_item_checker.setAttribute(\"type\", \"checkbox\");\r\n    friendlist_item_checker.id = \"friendlist_item_checkerID\" + item.imafriend.userid;\r\n    friendlist_item_checker.setAttribute(\"imafriend_userid\", item.imafriend.userid);\r\n    creategroup_friendlist_item.appendChild(friendlist_item_name);\r\n    creategroup_friendlist_item.appendChild(friendlist_item_checker);\r\n    listfriend.appendChild(creategroup_friendlist_item);\r\n  });\r\n}\r\n\r\nasync function close_newgroup(){\r\n  if(!PUPLESTATE.show_newgroup){\r\n    document.getElementById(\"creategroupboxID\").className = \"hidecreategroupbox\";\r\n    PUPLESTATE.show_newgroup =!PUPLESTATE.show_newgroup;\r\n    loadfriendlist(false);\r\n  }\r\n}\r\n\r\nfunction show_addfriend() {\r\n  if(PUPLESTATE.show_addfriend){\r\n    document.getElementById(\"addfriendboxID\").className = \"addfriendbox\";\r\n  }else {\r\n    document.getElementById(\"addfriendboxID\").className = \"hideaddfriendbox\";\r\n  }\r\n  PUPLESTATE.show_addfriend =!PUPLESTATE.show_addfriend;\r\n}\r\n\r\nfunction close_addfriend(){\r\n  if(!PUPLESTATE.show_addfriend){\r\n    document.getElementById(\"addfriendboxID\").className = \"hideaddfriendbox\";\r\n    PUPLESTATE.show_addfriend =!PUPLESTATE.show_addfriend;\r\n  }\r\n  clearsearch();\r\n}\r\n\r\nfunction clearsearch(){\r\n  const addfriendsearchresult = document.getElementById(\"addfriendsearchresultID\");\r\n  addfriendsearchresult.innerHTML=\"\";\r\n  const newfriendtext = document.getElementById(\"newfriendtextID\");\r\n  newfriendtext.value=\"\";\r\n}\r\n\r\nfunction showfriendSreachresult(friend){\r\n  const addfriendsearchresult = document.getElementById(\"addfriendsearchresultID\");\r\n  addfriendsearchresult.innerHTML=\"\";\r\n  const addfriendqueryresult = dmt.domtool.creatediv(\"addfriendqueryresult\", \"addfriendqueryresultID\");\r\n  addfriendqueryresult.innerHTML=\"\";\r\n  const friendinfo = dmt.domtool.creatediv(\"friendinfo\", \"friendinfoID\" + friend.userid);\r\n  const friendavatar = dmt.domtool.creatediv(\"friendavatar\");\r\n  const friendname = dmt.domtool.creatediv(\"friendname\", \"friendnameID\" + friend.userid);\r\n  friendname.innerHTML = friend.username;\r\n  if(friend.userid) {\r\n    var addfriendbutton = document.createElement(\"div\");\r\n    addfriendbutton.classList.add(\"addfriendbutton\");\r\n    addfriendbutton.id = \"addfriendbuttonID\" + friend.userid;\r\n    addfriendbutton.innerHTML= \"+ add friend\";\r\n    addfriendbutton.setAttribute(\"friend_userid\", friend.userid);\r\n    addfriendbutton.addEventListener('click', function() {\r\n      _chatService.userhaveaAction();\r\n      const userid = this.getAttribute(\"friend_userid\");\r\n      serverchatcmnc.sendmakerelateRequest(friend.userid);\r\n      close_addfriend();\r\n    });\r\n  }\r\n  const descript = dmt.domtool.creatediv(\"descript\");\r\n  const userdescript = dmt.domtool.creatediv(\"userdescript\");\r\n  descript.appendChild(userdescript);\r\n  friendinfo.appendChild(friendavatar);\r\n  friendinfo.appendChild(friendname);\r\n  if(addfriendbutton)\r\n  friendinfo.appendChild(addfriendbutton);\r\n  addfriendqueryresult.appendChild(friendinfo);\r\n  addfriendqueryresult.appendChild(descript);\r\n  const addfriendbox = document.getElementById(\"addfriendboxID\");\r\n  addfriendsearchresult.appendChild(addfriendqueryresult);\r\n  addfriendbox.appendChild(addfriendsearchresult);\r\n}\r\n\n\n//# sourceURL=webpack://someLibName/./wpsrc/menu/bubble.js?");

/***/ }),

/***/ "./wpsrc/menu/mainMenu.js":
/*!********************************!*\
  !*** ./wpsrc/menu/mainMenu.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"init\": () => (/* binding */ init)\n/* harmony export */ });\nlet APPNOTICE;\r\nlet CONTACTMODE;\r\nlet NOTIFYTYPE;\r\nlet contact;\r\nlet _chatService;\r\nlet serverchatcmnc;\r\n\r\nconst init = function (myapp, _contact, service, svrCom) {\r\n\r\n  APPNOTICE = myapp.APP.NOTICE;\r\n  CONTACTMODE = myapp.CONTACTMODE;\r\n  NOTIFYTYPE = myapp.NOTIFYTYPE;\r\n  contact = _contact;\r\n  _chatService = service._chatService;\r\n  serverchatcmnc = svrCom.serverchatcmnc;\r\n  initMenu();\r\n}\r\n\r\nfunction initMenu(){\r\n  const menunotify = document.getElementById(\"menunotifyID\");\r\n  const showaccountnotify = document.getElementById(\"showaccountnotifyID\");\r\n  menunotify.addEventListener('click', function() {\r\n    _chatService.userhaveaAction();\r\n    showNotice();\r\n  });\r\n\r\n  const accountnotify = document.getElementById(\"accountnotifyID\");\r\n  accountnotify.addEventListener('mouseleave', function () {\r\n    const accountnotify = document.getElementById(\"accountnotifyID\");\r\n    showaccountnotify.className=\"hideaccountnotify\";\r\n  });\r\n\r\n  const menucontact = document.getElementById(\"menucontactID\");\r\n  menucontact.addEventListener('click',function() {\r\n    contact.initContact(CONTACTMODE.SELECT);\r\n  });\r\n}\r\n\r\nfunction showNotice() {\r\n  new Promise(function(resolve, reject) {\r\n    const accountnotify = document.getElementById(\"accountnotifyID\");\r\n    accountnotify.innerHTML=\"\";\r\n    let haveNotice = false;\r\n\r\n    for (var item of APPNOTICE.invitechatboxNotify) {\r\n      addAccountnotify(NOTIFYTYPE.TYPEADDGROUP, item);\r\n      haveNotice = true;\r\n    }\r\n    for (var item of APPNOTICE.makerelateRequest) {\r\n      addAccountnotify(NOTIFYTYPE.TYPEADDFRIEND, item);\r\n      haveNotice = true;\r\n    }\r\n    let unread = 0;\r\n    for (var item of APPNOTICE.chatboxUnreadmessage) {\r\n      unread += item.totalnoticecount;\r\n    }\r\n    if(unread==0)resolve();\r\n    haveNotice = true;\r\n    addAccountnotify(NOTIFYTYPE.TYPEUNREADMESSAGE, {unread});\r\n    resolve();\r\n  }).then(()=>{\r\n    const showaccountnotify = document.getElementById(\"showaccountnotifyID\");\r\n    showaccountnotify.className = \"showaccountnotify\";\r\n    console.log(showaccountnotify.className);\r\n  });\r\n}\r\n\r\nfunction addAccountnotify(type, item){\r\n  // console.log(item);\r\n  const accountnotify = document.getElementById(\"accountnotifyID\");\r\n  const accountnotifyitem = document.createElement(\"div\");\r\n  accountnotifyitem.classList.add(\"accountnotifyitem\");\r\n  switch (type) {\r\n    case NOTIFYTYPE.TYPEADDFRIEND:\r\n    accountnotifyitem.id = \"accountnotifyitemID\" + type + item.partnerid;\r\n    break;\r\n    case NOTIFYTYPE.TYPEADDGROUP:\r\n    accountnotifyitem.id = \"accountnotifyitemID\" + type  + \"-\" + item.chatboxid + \"-\" + item.senderid;\r\n    break;\r\n    case NOTIFYTYPE.TYPEUNREADMESSAGE:\r\n    accountnotifyitem.id = \"accountnotifyitemID\" + type + item.unread;\r\n    break;\r\n  }\r\n  const user = document.createElement(\"div\");\r\n  user.classList.add(\"user\");\r\n  if(item){\r\n    var usericon = document.createElement(\"div\");\r\n    usericon.classList.add(\"usericon\");\r\n    var username = document.createElement(\"div\");\r\n    username.classList.add(\"username\");\r\n    switch (type) {\r\n      case NOTIFYTYPE.TYPEADDFRIEND:\r\n      console.log(type, item);\r\n      username.innerHTML = item.sendrequest.username;\r\n      break;\r\n      case NOTIFYTYPE.TYPEADDGROUP:\r\n      username.innerHTML = item.sender.username;\r\n      break;\r\n    }\r\n  }\r\n  const actionmessage = document.createElement(\"div\");\r\n  actionmessage.classList.add(\"actionmessage\");\r\n  switch (type) {\r\n    case NOTIFYTYPE.TYPEADDFRIEND:\r\n    actionmessage.innerHTML=\"send friend request to you\";\r\n    break;\r\n    case NOTIFYTYPE.TYPEADDGROUP:\r\n    actionmessage.innerHTML=\"send invite group to you\";\r\n    break;\r\n    case NOTIFYTYPE.TYPEUNREADMESSAGE:\r\n    actionmessage.innerHTML=\"you have: \" + item.unread + \" unread message\";\r\n    break;\r\n  }\r\n  const confirm = document.createElement(\"div\");\r\n  confirm.classList.add(\"confirm\");\r\n  confirm.classList.add(\"respone\");\r\n  switch (type) {\r\n    case NOTIFYTYPE.TYPEADDFRIEND:\r\n    confirm.id = \"confirmID\" + type + item.partnerid;\r\n    confirm.setAttribute(\"type\", type);\r\n    confirm.setAttribute(\"partnerid\", item.partnerid);\r\n    break;\r\n    case NOTIFYTYPE.TYPEADDGROUP:\r\n    confirm.id = \"confirmID\" + type + \"-\" + item.chatboxid + \"-\" + item.senderid;\r\n    confirm.setAttribute(\"type\", type);\r\n    confirm.setAttribute(\"chatboxid\", item.chatboxid);\r\n    confirm.setAttribute(\"senderid\", item.senderid);\r\n    break;\r\n    case NOTIFYTYPE.TYPEUNREADMESSAGE:\r\n    confirm.id = \"confirmID\" + type + item.unread;\r\n    confirm.setAttribute(\"type\", type);\r\n    confirm.setAttribute(\"unread\", item.unread);\r\n    break;\r\n  }\r\n  confirm.innerHTML = \"confirm\";\r\n  confirm.addEventListener('click', function(){\r\n    _chatService.userhaveaAction();\r\n    const type =  this.getAttribute(\"type\");\r\n    var accept = null;\r\n    switch (type) {\r\n      case NOTIFYTYPE.TYPEADDFRIEND:;\r\n      const userid = this.getAttribute(\"partnerid\");\r\n      accept = serverchatcmnc.relateAccept(userid);\r\n      break;\r\n      case NOTIFYTYPE.TYPEADDGROUP:\r\n      const chatboxid = this.getAttribute(\"chatboxid\");\r\n      const senderid = this.getAttribute(\"senderid\");\r\n      accept = serverchatcmnc.invitegroupAccept(senderid, chatboxid);// userid todo\r\n      break;\r\n      default:\r\n    }\r\n    if(!accept) return;\r\n    const thisid = this.id.substring(9);\r\n    const el = document.getElementById('accountnotifyitemID'+ thisid);\r\n    el.remove();\r\n  });\r\n  const discare = document.createElement(\"div\");\r\n  discare.classList.add(\"discare\");\r\n  discare.classList.add(\"respone\");\r\n  switch (type) {\r\n    case NOTIFYTYPE.TYPEADDFRIEND:\r\n    discare.id = \"discareID\" + type + item.partnerid;\r\n    discare.setAttribute(\"type\", type);\r\n    discare.setAttribute(\"partnerid\", item.partnerid);\r\n    break;\r\n    case NOTIFYTYPE.TYPEADDGROUP:\r\n    discare.id = \"confirmID\" + type + \"-\" + item.chatboxid + \"-\" + item.senderid;\r\n    discare.setAttribute(\"type\", type);\r\n    discare.setAttribute(\"chatboxid\", item.chatboxid);\r\n    discare.setAttribute(\"senderid\", item.senderid);\r\n    break;\r\n    case NOTIFYTYPE.TYPEUNREADMESSAGE:\r\n    discare.id = \"discareID\" + type + item.unread;\r\n    discare.setAttribute(\"type\", type);\r\n    discare.setAttribute(\"unread\", item.unread);\r\n    break;\r\n  }\r\n  discare.innerHTML = \"discare\";\r\n  discare.addEventListener('click',function() {\r\n    _chatService.userhaveaAction();\r\n    const type = this.getAttribute(\"type\");\r\n    var accept = false;\r\n    switch (type) {\r\n      case NOTIFYTYPE.TYPEADDFRIEND:\r\n      const userid = this.getAttribute(\"partnerid\");\r\n      accept = serverchatcmnc.relateRefuse(userid);\r\n      break;\r\n      case NOTIFYTYPE.TYPEADDGROUP:\r\n      const chatboxid = this.getAttribute(\"chatboxid\");\r\n      accept = serverchatcmnc.invitegroupRefuse(chatboxid);\r\n      if(!accept) return;\r\n      break;\r\n      default:\r\n    }\r\n    const thisid = this.id.substring(9);\r\n    const el = document.getElementById('accountnotifyitemID'+ thisid);\r\n    el.remove();\r\n  });\r\n  if(item){\r\n    user.appendChild(usericon);\r\n    user.appendChild(username);\r\n  }\r\n  accountnotifyitem.appendChild(user);\r\n  accountnotifyitem.appendChild(actionmessage);\r\n  switch (type) {\r\n    case NOTIFYTYPE.TYPEUNREADMESSAGE: // do nothing\r\n    break;\r\n    default:\r\n    accountnotifyitem.appendChild(confirm);\r\n    accountnotifyitem.appendChild(discare);\r\n  }\r\n  accountnotify.appendChild(accountnotifyitem);\r\n}\r\n\n\n//# sourceURL=webpack://someLibName/./wpsrc/menu/mainMenu.js?");

/***/ }),

/***/ "./wpsrc/service/chattask/chatsvctsk.js":
/*!**********************************************!*\
  !*** ./wpsrc/service/chattask/chatsvctsk.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"init\": () => (/* binding */ init),\n/* harmony export */   \"chatsvctsk\": () => (/* binding */ chatsvctsk)\n/* harmony export */ });\nlet srvcetool;\r\nlet cbxcntrl;\r\nlet token;\r\nlet ACTIVECHATBOX;\r\nlet ACBchatboxStackdata;\r\nlet ACBrecentchatboxdata;\r\nlet APPDATA;\r\nlet TOUCH;\r\nlet APPNOTICE;\r\nlet UPDATER;\r\nlet USERDATA;\r\nlet sleep;\r\nlet getDateString;\r\nlet chattask;\r\nlet serviceTool;\r\nlet chbxcontrol;\r\nlet TOKEN;\r\nlet refreshtoken;\r\nlet serverchatcmnc;\r\nlet serverstreamcmnc;\r\n\r\nconst init = function (myapp, chttk, srvcetool, cbxcntrl, token, svrCom) {\r\n\r\n  ACTIVECHATBOX = myapp.ACTIVECHATBOX;\r\n  ACBchatboxStackdata = ACTIVECHATBOX.chatboxStack.data;\r\n  ACBrecentchatboxdata = ACTIVECHATBOX.recentchatbox.data;\r\n  APPDATA = myapp.APP.DATA;\r\n  TOUCH = myapp.TOUCH;\r\n  APPNOTICE = myapp.APP.NOTICE;\r\n  UPDATER = myapp.UPDATER;\r\n  USERDATA = myapp.USERDATA;\r\n  sleep = myapp.sleep;\r\n  getDateString = myapp.getDateString;\r\n  chattask = chttk.chattask;\r\n  serviceTool = srvcetool.serviceTool;\r\n  chbxcontrol = cbxcntrl.chbxcontrol;\r\n  TOKEN = token.TOKEN;\r\n  refreshtoken = token.refreshtoken;\r\n  serverchatcmnc = svrCom.serverchatcmnc;\r\n  serverstreamcmnc = svrCom.serverstreamcmnc;\r\n}\r\n\r\nconst chatsvctsk = {\r\n  \r\n  userstilllivestream: function () {\r\n    ACBchatboxStackdata.forEach(chtbxstkitem => {\r\n      serverstreamcmnc.userstilllivestream(chtbxstkitem.chatboxid);\r\n    });\r\n  },\r\n\r\n  // chat list\r\n  updatechatboxlistdata: async function() {\r\n    const chatboxlist = await(serverchatcmnc.getChatboxlist());\r\n    if (!chatboxlist) return;\r\n    APPDATA.chatboxlist = chatboxlist\r\n    APPDATA.chatboxlist.forEach (async item => {\r\n      item.members = await(serverchatcmnc.getchatboxMember(item.chatboxid));\r\n    });\r\n  },\r\n\r\n  // chat box\r\n  updatechatboxstack: function() {\r\n    const chatboxlist = APPDATA.chatboxlist;\r\n    ACBchatboxStackdata.forEach(chtbxstkitem => {\r\n      chatboxlist.forEach(chatboxlistitem => {\r\n        if(chtbxstkitem.chatboxid!=chatboxlistitem.chatboxid) return;\r\n        if (!chatboxlistitem.members) return;\r\n        chtbxstkitem.members = chatboxlistitem.members;\r\n      });\r\n    });\r\n  },\r\n\r\n  showchatbox: function() {\r\n    if(!ACTIVECHATBOX.selector.isreadytoshow())return ;\r\n    const openlist = ACTIVECHATBOX.selector.openlist;\r\n    openlist.forEach(item => {\r\n      if (ACBchatboxStackdata.some(chtbxstkitem => { if(chtbxstkitem.chatboxid == item)return true;})) {// is opened\r\n        ACTIVECHATBOX.selector.openlist.remove(item);\r\n        return;\r\n      }\r\n      chbxcontrol.showChatbox(item);\r\n      ACTIVECHATBOX.selector.openlist.remove(item);\r\n    });\r\n  },\r\n\r\n  closechatbox: function() {\r\n    ACBchatboxStackdata.forEach((chtbxstkitem, i) => {\r\n      switch (true) {\r\n        case (!chtbxstkitem.dispose): return;\r\n        case (chtbxstkitem.chatbox.style.animation.localeCompare(\"\")!=0): return;\r\n      }\r\n      chbxcontrol.chtbxdestroyer(i);\r\n    });\r\n  },\r\n\r\n  removechatbox: function() {\r\n    for (var i = 0, len = ACBchatboxStackdata.length; i < len; i++) {\r\n      if (i< ACTIVECHATBOX.chatboxStack.maxWindows) continue;\r\n      ACBchatboxStackdata[0].dispose = true;\r\n    }\r\n  },\r\n\r\n  //service\r\n  gettouch: async function () {\r\n    const touch = await serverchatcmnc.gettouchMe();\r\n    TOUCH.touchme = ((touch)?touch.touchme:false);//\r\n    if(!TOUCH.touchme) {UPDATER.ISWAKEDUP = false;}\r\n  },\r\n\r\n  feedback: async function (chtSrvce) {\r\n    if(!TOUCH.touchme||TOUCH.VOTEUPDATE.updaterTotalVote < 3) return;\r\n    await serverchatcmnc.settouchMe(/*false*/);\r\n    console.log(\"feedback\", UPDATER.ISWAKEDUP);\r\n  },\r\n\r\n  wakeup: function (chtSrvce) {\r\n    if(!TOUCH.touchme||UPDATER.ISWAKEDUP) return;\r\n    UPDATER.ISWAKEDUP = true;// no double start\r\n    chtSrvce.wakeupService();\r\n    chtSrvce.dpsleep.count = 0;\r\n  },\r\n\r\n  deepslp: function (chtSrvce) {\r\n    if(TOUCH.touchme||serviceTool.serviceIsWakingup()||chtSrvce.dpsleep.count>UPDATER.dpslp+1) return ;\r\n    if (chtSrvce.dpsleep.count<UPDATER.dpslp) {chtSrvce.dpsleep.count++; return} ;\r\n    chtSrvce.dpsleep.gotoDeepsleep();//deepsleep\r\n    chtSrvce.dpsleep.count = 0;\r\n    console.log(\"goingtoDeepsleep\");\r\n  },\r\n\r\n  // online\r\n  userstillonline: async function () {\r\n    await serverchatcmnc.istillonline();\r\n  },\r\n\r\n  updtchtbxlistactivestt: function () {// update chat box list active\r\n    const chatlist = [];\r\n    const chatboxlist = APPDATA.chatboxlist;\r\n    for (var chatbox of chatboxlist) { chatlist.push(chatbox.chatboxid); }\r\n    chatboxlist.forEach(chatbox => {\r\n      chattask.chatboxactivestt(chatbox, chatlist);\r\n    });\r\n  },\r\n\r\n  updtchtbxlistonlinestt: function () {// update chat box list online\r\n    const chatboxlist = APPDATA.chatboxlist;\r\n    chatboxlist.forEach(chatbox => {\r\n      chattask.chatlistonlinestt(chatbox);\r\n    });\r\n  },\r\n\r\n  updtrecentchtbxonlinestt: async function () {// update recent chat box list online\r\n    const chatboxlist = APPDATA.chatboxlist;\r\n    const setuprecentchatboxOnline = recentchtbx => {\r\n      chatboxlist.forEach(chatboxlistitem => {\r\n        if(recentchtbx.chatboxid==chatboxlistitem.chatboxid) {\r\n          chattask.recentonlinestt(recentchtbx, chatboxlistitem);\r\n          return true;\r\n        }\r\n      });\r\n    }\r\n    ACBrecentchatboxdata.some(setuprecentchatboxOnline);\r\n  },\r\n\r\n  updtchtbxmemberonlinestt: function () {// update recent chat box mem online\r\n    const setupchatboxMemberonline = async chtbxstkitem => {\r\n      await chattask.memberonlinestt(chtbxstkitem);\r\n    }\r\n    ACBchatboxStackdata.forEach(setupchatboxMemberonline);\r\n\r\n  },\r\n\r\n  // token\r\n  tokenExtend: async function() {\r\n    const expired = new Date() - new Date(TOKEN.UPDATEDAT);\r\n    if(expired<3555555) return;\r\n    await refreshtoken();\r\n  },\r\n\r\n  // chat\r\n\r\n  refreshmsgreceivecache: function () {\r\n    ACBchatboxStackdata.forEach(chtbxstkitem => {\r\n      if (chtbxstkitem.receive_chatdata_cache.length < chtbxstkitem.cachelen) return ;\r\n      chtbxstkitem.receive_chatdata_cache.forEach(item => {\r\n        if (!item.success) return;\r\n        chtbxstkitem.receive_chatdata_cache.remove(item);\r\n      });\r\n    });\r\n  },\r\n\r\n  refreshmmfreceivecache: function () {\r\n    ACBchatboxStackdata.forEach(chtbxstkitem => {\r\n      if (chtbxstkitem.receive_streamdata_cache.length < chtbxstkitem.cachelen) return ;\r\n      chtbxstkitem.receive_streamdata_cache.forEach(item => {\r\n        if (!item.success) return;\r\n        chtbxstkitem.receive_streamdata_cache.remove(item);\r\n      });\r\n    });\r\n  },\r\n\r\n  refreshcbsendingcache: function () {\r\n    ACBchatboxStackdata.forEach(chtbxstkitem => {\r\n      if (chtbxstkitem.sending_chatdata_cache.length < chtbxstkitem.cachelen) return ;\r\n      chtbxstkitem.sending_chatdata_cache.forEach(item => {\r\n        if (!item.success||!item.updateinbrowser) return;\r\n        chtbxstkitem.sending_chatdata_cache.remove(item);\r\n      });\r\n    });\r\n  },\r\n\r\n  setnewconversation: function () {\r\n    ACBchatboxStackdata.forEach (async chtbxstkitem => {\r\n      if(chtbxstkitem.conversation!=null) return; // wait to clear\r\n      chtbxstkitem.sending_chatdata_cache.some(item => {\r\n        if (item.sendingcount != 0) return;\r\n        chtbxstkitem.MAKECONVERSATION = true;\r\n        return true;\r\n      });\r\n    });\r\n  },\r\n\r\n  sendmessage: async function () {\r\n    const sender = serverchatcmnc.sendMessagetochatbox;\r\n\r\n    for (var chtbxstkitem of ACBchatboxStackdata) {\r\n      if(chtbxstkitem.conversation==null) continue;\r\n      const conversationid = chtbxstkitem.conversation.conversationid;\r\n      const sending_chatdata_cache = chtbxstkitem.sending_chatdata_cache;\r\n      for (var item of sending_chatdata_cache) {\r\n        if(item.sendingcount>=1) continue;\r\n        item.sendingcount += 1;\r\n        await sleep(50);\r\n        const rs = await sender(conversationid, item);\r\n        if(rs.unhideUsermindid) {\r\n          item.resID = rs.unhideUsermindid;\r\n          item.success = true;\r\n          item.sended = true;// set sended to borowser update\r\n          continue;\r\n        }\r\n        item.success = false;\r\n        item.sended = true;// set sended to borowser update\r\n      }\r\n    };\r\n  },\r\n\r\n  updatemessagesended: function () {\r\n    ACBchatboxStackdata.forEach (async chtbxstkitem => {\r\n      if(chtbxstkitem.conversation==null) return;\r\n      for (var item of chtbxstkitem.sending_chatdata_cache) {\r\n        if(!item.sended||item.updateinbrowser) continue;\r\n        chattask.browser_updt_chbxmsgitem_sendedstt(item);\r\n      }\r\n    });\r\n  },\r\n\r\n  setmessagereaded: function () {\r\n    //set message is readed\r\n    const setcachedataisReaded = async (chtbxstkitem, item) => {\r\n      if (!item.viewinbrowser||item.success||item.sended||item.datetimeread != null ||item.unhideuserid==USERDATA.ID) return;\r\n      item.sendingcount += 1;\r\n      const rs = (await serverchatcmnc.setmessageReaded(item.unhideUsermindid, getDateString(new Date ())));// set item.success = res;\r\n      if(rs[0]>=1) {\r\n        item.success = true;\r\n        item.sended = true;\r\n        return;\r\n      }\r\n      item.success = false;// set status readed fail or ignore\r\n      item.sended = true;\r\n    }\r\n    ACBchatboxStackdata.forEach (chtbxstkitem => {\r\n      chtbxstkitem.receive_chatdata_cache.forEach(setcachedataisReaded.bind(null, chtbxstkitem));\r\n    });\r\n  },\r\n\r\n  setseenmessage: function () {\r\n    ACBchatboxStackdata.forEach (chtbxstkitem => {\r\n      chattask.brownser_show_seenmessage (chtbxstkitem); //\r\n    });\r\n  },\r\n\r\n  insert_msgitmrecei_tochbx: function () {\r\n    const setcachedataisReaded = (chtbxstkitem, item) => {\r\n      if (item.sended||item.datetimeread != null ||item.unhideuserid==USERDATA.ID||item.viewinbrowser) return;\r\n      chattask.brownser_insert_msgitmrecei_tochbx (chtbxstkitem, item); // show new message from cache\r\n    }\r\n\r\n    ACBchatboxStackdata.forEach (chtbxstkitem => {\r\n      chtbxstkitem.receive_chatdata_cache.forEach(setcachedataisReaded.bind(null, chtbxstkitem));\r\n    });\r\n  },\r\n\r\n  insert_mmfitmrecei_tochbx: function () {\r\n    const setcachedataisReaded = (chtbxstkitem, item) => {\r\n      if (item.viewinbrowser) return;\r\n      chattask.brownser_insert_mmfitmrecei_tochbx (chtbxstkitem, item/*multimedia file*/); // show new message from cache\r\n    }\r\n    ACBchatboxStackdata.forEach (chtbxstkitem => {\r\n      chtbxstkitem.receive_streamdata_cache.forEach(setcachedataisReaded.bind(null, chtbxstkitem));\r\n    });\r\n  },\r\n\r\n  resort_receimsgitem_chtbx: function () {\r\n    const resortchatboxmsg = async (chtbxstkitem, item) => {\r\n      chattask.resort_msgitmrecei_inchbx(chtbxstkitem, item);\r\n    }\r\n    ACBchatboxStackdata.forEach (chtbxstkitem => {\r\n      chtbxstkitem.receive_chatdata_cache.forEach(resortchatboxmsg.bind(null, chtbxstkitem));\r\n    });\r\n  },\r\n\r\n  getchatdatafromserver: function () {\r\n    ACBchatboxStackdata.forEach(item => {\r\n      chatsvctsktool.load_receivedchtbxmsg_tocache (item);\r\n    });\r\n  },\r\n\r\n  getstreamdatafromserver: function () {\r\n    ACBchatboxStackdata.forEach(item => {\r\n      chatsvctsktool.load_streamdata_tocache (item);\r\n    });\r\n  },\r\n\r\n  updateconversation: function () {\r\n    for (var chtbxstkitem of ACBchatboxStackdata) {\r\n      if(!chtbxstkitem.MAKECONVERSATION || chtbxstkitem.conversation != null) continue;\r\n      chtbxstkitem.MAKECONVERSATION = false;\r\n      chatsvctsktool.makeNewConversation(chtbxstkitem);\r\n    };\r\n  },\r\n\r\n  clearConversation: function () {\r\n    ACBchatboxStackdata.forEach(chtbxstkitem => {\r\n      chatsvctsktool.clearOldConversation(chtbxstkitem /*chatbox*/);\r\n    });\r\n  },\r\n\r\n  // notice\r\n  getmakerelateevent:async function() {\r\n    APPNOTICE.makerelateRequest = (await serverchatcmnc.getMakerelateNotify());\r\n  },\r\n\r\n  getinvitechatboxevent:async function() {\r\n    APPNOTICE.invitechatboxNotify = (await serverchatcmnc.getInvitechatboxNotify());\r\n  },\r\n\r\n  getchatnotievent:async function() {\r\n    APPNOTICE.chatboxUnreadmessage = (await serverchatcmnc.getchatNotify());// save to query\r\n  },\r\n\r\n  setchatboxlistnotice: function() {\r\n    if (!APPNOTICE.chatboxUnreadmessage) return;\r\n    const noticesetup = (item_, item) => {\r\n      if (item.chatboxid == item_.chatboxid) {item_.totalnoticecount = item.totalnoticecount; return true;}\r\n    }\r\n    const chatboxlist = APPDATA.chatboxlist;\r\n    chatboxlist.some (item_ => {\r\n      item_.totalnoticecount = 0;\r\n      APPNOTICE.chatboxUnreadmessage.some(noticesetup.bind(null, item_));\r\n    });\r\n  },\r\n\r\n  setrecentnotic: function() {\r\n    const noticesetup = (item_, item) => {\r\n      if (item.chatboxid == item_.chatboxid) {item_.totalnoticecount = item.totalnoticecount; return true;}\r\n    }\r\n    ACBrecentchatboxdata.some(item_ => {\r\n      item_.totalnoticecount = 0;\r\n      APPNOTICE.chatboxUnreadmessage.some(noticesetup.bind(null, item_));\r\n    });\r\n  },\r\n\r\n  showchatlistnotify: function () {\r\n    const chatboxlist = APPDATA.chatboxlist;\r\n    chatboxlist.forEach(item => {\r\n      chattask.brownser_update_chatlistnotice (item.chatboxid, item.totalnoticecount);\r\n    });\r\n  },\r\n\r\n  showrecentnotify: function () {\r\n    const chatboxlist = APPDATA.chatboxlist;\r\n    chatboxlist.forEach(item => {\r\n      chattask.browser_update_recentnotice (item.chatboxid, item.totalnoticecount);\r\n    });\r\n  },\r\n\r\n  showappnotify: function () {\r\n    chattask.browser_update_appNotify(chatsvctsktool.gettotalNoticecount());\r\n  },\r\n\r\n  // refresh page\r\n  chatlistrefresh: function() {\r\n    const chatboxlist = APPDATA.chatboxlist;\r\n    chatboxlist.forEach(chatbox =>{\r\n      chattask.refreshchatlistitem(chatbox);\r\n    });\r\n  },\r\n\r\n  clearchatlistitem: function () {\r\n    chattask.clearchatlistitem();\r\n  },\r\n\r\n  newchatlistitem:function () {\r\n    const chatboxlist = APPDATA.chatboxlist;\r\n    const len = chatboxlist.length;\r\n    chatboxlist.forEach((chatbox, i) => {\r\n      chattask.appendnewchatlistitem(chatbox, i, chatboxlist.length);\r\n    });\r\n  },\r\n\r\n  chatboxrefresh: function() {\r\n    const refreshchatboxdata = chtbxstkitem => {\r\n      switch (true) {\r\n        case (!chtbxstkitem.initcomplete): return;\r\n        default:\r\n        chattask.refreshchatboxinfo(chtbxstkitem);\r\n        chattask.refreshcbxprivilege(chtbxstkitem);\r\n        chattask.newcbxmemberjoin(chtbxstkitem);\r\n        chattask.updatecbxmemberinfo(chtbxstkitem);\r\n      }\r\n    }\r\n    ACBchatboxStackdata.some(refreshchatboxdata);\r\n  },\r\n\r\n  chatboxclean: function() {\r\n    const refreshchatboxdata = chtbxstkitem => {\r\n      switch (true) {\r\n        case (!chtbxstkitem.initcomplete): return;\r\n        default:\r\n        const findchatbox = chatbox => {if (chtbxstkitem.chatboxid == chatbox.chatboxid) return true;}\r\n        if(!APPDATA.chatboxlist.some(findchatbox)) {chattask.cleanchatboxstck(chtbxstkitem)};\r\n        chattask.cleancbxmemberlist(chtbxstkitem);\r\n      }\r\n    }\r\n    ACBchatboxStackdata.some(refreshchatboxdata);\r\n  },\r\n\r\n  getloadmoremessage: function () {\r\n    ACBchatboxStackdata.forEach(item => {\r\n      chattask.getloadmoremsg(item);\r\n    });\r\n  },\r\n\r\n  loadmoremessage: function () {\r\n    const setloadmore = item => {\r\n      if(item.NOMORE||!item.LOADMOREMESSAGE) return;;\r\n      item.LOADMOREMESSAGE = false;\r\n      chattask.loadmoremsg(item);\r\n    };\r\n    ACBchatboxStackdata.forEach(setloadmore);\r\n  }\r\n}\r\n\r\nconst chatsvctsktool = {\r\n\r\n  gettotalNoticecount: function () {\r\n    let count = APPNOTICE.makerelateRequest.length + APPNOTICE.invitechatboxNotify.length;\r\n    for (const item of APPNOTICE.chatboxUnreadmessage) {\r\n      count += item.totalnoticecount;\r\n    }\r\n    return count;\r\n  },\r\n\r\n  makeNewConversation: async function (chtbxstkitem) {\r\n    chattask.makenewConversation(chtbxstkitem);\r\n  },\r\n\r\n  clearOldConversation:async function (chtbxstkitem) {\r\n    chattask.clearOldConversation(chtbxstkitem);\r\n  },\r\n\r\n  load_receivedchtbxmsg_tocache:async function (chtbxstkitem) {\r\n    if(!chtbxstkitem.conversation) return;\r\n    if(!chtbxstkitem.initcomplete) return;\r\n\r\n    const chatboxUnreadmessage = await(serverchatcmnc.getChatboxUnreadmessage (chtbxstkitem.conversation.conversationid));// check match id and load\r\n    if (!chatboxUnreadmessage) return;\r\n    const setupReceiveChatdataCache = (convMessageitem, i) => {\r\n      //dont add double:\r\n      const getisdoubleitem = item => { if(item.unhideUsermindid==convMessageitem.unhideUsermindid) return true; }\r\n      const dontadddouble = chtbxstkitem.receive_chatdata_cache.some(getisdoubleitem);\r\n      if (dontadddouble) return;\r\n      const receivchat_data = {\r\n        unhideUsermindid: convMessageitem.unhideUsermindid,\r\n        unhideuserid: convMessageitem.unhideuserid,\r\n        datetimeUnhide: convMessageitem.datetimeUnhide,\r\n        messageData: convMessageitem.messageData,\r\n        datetimetell: convMessageitem.datetimetell,\r\n        readerid: convMessageitem.readerid,\r\n        datetimeread: convMessageitem.datetimeread,\r\n        sended: false,\r\n        success: false,\r\n        sendingcount: 0,\r\n        viewinbrowser: false,// wait for load to chatbox\r\n      };\r\n      setTimeout(function() {\r\n        chtbxstkitem.receive_chatdata_cache.push(receivchat_data);\r\n      }, 25);\r\n      if(i>50) return true;// for 50 per load\r\n    }\r\n    chatboxUnreadmessage.some(setupReceiveChatdataCache);\r\n  },\r\n\r\n  load_streamdata_tocache:async function (chtbxstkitem) {\r\n    if(!chtbxstkitem.conversation) return;\r\n    if(!chtbxstkitem.initcomplete) return;\r\n    const chatboxStreamdatareceiv = await serverstreamcmnc.getChatboxUnreadmessage(chtbxstkitem.conversation.conversationid);\r\n\r\n    const setupReceiveMultimediafile = (convMmediafileitem, i) => {\r\n      //dont add double:\r\n      const getisdoubleitem = item => { if(item.unhideUsermindid==convMmediafileitem.unhideUsermindid) return true; }\r\n      const dontadddouble = chtbxstkitem.receive_streamdata_cache.some(getisdoubleitem);\r\n      if (dontadddouble) return;\r\n      const receivchat_data = {\r\n        unhideUsermindid: convMmediafileitem.unhideUsermindid,\r\n        unhideuserid: convMmediafileitem.unhideuserid,\r\n        datetimeUnhide: convMmediafileitem.datetimetell,\r\n        messageData: convMmediafileitem.messageData,\r\n        datetimetell: convMmediafileitem.datetimetell,\r\n        conversationid: convMmediafileitem.conversationid,\r\n        sended: false,\r\n        success: false,\r\n        sendingcount: 0,\r\n        viewinbrowser: false,// wait for load to chatbox\r\n      };\r\n      chtbxstkitem.receive_streamdata_cache.push(receivchat_data);\r\n      if(i>50) return true;// for 50 per load\r\n    }\r\n    if(chatboxStreamdatareceiv)\r\n    chatboxStreamdatareceiv.some(setupReceiveMultimediafile);\r\n  },\r\n}\r\n\n\n//# sourceURL=webpack://someLibName/./wpsrc/service/chattask/chatsvctsk.js?");

/***/ }),

/***/ "./wpsrc/service/chattask/chattask.js":
/*!********************************************!*\
  !*** ./wpsrc/service/chattask/chattask.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"init\": () => (/* binding */ init),\n/* harmony export */   \"chattask\": () => (/* binding */ chattask)\n/* harmony export */ });\nconst dmt = __webpack_require__(/*! ../../app/domtl */ \"./wpsrc/app/domtl.js\");\r\nconst chtlst = __webpack_require__(/*! ../../chat/chatapp */ \"./wpsrc/chat/chatapp.js\");\r\n\r\nlet serverstreamcmnc;\r\nlet serverchatcmnc;\r\nlet chbxcontrol;\r\nlet chtbxtool;\r\nlet serviceTool;\r\nlet USERDATA;\r\nlet CHATROOMTYPE;\r\nlet APPDATA;\r\nlet ACBchatboxStackdata\r\n\r\nconst init = function (myapp, srvcetool, cbtool, cbxcntrl, svrCom) {\r\n\r\n  serverstreamcmnc = svrCom.serverstreamcmnc;\r\n  serverchatcmnc = svrCom.serverchatcmnc;\r\n  chbxcontrol = cbxcntrl.chbxcontrol;\r\n  chtbxtool = cbtool.chtbxtool;\r\n  serviceTool = srvcetool.serviceTool;\r\n  USERDATA = myapp.USERDATA;\r\n  CHATROOMTYPE = myapp.CHATROOMTYPE;\r\n  APPDATA = myapp.APP.DATA;\r\n  ACBchatboxStackdata = myapp.ACTIVECHATBOX.chatboxStack.data;\r\n}\r\n\r\nconst chattask = {\r\n\r\n  chatboxactivestt: function (chatbox, chatlist) {\r\n      serverstreamcmnc.getactiveChatboxlist(chatlist)\r\n      .then(activeChatboxlist => {\r\n        const setupActive = item_ => {if (item_ == chatbox.chatboxid) return true;}\r\n        const active = (activeChatboxlist||[]).some(setupActive);\r\n        chattasktool.chatboxactivestate(chatbox.chatboxid, active);\r\n      });\r\n  },\r\n\r\n  chatlistonlinestt: function (chatbox) {\r\n    const setupOnline = item_ => {if (item_.userid != USERDATA.ID && item_.lasttimelogin) {if (serviceTool.is_Stillonline (item_.lasttimelogin)) {return true;}}}\r\n    const online = (chatbox.members||[]).some(setupOnline);\r\n    chattasktool.chtbxlstonlinestate(chatbox.chatboxid, online);\r\n  },\r\n\r\n  recentonlinestt: function (recentchtbx, chatboxlistitem) {\r\n    const setupOnline = item_ => {if (item_.userid!= USERDATA.ID && item_.lasttimelogin) if (serviceTool.is_Stillonline(item_.lasttimelogin)) {return true;}}\r\n    const online = (chatboxlistitem.members||[]).some(setupOnline);\r\n    chattasktool.recentonlinestate(recentchtbx.chatboxid, online);\r\n  },\r\n\r\n  memberonlinestt: function (chtbxstkitem) {\r\n    //update user chatbox online status\r\n    const setupOnline = item_ => {\r\n      if (item_.lasttimelogin)\r\n      switch (true) {\r\n        case serviceTool.is_Stillonline(item_.lasttimelogin):\r\n        chattasktool.chtbxusronlinestate(chtbxstkitem.chatboxid, item_.userid, true);\r\n        break;\r\n        default:\r\n        chattasktool.chtbxusronlinestate(chtbxstkitem.chatboxid, item_.userid, false);\r\n      }\r\n    }\r\n    (chtbxstkitem.members||[]).some(setupOnline);\r\n    return true;\r\n  },\r\n\r\n  // update chat\r\n  cleanchatboxstck: function (chtbxstkitem) {\r\n    chtbxstkitem.chatbox.remove();\r\n    ACBchatboxStackdata.remove(chtbxstkitem);\r\n  },\r\n\r\n  refreshchatboxinfo: function (chtbxstkitem) {\r\n    // if (!chtbxstkitem.members) return;\r\n    try {\r\n\r\n      chtbxstkitem.members.forEach(mem => {\r\n        switch (true) {\r\n          case (mem.userid != USERDATA.ID): return;\r\n          case (!mem.userchatboxname): return true;\r\n        }\r\n        const chatboxname = document.getElementById(\"chatboxnameID\"+ chtbxstkitem.chatboxid);\r\n        if (!chatboxname)return true;\r\n        switch (chatboxname.contentEditable) {case \"false\": chatboxname.innerHTML = mem.userchatboxname; break;}\r\n      });\r\n    } catch (e) {\r\n      console.log(chtbxstkitem.members);\r\n      console.log(\"chtbxstkitem\", JSON.stringify(chtbxstkitem));\r\n    }\r\n  },\r\n\r\n  newcbxmemberjoin: function (chtbxstkitem) {\r\n    const memberList = document.getElementById(\"memberID\"+chtbxstkitem.chatboxid);\r\n    switch (true) {\r\n      case (!memberList): {return};\r\n      case (!chtbxstkitem.members): return;\r\n    }\r\n    let USER_ISKEY = chtbxstkitem.members.some(item => {if(item.userid == USERDATA.ID) return item.chatboxuserkey;});\r\n    chtbxstkitem.members.forEach(mem => {\r\n      if(document.getElementById(\"memberitemID\" + chtbxstkitem.chatboxid + \"-\" + mem.userid)) return;// if exists\r\n      const memberitem = chtbxtool.creatememberitem(chtbxstkitem.chatboxid, mem.userid, mem.username, mem.lasttimelogin);\r\n\r\n      if (!USER_ISKEY|| mem.userid == USERDATA.ID) {\r\n        memberitem.setAttribute(\"isupdated\", true);\r\n        memberList.prepend(memberitem);\r\n        return;\r\n      }\r\n\r\n      // remove member button\r\n      switch (chtbxstkitem.type) {\r\n        case CHATROOMTYPE.TYPEGROUP:\r\n        const removemember = chtbxtool.creatermvmembutton(chtbxstkitem.chatboxid, mem.userid);\r\n        memberitem.appendChild(removemember);\r\n        memberitem.setAttribute(\"isupdated\", true);\r\n        memberList.prepend(memberitem);\r\n        break;\r\n        case CHATROOMTYPE.TYPEFRIEND:\r\n        memberitem.setAttribute(\"isupdated\", true);\r\n        memberList.prepend(memberitem);\r\n        break;\r\n      }\r\n    });// end for\r\n  },\r\n\r\n  updatecbxmemberinfo: function (chtbxstkitem) {\r\n    switch (true) {\r\n      case (!chtbxstkitem.members): return;\r\n    }\r\n    chtbxstkitem.members.forEach( mem => {\r\n      const memberusername = document.getElementById(\"memberusernameID\" +chtbxstkitem.chatboxid+\"-\"+ mem.userid);\r\n      if(memberusername){// update friend\r\n        memberusername.innerHTML = mem.username;\r\n        memberusername.parentNode.setAttribute(\"isupdated\", true);\r\n      }\r\n      const teamviewicon = document.getElementById(\"memberteamviewID\" + chtbxstkitem.chatboxid +\"-\"+ mem.userid);\r\n      if(teamviewicon)\r\n      if(mem.isstream){\r\n        teamviewicon.classList.remove(\"hidememberteamview\");\r\n      }\r\n      else {\r\n        teamviewicon.classList.add(\"hidememberteamview\");\r\n      }\r\n    });\r\n  },\r\n\r\n  cleancbxmemberlist: function (chtbxstkitem) {\r\n    for (var item of document.querySelectorAll(\"[chatboxid='\"+chtbxstkitem.chatboxid+\"'][class=memberitem]\")) {\r\n      switch (item.getAttribute(\"isupdated\")) {\r\n        case \"false\": item.remove(); continue;\r\n        case \"true\": item.setAttribute(\"isupdated\", false); continue;\r\n      }\r\n    }\r\n  },\r\n\r\n  refreshcbxprivilege: function (chtbxstkitem) {\r\n    const memberList = document.getElementById(\"memberID\"+chtbxstkitem.chatboxid);\r\n    switch (true) {\r\n      case (!memberList): return;\r\n      case (!chtbxstkitem.members): return;//async still not update yet\r\n    }\r\n    let USER_ISKEY = chtbxstkitem.members.some(item => {if(item.userid == USERDATA.ID) {return item.chatboxuserkey;}});\r\n    chtbxstkitem.members.forEach(mem => {\r\n      const memberitem = document.getElementById(\"memberitemID\" + chtbxstkitem.chatboxid + \"-\" + mem.userid);\r\n      if(!memberitem) return;// will be create\r\n\r\n      if (USER_ISKEY&& mem.userid!= USERDATA.ID)\r\n      switch (chtbxstkitem.type) {\r\n        case CHATROOMTYPE.TYPEGROUP:\r\n        if (document.getElementById(\"removememberitemID\"+chtbxstkitem.chatboxid+\"-\"+mem.userid)) break; // has remv -> break\r\n        removemember = chtbxtool.creatermvmembutton(+ chtbxstkitem.chatboxid, mem.userid);\r\n        memberitem.appendChild(removemember);\r\n        break;\r\n      }\r\n    });\r\n\r\n    const memberinvite = document.getElementById (\"memberinviteID\" + chtbxstkitem.chatboxid);\r\n    const leave = document.getElementById (\"leaveID\" + chtbxstkitem.chatboxid);\r\n    const dissolution = document.getElementById (\"dissolutionID\" + chtbxstkitem.chatboxid);\r\n    const livestreamitem = document.getElementById (\"livestreamID\" + chtbxstkitem.chatboxid);\r\n\r\n\r\n    switch (chtbxstkitem.type) {\r\n      case CHATROOMTYPE.TYPEGROUP:\r\n      if (!USER_ISKEY) {\r\n        if(memberinvite) memberinvite.remove();\r\n        if (dissolution) dissolution.remove();\r\n        break;\r\n      }\r\n      if (!memberinvite) {\r\n        const memberitem = chtbxtool.createmberinvteitem(chtbxstkitem.chatboxid);\r\n        memberList.appendChild(memberitem);\r\n      }\r\n      if (!leave) {\r\n        const leave = chtbxtool.createleaveitem(chtbxstkitem.chatboxid);\r\n        memberList.appendChild(leave);\r\n      }\r\n      if (!dissolution) {\r\n        const memberitem = chtbxtool.createdissolutionitem(chtbxstkitem.chatboxid);\r\n        memberList.appendChild(memberitem);\r\n      }\r\n      break;\r\n    }\r\n    if (!livestreamitem) {\r\n      const _livestreamitem = chtbxtool.createlivestreamitem(chtbxstkitem.chatboxid);\r\n      memberList.appendChild(_livestreamitem);\r\n    }\r\n\r\n  },\r\n\r\n  appendnewchatlistitem: function (chatbox, i, len) {\r\n    if(document.getElementById(\"chatlistitemID\" + chatbox.chatboxid)) return;\r\n    const chatlist = document.getElementById(\"chatlistID\");\r\n    const chatlistitembean = dmt.domtool.creatediv(\"chatlistitembean\");\r\n\r\n    const chatlistitem = dmt.domtool.creatediv(\"chatlistitem\", \"chatlistitemID\" + chatbox.chatboxid);\r\n    chatlistitem.classList.add(chatbox.type);\r\n    chatlistitem.setAttribute(\"isupdated\", true);\r\n    chatlistitem.setAttribute(\"chatboxid\", chatbox.chatboxid);\r\n    chatlistitem.addEventListener(\"mousedown\", chtlst.chtlsttool.chatlistitemSelect);\r\n\r\n    var chatboxisonline = false;\r\n    const setuponline = item_ => { if (item_.userid!= USERDATA.ID&&item_.lastdatetimelogin)if(is_Stillonline(item_.lastdatetimelogin)){chatboxisonline = true; return true;}};\r\n    (chatbox.members||[]).some(setuponline);\r\n    const onlinestatus = dmt.domtool.creatediv(\"onlinestatus\", \"onlinestatusID\" + chatbox.chatboxid);\r\n    onlinestatus.style.backgroundColor = (chatboxisonline?\"#06FF0B\":\"#cc0000\");\r\n    chatlistitem.appendChild(onlinestatus);\r\n\r\n    const chatlistitemname = chtlst.chtlsttool.createchtbxnamechatlistitem(chatbox.type, chatbox.chatboxid, chatbox.chatboxName);\r\n    const icon = chtlst.chtlsttool.getgrpiconchatlistitem(chatbox.type);\r\n    const chatlistitemactive = dmt.domtool.creatediv(\"chatlistitemactive\", \"chatlistitemactiveID\"+chatbox.chatboxid);\r\n\r\n    chatlistitem.appendChild(icon);\r\n    chatlistitem.appendChild(chatlistitemactive);\r\n    chatlistitem.appendChild(chatlistitemname);\r\n\r\n    const getUserchatboxname = item_ => { if (item_.userid== USERDATA.ID&&item_.userchatboxname){chatlistitemname.innerHTML = item_.userchatboxname; return true;}};\r\n    (chatbox.members||[]).some(getUserchatboxname);\r\n\r\n    const callbean = chtlst.chtlsttool.getcallitem(chatbox.chatboxid);\r\n    const notice = chtlst.chtlsttool.getnoticeitem(chatbox.chatboxid);\r\n\r\n    chatlistitem.appendChild(callbean);\r\n    chatlistitem.appendChild(notice);\r\n\r\n    switch (true) {\r\n      case (APPDATA.inited):\r\n      chatlistitem.style.animation = \"expandh 0.5s ease-in-out\";\r\n      chatlistitembean.appendChild(chatlistitem);\r\n      chatlist.prepend(chatlistitembean);\r\n      break;\r\n      case (!APPDATA.inited):\r\n      chatlistitembean.appendChild(chatlistitem);\r\n      chatlist.append(chatlistitembean);\r\n      break;\r\n    }\r\n    if(i==len-1){ APPDATA.inited = true;}\r\n  },\r\n\r\n  refreshchatlistitem: function (chatbox) {\r\n    const chatlistitem = document.getElementById(\"chatlistitemID\" + chatbox.chatboxid);\r\n    if(!chatlistitem) return ;\r\n    const chatlistitemname = document.getElementById(\"chatlistitemnameID\" + chatbox.chatboxid);\r\n    const getUserchatboxname = item_ => {if(item_.userid== USERDATA.ID&&item_.userchatboxname){chatlistitemname.innerHTML = item_.userchatboxname; return true;}};\r\n    (chatbox.members||[]).some(getUserchatboxname);\r\n    chatlistitem.setAttribute(\"isupdated\", true);\r\n  },\r\n\r\n  clearchatlistitem: async function () {\r\n    for (var item of document.getElementsByClassName(\"chatlistitem\")) {\r\n      switch (item.getAttribute(\"isupdated\")) {\r\n        case \"true\":\r\n        item.setAttribute(\"isupdated\", false);\r\n        break;\r\n        case \"false\":\r\n        const bean = item.parentNode;\r\n        bean.style.opacity = '0';\r\n        await setTimeout(function(){bean.parentNode.removeChild(bean);}, 200);\r\n        break;\r\n      }\r\n    }\r\n  },\r\n\r\n  makenewConversation: async function (chtbxstkitem) {\r\n    chtbxstkitem.conversation = (await serverchatcmnc.createConversation(chtbxstkitem.chatboxid));\r\n    console.log(\"new conversation\");\r\n  },\r\n\r\n  clearOldConversation: async function (chtbxstkitem) {\r\n    if(chtbxstkitem.conversation)\r\n    if (serviceTool.is_liveconversation(chtbxstkitem.conversation)) return;\r\n    const conversation = await(serverchatcmnc.getLastConversation(chtbxstkitem.chatboxid,\"undefined\"));\r\n    if (!conversation) return;\r\n    if (serviceTool.is_liveconversation(conversation)) {\r\n      chtbxstkitem.conversation = conversation;// update conversation\r\n      return;\r\n    }\r\n    if(chtbxstkitem.conversation == null) return;\r\n    console.log(\"remove conversation: \", conversation.conversationid, (new Date () - new Date (conversation.endAt)));\r\n    chtbxstkitem.conversation = null;\r\n  },\r\n\r\n  br_up_ap_havechange: {value:true, lastvalue:0},\r\n  browser_update_appNotify: function (totalnotice){\r\n    if(!this.br_up_ap_havechange.value)return;\r\n    switch (this.br_up_ap_havechange.lastvalue) {\r\n      case totalnotice: return;\r\n    }\r\n    const menunotify = document.getElementById(\"menunotifyID\");\r\n    const menunotifyvalue = document.getElementById(\"menunotifyvalueID\");\r\n    menunotifyvalue.innerHTML = totalnotice;\r\n    if(totalnotice==0) {\r\n      menunotify.classList.add(\"notify\");\r\n      menunotify.classList.remove(\"havenotify\");\r\n      return;\r\n    }\r\n    menunotify.classList.add(\"havenotify\");\r\n    menunotify.classList.remove(\"notify\");\r\n    this.br_up_ap_havechange.lastvalue = totalnotice;\r\n  },\r\n\r\n  browser_update_recentnotice: function (id, totalnoticecount) {\r\n    if(totalnoticecount === undefined) return ;\r\n    const recentnotice = document.getElementById (\"recentnoticeID\" + id);\r\n    if(!recentnotice) return;\r\n    const last = recentnotice.getAttribute(\"lastvalue\");\r\n    if (totalnoticecount==last) return;\r\n    recentnotice.setAttribute(\"lastvalue\", totalnoticecount);\r\n    const noticevalue = document.getElementById (\"recentnoticevalueID\" + id);\r\n    if (totalnoticecount == 0) {\r\n      recentnotice.classList.add (\"hidenotice\");\r\n      noticevalue.innerHTML = 0;\r\n      return;\r\n    }\r\n    recentnotice.classList.remove (\"hidenotice\");\r\n    noticevalue.innerHTML = totalnoticecount;\r\n  },\r\n\r\n  brownser_update_chatlistnotice: function (chatboxid, totalnoticecount) {\r\n    const chatlistitemnotice = document.getElementById (\"chatlistitemnotice\"+chatboxid);\r\n    switch (true) {\r\n      case (totalnoticecount === undefined): return ;\r\n      case (!chatlistitemnotice): return;\r\n      case (totalnoticecount==chatlistitemnotice.getAttribute(\"lastvalue\")): return ;\r\n    }\r\n    chatlistitemnotice.setAttribute(\"lastvalue\", totalnoticecount);\r\n    const chatlistitemnoticevalue = document.getElementById (\"chatlistitemnoticevalue\"+chatboxid);\r\n    switch (true) {\r\n      case (totalnoticecount == 0):\r\n      if(chatlistitemnoticevalue.innerHTML==0) return;\r\n      chatlistitemnotice.classList.add (\"hidenotice\");\r\n      chatlistitemnoticevalue.innerHTML = 0;\r\n      return;\r\n      break;\r\n      case (totalnoticecount != 0):\r\n      chatlistitemnotice.classList.remove (\"hidenotice\");\r\n      chatlistitemnoticevalue.innerHTML = totalnoticecount;\r\n      break;\r\n    }\r\n  },\r\n\r\n  brownser_show_seenmessage: async function (chtbxstkitem) {\r\n    const messagebox = chtbxstkitem.messagebox;\r\n    const members = chtbxstkitem.members;\r\n    if (!members) return;\r\n    const minY = messagebox.getBoundingClientRect().y;\r\n    const maxY = minY + messagebox.getBoundingClientRect().height;\r\n    let unhideUsermindid, seenlistitem, seenlist;\r\n    try {\r\n      for (var message of document.querySelectorAll(\"[class=userchatboxmessagae]\")) {\r\n        const pos = message.getBoundingClientRect().y;\r\n        switch (true) {\r\n          case (pos>maxY||pos<minY):continue;\r\n          case !(unhideUsermindid = message.parentNode.getAttribute(\"unhideusermindid\")):continue;\r\n          case !(seenlistitem = document.getElementById(\"seenlistitemID\" + unhideUsermindid)):continue;\r\n          case !(seenlist = await (serverchatcmnc.getSeenlist(unhideUsermindid))):continue;\r\n          case (seenlist.length == members.length):continue;\r\n        }\r\n        (seenlist||[]).forEach(item => {\r\n          const seenitem = document.getElementById(\"seenitemID\"+ unhideUsermindid +\"-\"+item.userid);\r\n          switch (true) {\r\n            case (seenitem): chtbxtool.updateseenitem(seenlistitem, item.userid, item.username, null); break;\r\n            case (!seenitem): chtbxtool.addseenitem(seenlistitem, item.userid, item.username, null); break;\r\n          }\r\n        });\r\n      }\r\n    } catch (e) {\r\n      console.log(seenlist, e);\r\n    }\r\n  },\r\n\r\n  brownser_insert_msgitmrecei_tochbx: async function (chtbxstkitem, itemToinsert) {\r\n    const checkexists = document.querySelectorAll(\"[unhideusermindid='\"+itemToinsert.unhideUsermindid+\"']\");\r\n    switch (true) {\r\n      case (checkexists.length>0): itemToinsert.viewinbrowser = true; return;\r\n      case (itemToinsert.viewinbrowser): return;\r\n      case (!chtbxstkitem.initcomplete): return;\r\n      case (chtbxstkitem.LOADMOREMESSAGEID != chtbxstkitem.LOADMOREMESSAGEDONEID): return;\r\n    }\r\n    const messagebox = chtbxstkitem.messagebox;\r\n    const messageitem = chtbxtool.createmessageitem(itemToinsert, chtbxstkitem.chatboxid);\r\n    const messagelist = document.querySelectorAll(\"[class='messageitem']\");\r\n    if (messagelist.length==0) {\r\n      messagebox.append(messageitem);\r\n      itemToinsert.viewinbrowser = true;\r\n      chbxcontrol.chtbxautoscrolllast(chtbxstkitem.chatboxid);\r\n      return;\r\n    }\r\n\r\n    let inserted = false;\r\n    const len = messagelist.length;\r\n    const d = len - (10*chtbxstkitem.members.length); // max to delay\r\n    for (let i = (d<0?0:d); i < len; i++) {\r\n      const unhideusermindid = messagelist[i].getAttribute(\"unhideusermindid\");\r\n      if (!messagebox.contains(messagelist[i])) continue;\r\n\r\n      if(!unhideusermindid) return;//wait for update\r\n      if(itemToinsert.unhideUsermindid>unhideusermindid){\r\n        if(i==len-1){\r\n          messagebox.insertBefore (messageitem, messagelist[i].nextSibling);\r\n          inserted = true;\r\n          break; // insertAfter\r\n        }\r\n        continue;\r\n      }\r\n      if (itemToinsert.unhideUsermindid<unhideusermindid) {\r\n        messagebox.insertBefore(messageitem, messagelist[i]);\r\n        inserted = true;\r\n        break; // insertAfter\r\n      }\r\n    }\r\n    if (!inserted)return;\r\n    chbxcontrol.chtbxautoscrolllast(chtbxstkitem.chatboxid);\r\n    itemToinsert.viewinbrowser = true;\r\n  },\r\n\r\n  brownser_insert_mmfitmrecei_tochbx: async function (chtbxstkitem, itemToinsert) {\r\n    const messagebox = chtbxstkitem.messagebox;\r\n    const messageitem = chtbxtool.createmultimediafileitem(itemToinsert, chtbxstkitem.chatboxid, true);\r\n    messagebox.append(messageitem);\r\n    itemToinsert.viewinbrowser = true;\r\n    itemToinsert.success = true;\r\n    chbxcontrol.chtbxautoscrolllast(chtbxstkitem.chatboxid);\r\n  },\r\n\r\n  resort_msgitmrecei_inchbx: async function (chtbxstkitem, item) {// sort in curr conversation\r\n    const messagebox = chtbxstkitem.messagebox;\r\n    for (var item of document.querySelectorAll(\"[chatboxid='\"+chtbxstkitem.chatboxid+\"'][iscurrconversatt='true']\")) {\r\n      if (!item.nextSibling) continue;\r\n      const _item_id = parseInt(item.getAttribute(\"unhideUsermindid\")),\r\n      _nextitem_id = parseInt(item.nextSibling.getAttribute(\"unhideUsermindid\"));\r\n      if (_item_id > _nextitem_id) {\r\n        messagebox.insertBefore(item.nextSibling, item);\r\n      }\r\n    }\r\n  },\r\n\r\n  browser_updt_chbxmsgitem_sendedstt: function (item) {\r\n    const messageitem = document.getElementById (\"tempmessageitemID\"+item.post_data_id);\r\n    if (!messageitem) return;\r\n    const hidemessageinfo = document.getElementById (\"tempmessageinfoID\"+item.post_data_id);\r\n    const messgetext = document.getElementById (\"tempmessagetextID\"+item.post_data_id);\r\n    const checksened = document.getElementById(\"checksenedID\" + item.post_data_id);\r\n    switch (true) {\r\n      case (item.success):\r\n      messageitem.id = \"messageitemID\" + item.resID;\r\n      messageitem.setAttribute(\"unhideUsermindid\", item.resID);\r\n      messageitem.setAttribute(\"chatboxid\", item.chatboxid);\r\n      messageitem.setAttribute(\"iscurrconversatt\", true);// for sort\r\n      messageitem.setAttribute(\"sended\", item.post_data_id);\r\n      hidemessageinfo.id = \"messageinfoID\" + item.resID;\r\n      hidemessageinfo.className = \"hidemessageinfo\";\r\n      hidemessageinfo.innerHTML = \"sended\";\r\n      checksened.className = \"checksened\";\r\n      checksened.id = \"checksenedID\" + item.resID;\r\n      messgetext.id = \"message_dataID\" + item.resID;\r\n      messgetext.setAttribute(\"unhideUsermindid\", item.resID);\r\n      messgetext.addEventListener(\"click\", chbxcontrol.showinfomessage);\r\n      const messgetextbean = messgetext.parentNode;\r\n      const seenlistitem = chtbxtool.createseenlist(item.resID);\r\n      messgetextbean.appendChild(seenlistitem);\r\n      hidemessageinfo.innerHTML = item.datetimesend;\r\n      messgetext.classList.remove(\"messgetextpresend\");\r\n      break;\r\n      case (!item.success):\r\n      // message has sened fail\r\n      hidemessageinfo.innerHTML = \"send fail, click to resend\";\r\n      hidemessageinfo.className = \"messageinfo\";\r\n      messgetext.addEventListener (\"click\", function(){\r\n        const messageitem = document.getElementById (\"sended\" + item.post_data_id);\r\n        if (!messageitem||!item.sended) return;\r\n        messageitem.id = \"tempmessageitemID\" + item.post_data_id;\r\n        //show hand to user resend\r\n        item.sended = false;\r\n        item.success = false;\r\n        item.viewinbrowser = false;\r\n        messgetext.style.backgroundColor = \"\";\r\n      });\r\n      messgetext.style.backgroundColor = \"#E00003\";\r\n      messgetext.style.borderColor = \"#a80003\";\r\n      break;\r\n    }\r\n    // for give it\r\n    item.updateinbrowser = true;\r\n  },\r\n\r\n  getloadmoremsg: function (chtbxstkitem) {\r\n    switch (true) {\r\n      case (!chtbxstkitem.messagebox): return ;\r\n      case (chtbxstkitem.messagebox.scrollTop==0): chtbxstkitem.LOADMOREMESSAGE = true;//scrollTop==0\r\n      return;\r\n    }\r\n    chtbxstkitem.LOADMOREMESSAGE = false;\r\n  },\r\n\r\n  loadmoremsg: async function (chtbxstkitem){\r\n    switch (true) {\r\n      case (chtbxstkitem.LOADMOREMESSAGEID != chtbxstkitem.LOADMOREMESSAGEDONEID): return;\r\n      case (!chtbxstkitem.initcomplete): return ;\r\n    }\r\n    let firstconverstationinfo;\r\n    let conversationData = [];\r\n    const chatboxid = chtbxstkitem.chatboxid;\r\n    const messagebox = chtbxstkitem.messagebox;\r\n\r\n    //get first converstationinfo showed in chatbox\r\n\r\n    firstconverstationinfo = messagebox.getElementsByClassName('converstationinfo')[0];// get top conversaation\r\n    if (!firstconverstationinfo)return;\r\n    const firstconverstationid = firstconverstationinfo.getAttribute(\"conversationid\");\r\n    const converstationEndat = firstconverstationinfo.firstChild.getAttribute(\"endAt\");\r\n    const olderMsg = messagebox.getElementsByClassName('messageitem')[0]; // get curr oldest message in chatbox\r\n    if (olderMsg) {\r\n      const unhideUsermindid = olderMsg.getAttribute(\"unhideUsermindid\");\r\n      conversationData = await (serverchatcmnc.getconversationData(firstconverstationid, unhideUsermindid));\r\n    }\r\n    if(conversationData.length==0||!olderMsg) {// add new conversation to loadmoremsg\r\n      // get older conversation\r\n      const conversation = await (serverchatcmnc.getLastConversation(chatboxid, converstationEndat));\r\n      if (!conversation) {\r\n        chtbxstkitem.NOMORE = true;\r\n        const nomore = dmt.domtool.creatediv(\"nomore\");\r\n        nomore.innerHTML = \"No more message\"\r\n        messagebox.prepend(nomore);\r\n        return;\r\n      }\r\n\r\n      if (document.querySelectorAll(\"[conversationid='\"+conversation.conversationid+\"']\").length>0) return; //check exists\r\n\r\n      const converstationinfo = dmt.domtool.creatediv(\"converstationinfo\");\r\n      converstationinfo.setAttribute(\"conversationid\", conversation.conversationid);\r\n      const converstationstartat = dmt.domtool.creatediv(\"converstationstartat\");\r\n      converstationstartat.setAttribute(\"endAt\", conversation.endAt);\r\n      converstationstartat.innerHTML = new Date(conversation.startAt);\r\n      converstationinfo.append(converstationstartat);\r\n      messagebox.prepend(converstationinfo);// add new conversation to loadmoremsg\r\n\r\n      firstconverstationinfo = converstationinfo;\r\n      conversationData = await (serverchatcmnc.getconversationData(conversation.conversationid));\r\n    }\r\n    if(conversationData[0]) { // load data conversation\r\n      chtbxstkitem.LOADMOREMESSAGEID /*for sync*/ = conversationData[0].unhideUsermindid;\r\n      chtbxstkitem.LOADMOREMESSAGEDONEID = await chtbxtool.fillconversation (chtbxstkitem, firstconverstationinfo, conversationData, messagebox);\r\n    }\r\n    if (!chbxcontrol.getUserisscrollbox(chatboxid)) {\r\n      chbxcontrol.chtbxautoscrolllast(chatboxid);\r\n      return ;\r\n    }\r\n    messagebox.scrollTop = 1;\r\n  },\r\n}\r\n\r\nconst chattasktool = {\r\n  chatboxactivestate: function (chatboxid, online) {\r\n    const activestatus = document.getElementById(\"chatlistitemactiveID\" + chatboxid);\r\n    if(!activestatus) return ;\r\n    activestatus.style.backgroundColor = (online?\"#06FF0B\":\"#cc0000\");\r\n  },\r\n\r\n  recentonlinestate: function(chatboxid, online) {\r\n    const onlinestatus = document.getElementById(\"recentonlinestatusID\" + chatboxid);\r\n    if(!onlinestatus) return ;\r\n    onlinestatus.style.backgroundColor = (online?\"#06FF0B\":\"#cc0000\");\r\n  },\r\n\r\n  chtbxlstonlinestate: function(chatboxid, online) {\r\n    const onlinestatus = document.getElementById (\"onlinestatusID\"+chatboxid);\r\n    if(!onlinestatus) return ;\r\n    onlinestatus.style.backgroundColor = (online?\"#06FF0B\":\"#cc0000\");// make icon\r\n  },\r\n\r\n  chtbxusronlinestate: function(chatboxid, userid, online) {\r\n    const onlinestatus = document.getElementById(\"chatboxUseronlinestatusID\" + chatboxid + \"-\" + userid);\r\n    if(!onlinestatus) return ;\r\n    onlinestatus.style.backgroundColor = (online?\"#06FF0B\":\"#cc0000\");// make icon\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack://someLibName/./wpsrc/service/chattask/chattask.js?");

/***/ }),

/***/ "./wpsrc/service/service.js":
/*!**********************************!*\
  !*** ./wpsrc/service/service.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"init\": () => (/* binding */ init),\n/* harmony export */   \"_chatService\": () => (/* binding */ _chatService)\n/* harmony export */ });\nlet chatsvctsk;\r\nlet teamvwtask;\r\nlet serviceTool;\r\nlet sleep;\r\nlet UPDATER;\r\nlet APPDATA;\r\n\r\nconst init = function (myapp, chsvtsk, tmvwtsk, srvcetool) {\r\n\r\n  sleep = myapp.sleep;\r\n  chatsvctsk = chsvtsk.chatsvctsk;\r\n  teamvwtask = tmvwtsk.teamvwtask;\r\n  serviceTool = srvcetool.serviceTool;\r\n  UPDATER = myapp.UPDATER;\r\n  APPDATA = myapp.APP.DATA;\r\n  _chatService.startchatService();\r\n}\r\n\r\nclass chatService {\r\n\r\n  constructor () {\r\n    this.isstart = false;\r\n    this.dpsleep;\r\n  }\r\n\r\n  startchatService() {\r\n    this.dpsleep = new serviceTool.Deepsleep();\r\n    this.isstart = true;\r\n    this.initService();\r\n    this.startUpdater();\r\n  }\r\n\r\n  wakeupService() {\r\n    new Promise(function(resolve, reject) {\r\n      chatService.prototype.clearService();\r\n      chatService.prototype.initService();\r\n      resolve();\r\n    }).then(async ()=>{\r\n      await this.startUpdater(true);\r\n      console.log(\"service wakeup\");\r\n    });\r\n  }\r\n\r\n  initService(){\r\n    serviceTool.resetTicket();\r\n    serviceTool.resetDelay();\r\n  }\r\n\r\n  clearService(){\r\n    serviceTool.clearUpdater();\r\n  }\r\n\r\n  async startUpdater(wakeup){\r\n    this.useraction();\r\n    if (wakeup) await sleep(200);\r\n    this.cnf();\r\n    if (wakeup) await sleep(200);\r\n    this.beat();\r\n    if (wakeup) await sleep(200);\r\n    this.onlinestatus();\r\n    if (wakeup) await sleep(200);\r\n    this.newevent();\r\n    if (wakeup) await sleep(200);\r\n    this.servercache();\r\n    if (wakeup) await sleep(200);\r\n    this.brownsercache();\r\n    if (wakeup) await sleep(200);\r\n  }\r\n\r\n  useraction(){\r\n    UPDATER.useractionrate.timeoutid = setInterval(async ()=> {\r\n\r\n      chatsvctsk.showchatbox();\r\n      chatsvctsk.closechatbox();\r\n      chatsvctsk.removechatbox();\r\n    }, UPDATER.useractionrate.delay);\r\n  }\r\n\r\n  cnf() {\r\n    // cooldown and feedback\r\n    UPDATER.cnfrate.timeoutid = setInterval(async ()=> {\r\n      serviceTool.cooldownandfeedback.neweventcnf();\r\n      serviceTool.cooldownandfeedback.servercachecnf();\r\n      serviceTool.cooldownandfeedback.brownsercachecnf();\r\n    }, UPDATER.cnfrate.delay);\r\n  }\r\n\r\n  /**\r\n  *\r\n  *\r\n  * // SERVICE BEAT (SERVICE)\r\n  * wakeup Service\r\n  * say to server i still online\r\n  * say to server i still on stream\r\n  * get is touched\r\n  * feedback touch\r\n  *\r\n  */\r\n  beat() {\r\n    UPDATER.beatrate.timeoutid = setInterval(async () => {\r\n      try {\r\n        //user stream\r\n        teamvwtask.userisslivetream();\r\n\r\n        // user still online\r\n        chatsvctsk.userstillonline();\r\n\r\n\r\n        chatsvctsk.userstilllivestream();\r\n\r\n        // update Touch:\r\n        chatsvctsk.gettouch();\r\n\r\n        // wakeup And deep sleep service\r\n        chatsvctsk.wakeup(this);\r\n\r\n        //feedback touch\r\n        chatsvctsk.feedback(this);\r\n\r\n        // wakeup And deep sleep service\r\n        chatsvctsk.deepslp(this);\r\n\r\n        //refresh chat list\r\n        chatsvctsk.updatechatboxlistdata();\r\n\r\n        //update chat box data\r\n        chatsvctsk.updatechatboxstack();\r\n\r\n        //update new conversation: (time out 1s)\r\n        chatsvctsk.updateconversation();\r\n\r\n\r\n      } catch (e) {\r\n        console.log(e);\r\n      }\r\n\r\n      // console.log(TOUCH, myapp .TOUCH.VOTEUPDATE, UPDATERRATE);\r\n    }, UPDATER.beatrate.delay);\r\n  }\r\n\r\n  /**\r\n  *\r\n  * //KEEP APP ONLINE (SERVICE)\r\n  *\r\n  * token extend:\r\n  * updatr chtabox mem online state:\r\n  */\r\n\r\n  onlinestatus() {\r\n    UPDATER.olnstatusrate.timeoutid = setInterval( async ()=>{\r\n      try {\r\n        //tokenExtend\r\n        await chatsvctsk.tokenExtend();\r\n\r\n        //online state:\r\n\r\n        //update chtbxlist active\r\n        chatsvctsk.updtchtbxlistactivestt();\r\n\r\n        //update chtbxlist\r\n        chatsvctsk.updtchtbxlistonlinestt();\r\n\r\n        //update recent\r\n        chatsvctsk.updtrecentchtbxonlinestt();\r\n\r\n        //update member\r\n        chatsvctsk.updtchtbxmemberonlinestt();\r\n\r\n      } catch (e) {\r\n        console.log(e);\r\n      }\r\n\r\n    }, UPDATER.olnstatusrate.delay);\r\n  }\r\n\r\n  /**\r\n  *\r\n  * // GET NEW EVENT (SERVICE)\r\n  * wakeup service. get new event. vote update touch, refresh tikect, refresh touch\r\n  */\r\n  async newevent () {\r\n    while (true) {\r\n      try {\r\n        // event\r\n        chatsvctsk.getmakerelateevent();\r\n\r\n        // event\r\n        chatsvctsk.getinvitechatboxevent();\r\n\r\n        // event\r\n        chatsvctsk.getchatnotievent();\r\n\r\n        // refresh\r\n        chatsvctsk.chatlistrefresh();\r\n\r\n\r\n        chatsvctsk.newchatlistitem();\r\n\r\n\r\n        chatsvctsk.clearchatlistitem();\r\n\r\n\r\n        chatsvctsk.chatboxrefresh();\r\n\r\n\r\n        chatsvctsk.chatboxclean();\r\n\r\n\r\n        chatsvctsk.refreshmsgreceivecache();\r\n\r\n\r\n        chatsvctsk.refreshmmfreceivecache();\r\n\r\n\r\n        chatsvctsk.refreshcbsendingcache();\r\n\r\n      } catch (e) {\r\n        console.log(e);\r\n      }\r\n\r\n      //service delay\r\n      await new Promise(resolve => {UPDATER.neweventrate.timeoutid = setTimeout(resolve, UPDATER.neweventrate.delay)});\r\n    }\r\n  } /** //END newevent */\r\n\r\n  /**\r\n  *\r\n  * //LOAD DATA FROM SERVER AND SETUP (SERVICE)\r\n  * load data from server to cache:\r\n  */\r\n\r\n  async servercache () {\r\n\r\n    while (true){\r\n      try {\r\n\r\n        //load data from server to cache:\r\n        chatsvctsk.getchatdatafromserver();\r\n\r\n\r\n        chatsvctsk.getstreamdatafromserver();\r\n\r\n        chatsvctsk.clearConversation();\r\n\r\n        // item notify\r\n        chatsvctsk.setchatboxlistnotice();\r\n\r\n        // item notify\r\n        chatsvctsk.setrecentnotic();\r\n\r\n      } catch (e) {\r\n        console.log(e);\r\n      }\r\n\r\n      // service delay\r\n      await new Promise(resolve => {UPDATER.srvrcchrate.timeoutid = setTimeout(resolve, UPDATER.srvrcchrate.delay)});\r\n    }\r\n  } /** // END servercache */\r\n\r\n  /**\r\n  *\r\n  * //EXCUTE SETUPED CACHE DATA TO VIEW ELEMENT. SEND CHATDATA FROM CACHE TO SERVER (SERVICE)\r\n  * update browsers from cache:\r\n  * send and set readed chat data; update browsers - send message\r\n  */\r\n  async brownsercache() {\r\n    while (true) {\r\n      try {\r\n\r\n        chatsvctsk.setnewconversation();\r\n\r\n        //send and set readed chat data; update browsers - send message\r\n        await chatsvctsk.sendmessage();\r\n\r\n\r\n        chatsvctsk.updatemessagesended();\r\n\r\n        //send and set readed chat data; update browsers - send message\r\n        chatsvctsk.setmessagereaded();\r\n\r\n\r\n        chatsvctsk.setseenmessage();\r\n\r\n\r\n        chatsvctsk.insert_msgitmrecei_tochbx();\r\n\r\n\r\n        chatsvctsk.insert_mmfitmrecei_tochbx();\r\n\r\n\r\n        chatsvctsk.resort_receimsgitem_chtbx();\r\n\r\n\r\n        chatsvctsk.getloadmoremessage();\r\n\r\n        //load more mesg\r\n        chatsvctsk.loadmoremessage();\r\n\r\n        //notify brownser element update\r\n        chatsvctsk.showchatlistnotify();\r\n\r\n        //notify brownser element update\r\n        chatsvctsk.showrecentnotify();\r\n\r\n        //notify brownser element update\r\n        chatsvctsk.showappnotify();\r\n\r\n      } catch (e) {\r\n        console.log(e);\r\n      }\r\n\r\n      //service delay\r\n      await new Promise(resolve => {UPDATER.brnsrcchrate.timeoutid = setTimeout(resolve, UPDATER.brnsrcchrate.delay)});\r\n\r\n    }\r\n  } /** //END brownsercache*/\r\n\r\n\r\n  userhaveaAction() {\r\n\r\n    // wakeup And deep sleep service\r\n    if(serviceTool.serviceIsWakingup()) return ;\r\n\r\n    console.log(serviceTool.serviceIsWakingup(), \"Action\");\r\n\r\n    // update Touch:\r\n    chatsvctsk.gettouch();\r\n\r\n    this.wakeupService();\r\n  }\r\n  \r\n} /** // END CHAT SERVICE CLASS DECLARE */\r\n\r\n\r\n/**\r\n*\r\n* // DECLARE CHAT SERVICE: _chatService : ble ble\r\n*\r\n*/\r\nconst _chatService = new chatService();\r\n\n\n//# sourceURL=webpack://someLibName/./wpsrc/service/service.js?");

/***/ }),

/***/ "./wpsrc/service/servicetool.js":
/*!**************************************!*\
  !*** ./wpsrc/service/servicetool.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"init\": () => (/* binding */ init),\n/* harmony export */   \"serviceTool\": () => (/* binding */ serviceTool)\n/* harmony export */ });\nlet UPDATER;\r\nlet TIMEFORGIVE;\r\nlet VOTEUPDATE;\r\nlet sleep;\r\n\r\nconst init = function (myapp) {\r\n  UPDATER = myapp.UPDATER;\r\n  VOTEUPDATE = myapp.TOUCH.VOTEUPDATE;\r\n  TIMEFORGIVE = myapp.TIMEFORGIVE;\r\n  sleep = myapp.sleep;\r\n}\r\n\r\nconst serviceTool = {\r\n\r\n  cooldownandfeedback: {\r\n\r\n    delaycooldown: async function (updaterate) {\r\n      updaterate.delay += 1;\r\n      if (updaterate.delay < updaterate.fullpower)\r\n      for (var i = 0;i < updaterate.cldnrate;i++) {\r\n        await sleep(updaterate.cldndelay);\r\n        updaterate.delay += updaterate.cldnstep;\r\n        if (updaterate.delay >= updaterate.fullpower) break;\r\n      }\r\n      updaterate.delay = updaterate.fullpower;//ms\r\n    },\r\n\r\n    voteUpdateTouch: function(ticket){// SERVICE WILL VOTE WHEN delaycooldown TO UPDATE TOUCH\r\n      if(ticket.ticket==0) return;\r\n      VOTEUPDATE.updaterTotalVote +=ticket.ticket;\r\n      ticket.ticket = 0;\r\n      // console.log(\"voteUpdateTouch\");\r\n    },\r\n\r\n    brownsercachecnf: function () {\r\n      if(VOTEUPDATE.updaterTotalVote < 3) {// we still vote\r\n        //PREPARE END WAKE (SLEEP)\r\n        if(UPDATER.brnsrcchrate.delay >= UPDATER.brnsrcchrate.fullpower)\r\n        if(VOTEUPDATE.brownsercache.ticket > 0)\r\n        if(VOTEUPDATE.updaterTotalVote >= 2) // i'm later //brownsercache vote after get data from server:\r\n        this.voteUpdateTouch(VOTEUPDATE.brownsercache);\r\n      }//END WAKE\r\n      // cooldown\r\n      if (UPDATER.brnsrcchrate.delay > UPDATER.brnsrcchrate.limittocldn)return ;\r\n      this.delaycooldown (UPDATER.brnsrcchrate); // do delaycooldown\r\n    },\r\n\r\n    servercachecnf: function () {\r\n      if(VOTEUPDATE.updaterTotalVote < 3){ // we still vote\r\n        if(VOTEUPDATE.servercache.ticket>0)\r\n        if(UPDATER.srvrcchrate.delay >= UPDATER.srvrcchrate.fullpower)\r\n        this.voteUpdateTouch(VOTEUPDATE.servercache);\r\n      } // END WAKE\r\n      //delaycooldown\r\n      if (UPDATER.srvrcchrate.delay > UPDATER.srvrcchrate.limittocldn)return ;\r\n      this.delaycooldown (UPDATER.srvrcchrate);\r\n    },\r\n\r\n    neweventcnf: function () {\r\n      if(VOTEUPDATE.updaterTotalVote < 3) {// we still wake\r\n        if(VOTEUPDATE.newevent.ticket>0)\r\n        if(UPDATER.neweventrate.delay >= UPDATER.neweventrate.fullpower)\r\n        this.voteUpdateTouch(VOTEUPDATE.newevent);\r\n      }// END WAKE\r\n      //delaycooldown\r\n      if (UPDATER.neweventrate.delay > UPDATER.neweventrate.limittocldn)return ;\r\n      this.delaycooldown (UPDATER.neweventrate);\r\n    },\r\n  },\r\n\r\n  neweventraterefresh: function functionName() {\r\n    return new Promise(function(resolve, reject) {\r\n      UPDATER.neweventrate.delay = UPDATER.neweventrate.limittocldn;//updated now\r\n      resolve();\r\n    });\r\n  },\r\n\r\n  srvrcchraterefresh:function functionName() {\r\n    return new Promise(function(resolve, reject) {\r\n      UPDATER.srvrcchrate.delay = UPDATER.srvrcchrate.limittocldn;//updated now\r\n      resolve();\r\n    });\r\n  },\r\n\r\n  brnsrcchraterefresh:function functionName() {\r\n    return new Promise(function(resolve, reject) {\r\n      UPDATER.brnsrcchrate.delay = UPDATER.brnsrcchrate.limittocldn;//updated now\r\n      resolve();\r\n    });\r\n  },\r\n\r\n  clearUpdater: function () {\r\n    clearTimeout(UPDATER.neweventrate.timeoutid);\r\n    clearTimeout(UPDATER.srvrcchrate.timeoutid);\r\n    clearTimeout(UPDATER.brnsrcchrate.timeoutid);\r\n    clearTimeout(UPDATER.olnstatusrate.timeoutid);\r\n    clearTimeout(UPDATER.beatrate.timeoutid);\r\n    clearTimeout(UPDATER.cnfrate.timeoutid);\r\n    clearTimeout(UPDATER.useractionrate.timeoutid);\r\n  },\r\n\r\n  resetTicket: function () {\r\n    VOTEUPDATE.updaterTotalVote = 0;\r\n    VOTEUPDATE.newevent.ticket = 1;\r\n    VOTEUPDATE.servercache.ticket = 1;\r\n    VOTEUPDATE.brownsercache.ticket = 1;\r\n  },\r\n\r\n  resetDelay: function () {\r\n    UPDATER.neweventrate.delay = UPDATER.neweventrate.limittocldn;\r\n    UPDATER.srvrcchrate.delay = UPDATER.srvrcchrate.limittocldn;\r\n    UPDATER.brnsrcchrate.delay = UPDATER.brnsrcchrate.limittocldn;\r\n  },\r\n\r\n  serviceIsDeepsleep: function (){\r\n    if (UPDATER.neweventrate.delay>UPDATER.neweventrate.fullpower) return true;\r\n    if (UPDATER.srvrcchrate.delay>UPDATER.srvrcchrate.fullpower) return true;\r\n    if (UPDATER.brnsrcchrate.delay>UPDATER.brnsrcchrate.fullpower) return true;\r\n    return false;\r\n  },\r\n\r\n  serviceIsWakingup: function (){\r\n    if (UPDATER.neweventrate.delay<UPDATER.neweventrate.fullpower) return true;\r\n    if (UPDATER.srvrcchrate.delay<UPDATER.srvrcchrate.fullpower) return true;\r\n    if (UPDATER.brnsrcchrate.delay<UPDATER.brnsrcchrate.fullpower) return true;\r\n    return false;\r\n  },\r\n\r\n  Deepsleep: function(){\r\n    this.count = 0;\r\n    this.gotoDeepsleep = function () {\r\n      console.log(\"going to deepsleep...\");\r\n      UPDATER.neweventrate.delay = 100000;\r\n      UPDATER.srvrcchrate.delay = 100000;\r\n      UPDATER.brnsrcchrate.delay = 100000;\r\n    }\r\n  },\r\n\r\n  is_liveconversation: function (conversation) {\r\n    if ((new Date () - new Date (conversation.endAt)) < TIMEFORGIVE.CONVERSATION) return true;\r\n    return false;\r\n  },\r\n\r\n  is_Stillonline: function (date) {\r\n    if (!date) return false;\r\n    if ((new Date () - new Date (date)) > TIMEFORGIVE.ONLINE) return false;\r\n    return true;\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack://someLibName/./wpsrc/service/servicetool.js?");

/***/ }),

/***/ "./wpsrc/service/teamviewtask/teamvwtask.js":
/*!**************************************************!*\
  !*** ./wpsrc/service/teamviewtask/teamvwtask.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"init\": () => (/* binding */ init),\n/* harmony export */   \"teamvwtask\": () => (/* binding */ teamvwtask)\n/* harmony export */ });\nlet ACBchatboxStackdata;\r\nlet serverstreamcmnc;\r\n\r\nconst init = function (myapp, svrCom) {\r\n  ACBchatboxStackdata = myapp.ACTIVECHATBOX.chatboxStack.data;\r\n  serverstreamcmnc = svrCom.serverstreamcmnc;\r\n}\r\n\r\nconst teamvwtask = {\r\n\r\n  userisslivetream: function () {\r\n\r\n    ACBchatboxStackdata.forEach(async chtbxstkitem => {\r\n\r\n      const streamlist = await serverstreamcmnc.getuserstreamchatbox(chtbxstkitem.chatboxid);\r\n\r\n      const setupisstream = (mem, item_) => {\r\n        if (item_ == mem.userid) return true;\r\n      }\r\n\r\n      chtbxstkitem.members.forEach(mem => {\r\n        mem.isstream = (streamlist||[]).some(setupisstream.bind(null, mem));\r\n      });\r\n\r\n    });\r\n\r\n  },\r\n}\r\n\n\n//# sourceURL=webpack://someLibName/./wpsrc/service/teamviewtask/teamvwtask.js?");

/***/ }),

/***/ "./wpsrc/teamviewer/openscreenshare.js":
/*!*********************************************!*\
  !*** ./wpsrc/teamviewer/openscreenshare.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const playvideo = __webpack_require__(/*! ./playvideo */ \"./wpsrc/teamviewer/playvideo.js\");\r\nfunction startScreenshare() {\r\nconst option = { video: true, audio: true, }\r\n  try {\r\n    return navigator.mediaDevices.getDisplayMedia(option);\r\n  } catch (e) {\r\n    console.log(e);\r\n  }\r\n}\r\n\r\nmodule.exports = startScreenshare;\r\n\n\n//# sourceURL=webpack://someLibName/./wpsrc/teamviewer/openscreenshare.js?");

/***/ }),

/***/ "./wpsrc/teamviewer/playvideo.js":
/*!***************************************!*\
  !*** ./wpsrc/teamviewer/playvideo.js ***!
  \***************************************/
/***/ ((module) => {

eval("function openVideo(video, stream) {\r\n  video.srcObject = stream;\r\n}\r\nmodule.exports = openVideo;\r\n\n\n//# sourceURL=webpack://someLibName/./wpsrc/teamviewer/playvideo.js?");

/***/ }),

/***/ "./wpsrc/teamviewer/screencapture.js":
/*!*******************************************!*\
  !*** ./wpsrc/teamviewer/screencapture.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"init\": () => (/* binding */ init),\n/* harmony export */   \"screensharetool\": () => (/* binding */ screensharetool)\n/* harmony export */ });\nconst dmt = __webpack_require__(/*! ../app/domtl */ \"./wpsrc/app/domtl.js\");\r\nlet tvwcntrl;\r\nconst init = function (_tvwcntrl) {\r\n  tvwcntrl = _tvwcntrl;\r\n}\r\n\r\nconst screensharetool = {\r\n\r\n  getshareinterface: function (chatboxid, userid) {\r\n\r\n    const teamviewwindow = dmt.domtool.creatediv(\"teamviewwindow\", \"teamviewwindowID\"+chatboxid+\"-\"+userid);\r\n    const teamviewcontrolbean = dmt.domtool.creatediv(\"teamviewcontrolbean\");\r\n    const teamviewcontrol = dmt.domtool.creatediv(\"teamviewcontrol\", \"teamviewcontrolID\"+chatboxid+\"-\"+userid);\r\n    teamviewcontrol.setAttribute(\"chatboxid\", chatboxid);\r\n    teamviewcontrol.setAttribute(\"userid\", userid);\r\n    const teamviewclose = dmt.domtool.creatediv(\"teamviewclose\", \"teamviewcloseID\"+chatboxid+\"-\"+userid);\r\n    teamviewclose.classList.add(\"teamviewcontrolitem\");\r\n    teamviewclose.setAttribute('chatboxid', chatboxid);\r\n    teamviewclose.setAttribute('userid', userid);\r\n    teamviewclose.addEventListener('click', tvwcntrl.twcontrol.teamviewclose);\r\n\r\n    teamviewclose.innerHTML = \"close\";\r\n    const teamviewmaximize = dmt.domtool.creatediv(\"teamviewmaximize\", \"teamviewmaximizeID\"+chatboxid+\"-\"+userid);\r\n    teamviewmaximize.innerHTML = \"max\";\r\n    teamviewmaximize.classList.add(\"teamviewcontrolitem\");\r\n    const teamviewminimize = dmt.domtool.creatediv(\"teamviewminimize\", \"teamviewminimizeID\"+chatboxid+\"-\"+userid);\r\n    teamviewminimize.innerHTML = \"min\";\r\n    teamviewminimize.classList.add(\"teamviewcontrolitem\");\r\n    const teamviewscreenbean = dmt.domtool.creatediv(\"teamviewscreenbean\");\r\n    const teamviewscreen = dmt.domtool.createvideo(\"teamviewscreen\", \"teamviewscreenID\"+chatboxid+\"-\"+userid);\r\n    teamviewscreen.autoplay = true;\r\n    teamviewscreen.controls = true;\r\n\r\n    const startcapture = dmt.domtool.creatediv(\"startcapture\", \"start\");\r\n    startcapture.innerHTML = \"start\";\r\n    startcapture.classList.add(\"teamviewcontrolitem\");\r\n    startcapture.setAttribute(\"chatboxid\", chatboxid);\r\n    startcapture.setAttribute(\"userid\", userid);\r\n    startcapture.addEventListener(\"click\", function(evt) {\r\n      const chatboxid = this.getAttribute(\"chatboxid\");\r\n      const userid = this.getAttribute(\"userid\");\r\n      const teamviewscreen = document.getElementById(\"teamviewscreenID\"+chatboxid+\"-\"+userid);\r\n      tvwcntrl.twcontrol.startCapture(teamviewscreen, chatboxid, userid);\r\n    }, false);\r\n\r\n    const stopcapture = dmt.domtool.creatediv(\"stopcapture\", \"stop\");\r\n    stopcapture.innerHTML = \"stop\";\r\n    stopcapture.classList.add(\"teamviewcontrolitem\");\r\n    stopcapture.setAttribute(\"chatboxid\", chatboxid);\r\n    stopcapture.setAttribute(\"userid\", userid);\r\n    stopcapture.addEventListener(\"click\", function(evt) {\r\n      const chatboxid = this.getAttribute(\"chatboxid\");\r\n      const userid = this.getAttribute(\"userid\");\r\n      const teamviewscreen = document.getElementById(\"teamviewscreenID\"+chatboxid+\"-\"+userid);\r\n      tvwcntrl.twcontrol.stopCapture(teamviewscreen);\r\n    }, false);\r\n\r\n    teamviewscreenbean.appendChild(teamviewscreen);\r\n    teamviewcontrol.appendChild(startcapture);\r\n    teamviewcontrol.appendChild(stopcapture);\r\n    teamviewcontrol.appendChild(teamviewminimize);\r\n    teamviewcontrol.appendChild(teamviewmaximize);\r\n    teamviewcontrol.appendChild(teamviewclose);\r\n    teamviewcontrolbean.appendChild(teamviewcontrol);\r\n    teamviewwindow.appendChild(teamviewcontrolbean);\r\n    teamviewwindow.appendChild(teamviewscreenbean);\r\n    document.body.prepend(teamviewwindow);\r\n  },\r\n\r\n  getreceivedinterface: function (chatboxid, userid) {\r\n\r\n    const teamviewwindow = dmt.domtool.creatediv(\"teamviewwindow\", \"teamviewwindowID\"+chatboxid+\"-\"+userid);\r\n    const teamviewcontrolbean = dmt.domtool.creatediv(\"teamviewcontrolbean\");\r\n    const teamviewcontrol = dmt.domtool.creatediv(\"teamviewcontrol\", \"teamviewcontrolID\"+chatboxid+\"-\"+userid);\r\n    teamviewcontrol.setAttribute(\"chatboxid\", chatboxid);\r\n    teamviewcontrol.setAttribute(\"userid\", userid);\r\n    const teamviewclose = dmt.domtool.creatediv(\"teamviewclose\", \"teamviewcloseID\"+chatboxid+\"-\"+userid);\r\n    teamviewclose.classList.add(\"teamviewcontrolitem\");\r\n    teamviewclose.setAttribute('chatboxid', chatboxid);\r\n    teamviewclose.setAttribute('userid', userid);\r\n    teamviewclose.addEventListener('click', tvwcntrl.twcontrol.teamviewclose);\r\n    teamviewclose.innerHTML = \"close\";\r\n    const teamviewmaximize = dmt.domtool.creatediv(\"teamviewmaximize\", \"teamviewmaximizeID\"+chatboxid+\"-\"+userid);\r\n    teamviewmaximize.innerHTML = \"max\";\r\n    teamviewmaximize.classList.add(\"teamviewcontrolitem\");\r\n    const teamviewminimize = dmt.domtool.creatediv(\"teamviewminimize\", \"teamviewminimizeID\"+chatboxid+\"-\"+userid);\r\n    teamviewminimize.innerHTML = \"min\";\r\n    teamviewminimize.classList.add(\"teamviewcontrolitem\");\r\n    const teamviewscreenbean = dmt.domtool.creatediv(\"teamviewscreenbean\");\r\n    const teamviewscreen = dmt.domtool.createvideo(\"teamviewscreen\", \"teamviewscreenID\"+chatboxid+\"-\"+userid);\r\n    teamviewscreen.setAttribute(\"chatboxid\", chatboxid);\r\n    teamviewscreen.setAttribute(\"userid\", userid);\r\n    teamviewscreen.onplay = tvwcntrl.twcontrol.teamviewscreenonplay;\r\n    teamviewscreen.autoplay = true;\r\n    // teamviewscreen.controls = true;\r\n\r\n    const receiver = dmt.domtool.creatediv(\"receiver\", \"receiver\");\r\n    receiver.innerHTML = \"receiver\";\r\n    receiver.classList.add(\"teamviewcontrolitem\");\r\n    receiver.setAttribute(\"chatboxid\", chatboxid);\r\n    receiver.setAttribute(\"userid\", userid);\r\n    receiver.addEventListener(\"click\", function(evt) {\r\n      const chatboxid = this.getAttribute(\"chatboxid\");\r\n      const userid = this.getAttribute(\"userid\");\r\n      const teamviewscreen = document.getElementById(\"teamviewscreenID\"+chatboxid+\"-\"+userid);\r\n      tvwcntrl.twcontrol.receivestreamdata(teamviewscreen, chatboxid, userid);\r\n    }, false);\r\n\r\n\r\n    teamviewscreenbean.appendChild(teamviewscreen);\r\n    teamviewcontrol.appendChild(receiver);\r\n    teamviewcontrol.appendChild(teamviewminimize);\r\n    teamviewcontrol.appendChild(teamviewmaximize);\r\n    teamviewcontrol.appendChild(teamviewclose);\r\n    teamviewcontrolbean.appendChild(teamviewcontrol);\r\n    teamviewwindow.appendChild(teamviewcontrolbean);\r\n    teamviewwindow.appendChild(teamviewscreenbean);\r\n    document.body.prepend(teamviewwindow);\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack://someLibName/./wpsrc/teamviewer/screencapture.js?");

/***/ }),

/***/ "./wpsrc/teamviewer/teamview.js":
/*!**************************************!*\
  !*** ./wpsrc/teamviewer/teamview.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"init\": () => (/* binding */ init),\n/* harmony export */   \"teamviewtool\": () => (/* binding */ teamviewtool)\n/* harmony export */ });\nlet scrncapture;\r\nconst init = function (_scrncapture) {\r\n  scrncapture = _scrncapture;\r\n}\r\n\r\nconst teamviewtool = {\r\n\r\n  teamviewshare: function (chatboxid, userid) {\r\n    scrncapture.screensharetool.getshareinterface(chatboxid, userid);\r\n  },\r\n\r\n  teamviewreceive: function (chatboxid, userid) {\r\n    scrncapture.screensharetool.getreceivedinterface(chatboxid, userid);\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack://someLibName/./wpsrc/teamviewer/teamview.js?");

/***/ }),

/***/ "./wpsrc/teamviewer/tvwcontrol.js":
/*!****************************************!*\
  !*** ./wpsrc/teamviewer/tvwcontrol.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"init\": () => (/* binding */ init),\n/* harmony export */   \"twcontrol\": () => (/* binding */ twcontrol)\n/* harmony export */ });\nconst startScreenshare = __webpack_require__(/*! ./openscreenshare */ \"./wpsrc/teamviewer/openscreenshare.js\");\nconst Peer = __webpack_require__(/*! simple-peer */ \"./node_modules/simple-peer/index.js\");\n\nlet serverstreamcmnc;\nlet executeAsync;\nlet sleep;\n\nconst init = function (myapp, svrCom) {\n  executeAsync = myapp.executeAsync;\n  sleep = myapp.sleep;\n  serverstreamcmnc = svrCom.serverstreamcmnc;\n}\n\nconst twcontrol = {\n  teamviewscreenonplay: function () {\n    const chatboxid = this.getAttribute('chatboxid');\n    const userid = this.getAttribute('userid');\n    console.log(\"teamviewcontrolID\"+chatboxid+\"-\"+userid);\n    const teamviewcontrol = document.getElementById(\"teamviewcontrolID\"+chatboxid+\"-\"+userid);\n    const s = this.videoHeight / this.videoWidth;\n    const screenheight = parseInt(this.offsetWidth * s,10);\n    const controlbarheight = teamviewcontrol.offsetHeight;\n    const teamviewwindow = document.getElementById(\"teamviewwindowID\"+chatboxid+\"-\"+userid);\n    console.log(\"aasd:\", controlbarheight+screenheight);\n    teamviewwindow.style.height = (controlbarheight+screenheight) + \"px\";\n  },\n\n  startCapture: async function (teamviewscreen, chatboxid, userid) {\n    let peer;\n    let connected = false;\n    twcontrol.stopteamview = false;\n    await startScreenshare()\n    .then(stream => {\n      teamviewscreen.srcObject = stream;\n      peer = new Peer({ initiator: true, stream: stream });\n      peer.on('signal', async data => {\n        console.log(\"chatboxid, userid:\", chatboxid, userid);\n        const rs = await serverstreamcmnc.sendoffer(chatboxid, JSON.stringify(data));\n        console.log(\"sendoffer:\", rs);\n      });\n\n      peer.on('connect', () => {\n        // say to server we are connected\n        console.log('CONNECTED')\n        connected = true;\n        serverstreamcmnc.offersideconnected(chatboxid);\n      })\n    })\n    .catch(err => console.log(err));\n\n    executeAsync(async function() {\n      /****************************************************\n      * receive answer\n      *****************************************************/\n      for (var i = 0; i < 100; i++) {\n        await sleep(1000);\n        const answers = await serverstreamcmnc.getanswer(chatboxid);\n        console.log(\"answers:\", answers);\n        if (connected) break;\n        if (answers) {\n          if (answers.length==0)continue;\n          answers.forEach(answer => {\n            peer.signal(answer);\n            if (connected) return;\n          });\n        }\n      }\n    }, 5);\n  },\n\n  stopCapture: function (teamviewscreen) {\n    let tracks = teamviewscreen.srcObject.getTracks();\n    tracks.forEach(track => track.stop());\n    teamviewscreen.srcObject = null;\n  },\n\n  receivestreamdata: function (teamviewscreen, chatboxid, userid) {\n    let peer;\n    let connected = false;\n    executeAsync(async function() {\n      /****************************************************\n      * get stream info, receive data\n      *****************************************************/\n      peer = new Peer();\n      peer.on('signal', async data => {\n        const rs = await serverstreamcmnc.sendanswer(chatboxid, userid, JSON.stringify(data));\n        console.log(\"sendanswer:\", rs);\n      });\n\n      peer.on('stream', stream => {\n        teamviewscreen.srcObject = stream;\n      });\n\n      peer.on('connect', () => {\n        // say to server we are connected, and clear\n        connected = true;\n        console.log('CONNECTED')\n        serverstreamcmnc.answersideconnected(chatboxid, userid);\n      })\n\n      for (var i = 0; i < 100; i++) {\n        await sleep(1000);\n        const signdata = await serverstreamcmnc.getoffer(chatboxid, userid);\n        console.log(\"signdata:\", signdata);\n        if (connected) break;\n        signdata.forEach(data => {\n          peer.signal(data);\n          if (connected) return;\n        });\n      }\n    }, 5);\n\n  },\n\n  teamviewclose: function () {\n    twcontrol.stopteamview = true;\n    const chatboxid = this.getAttribute('chatboxid');\n    const userid = this.getAttribute('userid');\n    const teamviewwindowid = \"teamviewwindowID\"+chatboxid+\"-\"+userid;\n    const teamviewscreenid = \"teamviewscreenID\"+chatboxid+\"-\"+userid;\n    const teamviewwindow = document.getElementById(teamviewwindowid);\n    const teamviewscreen = document.getElementById(teamviewscreenid);\n    if (teamviewscreen.srcObject){\n      teamviewscreen.srcObject.getTracks().forEach(track => track.stop());\n    }\n    teamviewscreen.srcObject = null;\n    teamviewwindow.remove();\n    teamviewscreen.remove();\n  }\n}\n\n\n//# sourceURL=webpack://someLibName/./wpsrc/teamviewer/tvwcontrol.js?");

/***/ }),

/***/ "?6e84":
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/***/ (() => {

eval("/* (ignored) */\n\n//# sourceURL=webpack://someLibName/util_(ignored)?");

/***/ }),

/***/ "?2581":
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/***/ (() => {

eval("/* (ignored) */\n\n//# sourceURL=webpack://someLibName/util_(ignored)?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./wpsrc/app/appinit.js");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});